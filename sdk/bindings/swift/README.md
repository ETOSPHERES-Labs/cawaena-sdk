# Static ETOPay SDK library for iOS using swift-bridge crate

This library provides a set of bindings for integrating the ETOPay SDK with Swift applications. It allows developers to easily use the ETOPay functionality in their Swift projects. To generate the necessary library files, you can use the provided commands such as `cargo build --lib --release --target={architecture}`. Additionally, there are commands available for bundling the libraries and packaging them for export.

## Supported architectures

The library currently supports these architectures:

- `aarch64-apple-ios`: This architecture targets 64-bit ARM processors for iOS devices like iPhones and iPads.
- `aarch64-apple-darwin`: This architecture targets 64-bit ARM processors on macOS systems, enabling compatibility with Apple's hardware and software ecosystem.
- `x86_64-apple-darwin`: This architecture targets 64-bit Intel processors on macOS, facilitating development and execution of software on Apple's Intel-based Mac computers.
- `aarch64-apple-ios-sim`: This architecture targets 64-bit ARM processors running iOS simulators, typically used on Apple Silicon Macs.
- `x86_64-apple-ios`: This architecture targets 64-bit Intel processors for iOS simulators.

## Library generation

While working in dev container run a command to generate lib for one of supported architectures.

```bash
  cargo build --lib --release --target=aarch64-apple-ios
  cargo build --lib --release --target=aarch64-apple-darwin
  cargo build --lib --release --target=x86_64-apple-darwin
  cargo build --lib --release --target=aarch64-apple-ios-sim
  cargo build --lib --release --target=x86_64-apple-ios
```

To build a xcframework bundle for testing in iOS, use the following command:

```bash
make xcframework
```

This command needs to be executed on a Mac with xcode tools enabled and the xcode command line tools installed. This is because this needs lipo and xcode build commands.

## Generating iOS xcframeworks

The iOS ecosystem allows developers to create xcframeworks, which are a distribution format that contains multiple architectures and platforms in a single bundle. The xcframeworks offer advantages such as improved performance, reduced app size, and easier distribution and integration.

Our xcframework structure is as following:

- ETOPaySdkBin.xcframework/
  - ios-arm64/
    - Headers/
      - generated/
        - etopay-sdk-swift/
          - etopay-sdk-swift.h
        - SwiftBridgeCore.h
      - bridging-header.h
      - module.modulemap
    - libetopaysdk_cabi.a
  - ... (other architectures)

The creation can be done using the `xcodebuild` command, which takes the static library as input and an include section, which is actually a folder containing at most one module.modulemap file and any other C header files which describe the interface to the static library, assuming that it is C ABI.

The module map should include all the header files for working with the static library and re-export them as shown below.

```module.modulemap
module ETOPaySdkBin {
    header "bridging-header.h"
    export *
}
```

The module name is important here. It needs to have the name of the package binary which in our case is `ETOPaySdkBin`.

The `bridging-header.h` file includes the auto-generated files from the `swift-bridge` crate which we explain in more details on the `header files` section below.

The `lipo` utility is used to re-arrange the Rust generated static library with binary information. It allows developers to combine multiple architectures into a single binary file.

Installing an xcframework in the iOS app development environment is simply done by dragging and dropping the xcframework file in xcode or importing it using the settings menu.

## Swift package

Previously we were bundling our Swift bindings into a `.zip` file and exporting it. This was not very practical for the users and also for us since we need to bundle, download it and give it to our users manually. Instead, we want to offer it as a package. In this version we generate a Swift package instead which can be imported as a dependency. The structure of our Swift package is as following:

- ETOPaySdk/
  - ETOPaySdkBin.xcframework/
  - Sources/
    - ETOPaySdk/
      - SwiftBridgeCore.swift
      - etopay-sdk-swift.swift
      - utils.swift
  - Package.swift

The `ETOPaySdkBin.xcframework` creation and its internal structure is explained in the above `Generating iOS xcframeworks` section. The `SwiftBridgeCore.swift` and `etopay-sdk-swift.swift` files are auto-generated by the `swift-bridge` crate.

Finally, the `Package.swift` is the actual file that generates the Swift package called `ETOPaySdk`. In xcode we can add the ETOPaySdk package and initialize the constructor and call its functions (our Rust bindings):

```Swift
  import ETOPaySdk
  import Foundation

  let sdk = ETOPaySdk()
  try await sdk.getNetworks()
```

## Running Examples

We have a `compile_swift_main` on the `Makefile` can be run as a `test` to verify that the code compiles with success. It calls the `swift.main` file which calls our Rust bindings from Swift code. On `wsl` this command will only check check for compilations errors. On `mac` it will actually call our Rust functions and output the response.

**Note**: Examples need environmental variables in order to run successfully. Make sure to add a `.env` in the root directory: `sdk/bindings/swift/examples` with the corresponding values.

```
ALICE= 
MNEMONIC_ALICE=
USERNAME=
ARCHIEVEME= 
MNEMONIC=
PASSWORD=
KC_URL=
KC_REALM=
KC_CLIENT_ID=
KC_CLIENT_SECRET=
EXAMPLE_BACKEND_URL=
```
