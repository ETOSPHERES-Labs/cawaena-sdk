# Static cryptpay SDK library for iOS using swift-bridge crate

This library provides a set of bindings for integrating the CryptPay SDK with Swift applications. It allows developers to easily use the CryptPay functionality in their Swift projects. To generate the necessary library files, you can use the provided commands such as `cargo build --lib --release --target={architecture}`. Additionally, there are commands available for bundling the libraries and packaging them for export.

## Supported architectures

The library currently supports these architectures:

 - `aarch64-apple-ios`: This architecture targets 64-bit ARM processors for iOS devices like iPhones and iPads.
 - `aarch64-apple-darwin`: This architecture targets 64-bit ARM processors on macOS systems, enabling compatibility with Apple's hardware and software ecosystem.
 - `x86_64-apple-darwin`: This architecture targets 64-bit Intel processors on macOS, facilitating development and execution of software on Apple's Intel-based Mac computers.
 - `aarch64-apple-ios-sim`: This architecture targets 64-bit ARM processors running iOS simulators, typically used on Apple Silicon Macs.
 - `x86_64-apple-ios`: This architecture targets 64-bit Intel processors for iOS simulators.

## Library generation

While working in dev container run a command to generate lib for one of supported architectures.

```bash
  cargo build --lib --release --target=aarch64-apple-ios
  cargo build --lib --release --target=aarch64-apple-darwin
  cargo build --lib --release --target=x86_64-apple-darwin
  cargo build --lib --release --target=aarch64-apple-ios-sim
  cargo build --lib --release --target=x86_64-apple-ios
```

To build a xcframework bundle for testing in iOS, use the following command:

```bash
make xcframework
```
This command needs to be executed on a Mac with xcode tools enabled and the xcode command line tools installed. This is because this needs lipo and xcode build commands.

## Generating iOS xcframeworks

The iOS ecosystem allows developers to create xcframeworks, which are a distribution format that contains multiple architectures and platforms in a single bundle. The xcframeworks offer advantages such as improved performance, reduced app size, and easier distribution and integration.

Our xcframework structure is as following:

- CryptpaySdkBin.xcframework/
  - ios-arm64/
    - Headers/
      - generated/
        - cryptpay-sdk-swift/
          - cryptpay-sdk-swift.h
        - SwiftBridgeCore.h
      - bridging-header.h
      - module.modulemap
    - libwalletsdk_cabi.a
  - ... (other architectures)

The creation can be done using the `xcodebuild` command, which takes the static library as input and an include section, which is actually a folder containing at most one module.modulemap file and any other C header files which describe the interface to the static library, assuming that it is C ABI.

The module map should include all the header files for working with the static library and re-export them as shown below.

```module.modulemap
module CryptpaySdkBin {
    header "bridging-header.h"
    export *
}
```
The module name is important here. It needs to have the name of the package binary which in our case is `CryptpaySdkBin`.

The `bridging-header.h` file includes the auto-generated files from the `swift-bridge` crate which we explain in more details on the `header files` section below.

The `lipo` utility is used to re-arrange the Rust generated static library with binary information. It allows developers to combine multiple architectures into a single binary file.

Installing an xcframework in the iOS app development environment is simply done by dragging and dropping the xcframework file in xcode or importing it using the settings menu.

## Swift package

Previously we were bundling our Swift bindings into a `.zip` file and exporting it. This was not very practical for the users and also for us since we need to bundle, download it and give it to our users manually. Instead, we want to offer it as a package. In this version we generate a Swift package instead which can be imported as a dependency. The structure of our Swift package is as following:

- CryptpaySdk/
  - CryptpaySdkBin.xcframework/
  - Sources/
    - CryptpaySdk/
      - SwiftBridgeCore.swift
      - cryptpay-sdk-swift.swift
      - vectorizable.swift
  - Package.swift

The `CryptpaySdkBin.xcframework` creation and its internal structure is explained in the above `Generating iOS xcframeworks` section. The `SwiftBridgeCore.swift` and `cryptpay-sdk-swift.swift` files are auto-generated by the `swift-bridge` crate.

The `vectorizable.swift` contains custom implementations for Rust types which cannot be bridged directly to Swift. For example the `Vec<KycOpenDocument` type needs to implement the `Vectorizable` to compile in Swift. This is due to some limitations on the crate which need some workaround to compile properly.

Finally, the `Package.swift` is the actual file that generates the Swift package called `CryptpaySdk`. In xcode we can add the CryptpaySdk packge and initialize the constructor and call its functions (our Rust bindings):

```Swift
  import CryptpaySdk
  import Foundation

  let sdk = CryptpaySdk()
  try await sdk.setCurrency(Currency.Smr)
```

## Swift-Bridge

We are using the [`swift-bridge`](https://crates.io/crates/swift-bridge) crate to generate the Swift bindings.

#### Built-in Types

The `swift-bridge` crate uses the `#[swift_bridge::bridge]` procedural macro to declare a bridge module. This macro parses the bridge module at compile time and then generates the Rust side of the FFI layer. The bridge module is declared inside the `lib.rs` module.

```Rust
#[swift_bridge::bridge]
pub mod ffi {
    pub enum UserState {
        Undefined,
        New,
        Verified,
        Locked,
        Unlocked,
    }

    extern "Rust" {
        #[swift_bridge(swift_name = "getUserState")]
        async fn get_user_state(&self) -> Result<UserState, String>;
      }
}
```

For the above function it will generate the following C ABI in the backgroud, which will make the bridge with Swift possible:

```Rust
pub extern "C" fn __swift_bridge__CryptpaySdk_get_user_state(callback_wrapper: *mut std::ffi::c_void, callback: extern "C" fn(*mut std::ffi::c_void, ResultUserStateAndString), this: *mut super::CryptpaySdk)
```

In the `java` bindings we serialize any complex return values into JSON and return a `String`. We also take enum variants as `Strings` and perform conversion internally.

The `swift-bridge` crate supports sharing standard library types between Rust and Swift. We can return `Result` or `Option` types in the response which can contain a complex type such as a `struct` or `enum`. These types can ba used in the response and also as function arguments. In our case, we always return a `Result` type and on the `Err` case we are returning a formatted `String` of the internal SDK error.

The swift-bridge allows this if we declare shared types between Rust and Swift in the bridge module as shown in the example above with the `UserState` enum.

Additionally, we should write the conversion between these types. In our case we have developed a helper macro for generating the `From` implementations for enums and structs. In other cases we do the conversion manually, depending on the use case and limitations.

```Rust
convert_enum!(
    sdk::types::users::UserState,
    ffi::UserState,
    Undefined,
    New,
    Verified,
    Locked,
    Unlocked,
);
```

There are still some limitations with this library to passing some complex types and require some adaptations to work out. For example, the `Option<String>` type is not supported in return structs. In this case, the workaround would be to use `.unwrap_or("".to_string())` on the Option value. It attempts to unwrap the `Option` that comes from the SDK and get the `String` value. Otherwise, if the unwrap fails, meaning we get a `None` value, it returns an empty `String` which would be equivalent to the `None` value. For more information regarding the supported build-in types refer to the official [documentation]("https://chinedufn.github.io/swift-bridge/built-in/index.html") of `swift-bridge` crate.

#### async support

As we can see from the example above, the `swift-bridge` library supports `async/await` functions between Swift and Rust. Calling an async Rust function from Swift is supported. Calling an async Swift function from Rust is not yet supported. In our case, we are exporting async functions from Rust to Swift, which is supported. Therefore we do not need to embedd a runtime (such as `tokio`) ourselves!

At build time, on the background, it runs `swift-bridge-build` on files that contain bridge modules in order to generate the Swift and C code necessary to make the bridge work.

#### header files

The `swift-bridge` crate along with `build.rs` is used to create the header files from the source code directly. Although one could write these header files by hand, but for a SDK with many functions, it makes sense to automate it for avoiding errors and missing out any functions.

The `build.rs` links Swift to the Rust native library. Aside the header files, it generates also the Swift files.

It parses the Rust source files for `#[swift_bridge::bridge]` procedural macro headers and generates the corresponding Swift files. It then writes the auto-generated files to a single Swift file and all of the generated C headers to a single header file. These files are generated under the `/include` folder so that it can become a part of the xcframework without moving or copying it.

This is what the auto-generated header files structure look like:

- generated/
  - cryptpay-sdk-swift/
    - cryptpay-sdk-swift.h
    - cryptpay-sdk-swift.swift
  - SwiftBridgeCore.h
  - SwiftBridgeCore.swift

## Running Examples

We have a `compile_swift_main` on the `Makefile` can be run as a `test` to verify that the code compiles with success. It calls the `swift.main` file which calls our Rust bindings from Swift code. On `wsl` this command will only check check for compilations errors. On `mac` it will actually call our Rust functions and output the response.

**Note**: Examples need environmental variables in order to run successfully. Make sure to add a `.env` in the root directory: `sdk/bindings/swift/examples` with the corresponding values.

```
ALICE= 
MNEMONIC_ALICE=
USERNAME=
ARCHIEVEME= 
MNEMONIC=
PASSWORD=
KC_URL=
KC_REALM=
KC_CLIENT_ID=
KC_CLIENT_SECRET=
EXAMPLE_BACKEND_URL=
```