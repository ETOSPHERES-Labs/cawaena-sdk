{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Welcome to the Cawaena SDK documentation. This comprehensive guide is designed to provide you with all the information you need to install and use the Cawaena SDK effectively.</p> <p>The Cawaena SDK provides the logic for interacting with the Cawaena backend correctly. The SDK plans to help developers with a quicker, safer and easier on-boarding in the web3 world, while using the Cawaena infrastructure to support various use-cases around data monetization.</p> <p>The SDK is divided in various modules which come together to ensure an easy and safe way to incorporate the SDK in the application.</p> <p>For ease of integration, the SDK also generates bindings in various languages for various platforms, especially for mobile platforms, to provide easy integration with native and hybrid mobile app development frameworks.</p> <p>This documentation is primarily intended for developers who are integrating the Cawaena SDK into their applications. It provides a comprehensive guide to installing and using the SDK, with a focus on practical examples and clear, concise explanations.</p> <p>The documentation is divided into following sections. Simply choose one and get started!</p> <ul> <li> <p> Features</p> <p>Know the features before using Cawaena in your applications for a better product-market fit.</p> <p> Architecture</p> </li> <li> <p> Set up the SDK</p> <p>This section provides step-by-step instructions on how to install the Cawaena SDK in your development environment.</p> <p> Install</p> </li> <li> <p> Configuring the SDK</p> <p>Here, you'll find information on how to use the SDK's basic features and configure it correctly, complete with code snippets and examples to help you get started.</p> <p> Configure</p> </li> <li> <p> SDK Modules</p> <p>Once you're comfortable with the basics and configuration, this section delves into the core SDK module functions around user and wallet management, kyc onboarding processes, integration with exchanges, helping you leverage the full power of the Cawaena SDK.</p> <p> Modules</p> </li> <li> <p> API Reference</p> <p>This section provides a detailed overview of the SDK's API, including descriptions of the different functions, their return values, and the error types you might encounter.</p> <p> Reference</p> </li> <li> <p> Release Notes</p> <p>Stay up-to-date with the latest changes to the Cawaena SDK. This section provides information about the changes in each release.</p> <p> Releases</p> </li> <li> <p> SDK Examples</p> <p>This section provides a basic overview of the SDK internal structure and explains the different modules and their functions intrinsically.</p> <p> Examples</p> </li> </ul> <p>We hope this documentation serves as a valuable resource to explore the capabilities of the Cawaena SDK.</p> <p>Made with  by Team Lobster </p>"},{"location":"Choosing%20Cawaena/Architecture/","title":"Architecture","text":""},{"location":"Choosing%20Cawaena/Architecture/#overview","title":"Overview","text":"<p>The architecture shows the involved participants and explains how the integration of a client application works with .</p>"},{"location":"Choosing%20Cawaena/Architecture/#services","title":"Services","text":"<p>The Cawaena services are a bundle of services, which work together, using various infrastructure components like databases, message queues, caches, etc... to provide the different features as listed here</p> <p>These services are maintained, tested and updated by the development team behind this project. The source code for the same is maintained in a closed source repository with the development team.</p>"},{"location":"Choosing%20Cawaena/Architecture/#web-portal","title":"Web portal","text":"<p>The developers trying to integrate the Cawaena SaaS product would typically access the web portal to register themselves. After the registration, the developer can requisition a fresh new instance for the application from Cawaena through this portal.</p> <p>Additionally, the web portal allows the developers to configure their instance according to their application needs. It can be also used to undertake some application specific settings and modify them as well. For example, setting the identity provider urls and access points, which is owned by the application but may be used by Cawaena to authenticate users or setting a webhook receiver endpoint, where a notification server is already listening to Cawaena internal events, to push notifications to the end-user devices, etc...</p> <p>Currently, on the first request, a staging environment of a fresh Cawaena services instance is deployed. This allows the developers to test their application flow and integration with Cawaena before moving to production. Requesting a production instance is an extra step which needs to be done additionally. This helps the developers to fix a version for their production, while they continue testing new features and releases from Cawaena team on the staging environment, before requesting to update to production.</p> <p>The infrastructure deploys in a private cloud hosted in the european data center. Deployments in client infrastructure and public clouds are currently not possible, however will be considered in the future, for example with client-owned kubernetes cluster or Azure/AWS depolyments. The Cawaena services are coded in software to be fully platform agnostic. Hence, the deployment architecture does not affect the features and working of the services.</p>"},{"location":"Choosing%20Cawaena/Architecture/#integration","title":"Integration","text":"<p>The integration can occur for the client in three different ways:</p> <ol> <li> <p>REST API: A platform-agnostic, robust API to interact with the  features and a modern and sleek documentation.</p> <p>Within this integration, the Cawaena services are exposed via a REST API. The client developers can directly connect to these services using the Open API specification for the services. A drawback for this approach could be that the requirement on the various flows as expected by the Cawaena services needs to be well understood from the documentation. This approach also works only with custodial wallets, which might increase costs for end-users, as compared to a self-custody wallet.</p> </li> <li> <p>SDK: A variety of multi-stack SDKs working together to allow seamless in-app integration with code examples and instructions on best-practices.</p> <p>Here, the client developers can download our SDKs and even modify their behaviour according to their own needs. These SDKs are described in detail and the source code is kept open to allow maximum benefit during integration. Using the SDK gives the advantage to the developers in a way that, the SDK does all the heavy lifting in terms of executing the flows together with the Cawaena service whilst ensuring secure self-custody wallets and user management on end-user devices. This takes away a significant amount of integration effort and allows for a quick time-to-market without needing to understand all particular nuances of Cawaena services.</p> </li> <li> <p>White Label App: A multi-platform white label application with intuitive interfaces for low time to market with fully compliant flows to ensure highest user satisfaction.</p> <p>As the white label application builds on top of the SDK, it provides the client developers with complete UI/UX for maximum integration with minimal effort. The only thing the client developers would need is to adjust the corporate identiy, build the application and ship it to their end-users. The white label app ensures that all the flows are correctly executed, with the most lucid user experience from on-boarding to using the features of Cawaena. Being open source again, the white label application can also be customized for own needs and making an entirely new application would be like simply adding a few new layouts.</p> </li> </ol>"},{"location":"Choosing%20Cawaena/Features/","title":"Features","text":"<p>allows end-users to perform in-app payments to other end-users for services and products offered through the application.</p> <p>solves the problem of P2P payments between end-users, by not becoming a gate-keeper, but a path-finder between consumers for digital data, services and real-world commodities</p> <ul> <li> <p>Complete Wallet Management with MFA (Multi-factor approvals)</p> <p>For end-users with custodial and non-custodial cryptocurrency wallets without the need of additional approval from regulatory authorities</p> </li> <li> <p>KYC onboarding</p> <p>A completed on-boarding with a full-KYC without ever needing to leave the application and jumping in different browsers.</p> </li> <li> <p>Fiat/Cryptocurrency integration</p> <p>Allows loading cryptocurrency wallets from FIAT bank accounts and vice versa all within the application. Hassle-free and no copy pasting strange character addresses in even stranger browser apps.</p> </li> <li> <p>Multi-user app</p> <p>One end-user or multiple end-users on a single device? We have you covered. Every user on the same end-device can work with the highest assurance that their data cannot be seen by anyone else except themselves.</p> </li> <li> <p>Seamless identity integration</p> <p>We integrate directly with our existing identity providers, to avoid the confusion of re-registration and doing the onboarding for the users again.</p> </li> <li> <p>Integrated invoice and receipt</p> <p>The users need not worry for being conform with the tax authorities. We generate the legally exact receipts and invoices for every user automatically.</p> </li> <li> <p>Multi-platform compatible</p> <p>The solution is provided as an SDK (Software Development Kit) for major application platforms like Android, iOS and Web for developer-easy integration.</p> </li> <li> <p>European Data Center</p> <p>All your data stays in EU and never leaves, replicated or sold to anyone. A fully (really!) GDPR compliant solution with no non-EU entities lurking in the shadows of privacy policy.</p> </li> <li> <p>Cyber-secure</p> <p>A periodic vulnerability assessment and penetration testing ensures that the system is robust against attacks and leaks.</p> </li> </ul>"},{"location":"Choosing%20Cawaena/Features/#use-cases","title":"Use-cases","text":"<p>With Cawaena, you can do a lot more than the listed use-cases below. The use-cases just simply show the tip of the iceberg, how you can benefit from integrating Cawaena in your applications:</p> <ol> <li>Data-Marketplace for buying and selling sensor data, digital content or even NFTs.</li> <li>A simple cart checkout with multiple payment and currency options</li> <li>Artist remuneration directly in app for major events</li> <li>A DeFi dApp with a fully embedded wallet, without needing users to download and install shady plugins.</li> <li>Gaming exchanges for in-game artifacts and digital content with exclusive content mangement rights negotiated in real-time between end-users.</li> <li>Scam detection and regulated payments to health-care related products for the elderly</li> </ol>"},{"location":"Choosing%20Cawaena/Licensing/","title":"Licensing","text":""},{"location":"Choosing%20Cawaena/Licensing/#software-licensing-and-open-source","title":"Software licensing and open source","text":"<p>We are planning to make the SDK open source and start accepting contribution from the community.</p> <p>However, till we decide on the best way to move forward with various open source licensing options available, that might suit our needs as well as benefit the developer community, we are currently delivering the SDK under a strict license as shown on the footer of this website.</p>"},{"location":"Choosing%20Cawaena/Licensing/#license","title":"License","text":"<p> 2025 ETOSPHERES Labs GmbH, All rights reserved.</p>"},{"location":"Choosing%20Cawaena/Philosophy/","title":"Philosophy","text":"<p>The Cawaena project was started with a few basic principles and they are also the guiding values which will continue to motivate the team and all its contributors to work for this project.</p>"},{"location":"Choosing%20Cawaena/Philosophy/#core-principles","title":"Core principles","text":"<p>The following core principles summarize how the team looks at things differently:</p>"},{"location":"Choosing%20Cawaena/Philosophy/#self-realization","title":"Self-realization","text":"<p>Identify the problem: It is always important for us to identify the core problem on the technical front and approach it as an engineer with fixed boundary conditions. It is crucial to understand and realize the crux of a certain system to also get to the core of the underlying problem, rather than waiting for anyone else to explain to us their view of the system and problem.</p>"},{"location":"Choosing%20Cawaena/Philosophy/#awareness","title":"Awareness","text":"<p>Look for solutions: Look around at other people, who might have faced the same problem and look at the solutions they are using. Look at other solutions in totally different systems but with the same problems and see if they are a fit for your problem. Most of the times, the buck stops here and the problem is solved with a possible solution being discovered. But, we do care for one more core principle which influences entirely as to why certain solutions are not the best fits.</p>"},{"location":"Choosing%20Cawaena/Philosophy/#fairness","title":"Fairness","text":"<p>Is it allowed? Not just in terms of legal, but in terms of morality as well. It is very important to consider the sentiments of each and every human and especially their rights, when they interact with our systems. Legally speaking, there might be some grey areas, but morally there are plainly some things which we cannot just allow on principle. And mostly this is how we judge the solutions and the philosophies behind them, as how they would affect us and in turn our customers.</p>"},{"location":"Choosing%20Cawaena/Philosophy/#dexterity","title":"Dexterity","text":"<p>DIY: If there is no solution which is legally and morally correct, or no solution technically at all, then it becomes the time for us to get our hands dirty and dive in completely to solve the problem from its roots and come up with a solution that provides us a way out of the problem once and for all. Resources become no concern as the best available methods, processes and people get attracted to us when we approach a well-aware core problem with fairness also in focus.</p>"},{"location":"Choosing%20Cawaena/Philosophy/#community","title":"Community","text":"<p>One-for-all and all-for one: We strongly believe that we should be rewarded for what we do. And this is also sometimes a driver and motivation behind searching for solutions. In addition, we also equally strongly believe that we do not want to become gate-keepers but path-finders and light-bringers for others like us, searching for solutions in the dark. Putting back our efforts to the community, in a way which allows a beautiful, sustainable ecosystem to flourish makes complete sense, when we start contemplating that, the solutions would themselves never exist, if not for the base provided by the same thriving community.</p> <p>With these core principles guiding us, we just rinse and repeat at every opportunity that comes in-front of us either as a special request, challenge or self-discovered problems. We are affirmed more than once that this belief in the core principles has potential to rescue the world trapped under various gate-keepers to a truly decentralized and fair ecosystem.</p> <p>Hence, it does not come to us as a surprise that, all which we are building fits perfectly in the Web3 context, which also strives to unite over marginalizing or dividing people.</p>"},{"location":"Choosing%20Cawaena/Philosophy/#the-cawaena-story","title":"The Cawaena story","text":"<p>began exactly with the simplest of problems: How is it possible for a person to pay another person for goods and services offered on a platform in a way where the platform is not a gate-keeper?</p> <p>With this started our search for solutions and we concluded that there is no platform as such which respects their end-users and their rights like data protection, but rather tries to exploit as much as they can from their users.</p> <p>We started developing Cawaena and we realized that we actually are just using various solutions, which are already available in the community, but just presenting and connecting them in a way that makes it fair, legal and transparent.</p> <p>Taking guidance from our core principles, we have decided to go open source with our solution and give it to the community, not just to help develop it further with us but also use it everywhere, where they encountered gate-keepers. To employ it in a way which guarantees fairness and transparency to their end users, baked right in the solution.</p>"},{"location":"Installing%20the%20SDK/Installation/","title":"Installation","text":"<p>For installing the SDK, follow the steps detailed for each ecosystem. Currently the SDK supports the following languages/stacks:</p> <ul> <li>Rust</li> <li>Java</li> <li>Swift (for iOS)</li> <li>JavaScript / TypeScript</li> </ul> <p>Further support for other languages &amp; ecosystems can be requested to the SDK team by contacting the maintainers of this document or reaching out directly to us @ ETOSPHERES Labs GmbH.</p>"},{"location":"Installing%20the%20SDK/JS_TS/","title":"Javascript/Typescript Installation","text":"<p>The JS/TS SDK is delivered as a <code>.tgz</code> compressed NPM package file, ready for inclusion into any project using a NPM compatible package manager. Currently, the package is designed for being compatible with popular bundlers such as <code>webpack</code> and <code>vite</code><sup>1</sup> , and comes with TypesScript type definitions as well as ergonomic JavaScript wrappers. These instructions assume that you already have a project setup using one of the supported bundlers.</p>"},{"location":"Installing%20the%20SDK/JS_TS/#installing-the-jsts-sdk","title":"Installing the JS/TS SDK","text":"<p>To install the WASM SDK, simply place the compressed file next to your project and use <code>npm</code>/<code>pnpm</code> to install it from your project directory (the one containing your <code>project.json</code> file):</p> <pre><code>npm install &lt;path-to-the-tgz-file&gt;\n</code></pre> <p>The package can then be used within your application like so (example using <code>webpack</code>):</p> <pre><code>import { CawaenaSdk, Environment, Level } from \"@eto/Cawaena-sdk-wasm\";\n\nconst sdk = await new CawaenaSdk();\nsdk.initLogger(Level.Info);\nawait sdk.setEnvironment(Environment.Development);\nawait sdk.validateConfig();\n</code></pre> <p>or using a named import:</p> <pre><code>import * as Cawaena from \"@eto/Cawaena-sdk-wasm\";\n\nconst sdk = new Cawaena.CawaenaSdk();\nsdk.initLogger(Cawaena.Level.Info);\nawait sdk.setEnvironment(Cawaena.Environment.Development);\nawait sdk.validateConfig();\n</code></pre> <p>See the API reference for more information about the available functions.</p>"},{"location":"Installing%20the%20SDK/JS_TS/#updating-the-jsts-sdk","title":"Updating the JS/TS SDK","text":"<p>Updating the SDK is simply replacing the file and performing the steps above again.</p>"},{"location":"Installing%20the%20SDK/JS_TS/#future-releases-of-the-jsts-sdk","title":"Future releases of the JS/TS SDK","text":"<p>Future releases of the SDK for JS/TS will be published to the NPM registry, for even easier installation.</p>"},{"location":"Installing%20the%20SDK/JS_TS/#minimum-supported-version","title":"Minimum supported version","text":"<p>The bindings have been tested to work with <code>webpack</code> v4.47.0.</p> <ol> <li> <p>If the current package does not work for you, and you for example need a package for inclusion directly on a web page as a <code>&lt;script&gt;</code> tag, please reach out to the development team.\u00a0\u21a9</p> </li> </ol>"},{"location":"Installing%20the%20SDK/Java/","title":"Java Installation","text":"<p>The Java SDK is now available through a private Maven repository hosted on JFrog. You can add it as a dependency in your Maven project's <code>pom.xml</code> file.</p>"},{"location":"Installing%20the%20SDK/Java/#installing-via-maven-repository","title":"Installing via Maven Repository","text":"<ol> <li> <p>Update <code>settings.xml</code></p> <p>To access the private Maven repository, you need to update your Maven <code>settings.xml</code> file, usually located in the <code>~/.m2</code> directory. Add the following server configuration:</p> <pre><code>&lt;servers&gt;\n&lt;server&gt;\n    &lt;id&gt;jfrog-private-repo&lt;/id&gt;\n    &lt;username&gt;your-username&lt;/username&gt;\n    &lt;password&gt;your-password&lt;/password&gt;\n    &lt;/server&gt;\n&lt;/servers&gt;\n</code></pre> <p>Note: Replace <code>your-username</code> and <code>your-password</code> with your actual JFrog repository credentials.</p> </li> <li> <p>Update your projects <code>pom.xml</code> file to include the <code>dependency</code> and the <code>repository</code>:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.etogruppe&lt;/groupId&gt;\n    &lt;artifactId&gt;CryptpaySdk&lt;/artifactId&gt;\n    &lt;version&gt;0.11.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <pre><code>&lt;repositories&gt;\n&lt;repository&gt;\n    &lt;id&gt;snapshots-repo&lt;/id&gt;\n    &lt;url&gt;https://repo.farmunited.com:443/artifactory/egdbz-mvn/&lt;/url&gt;\n    &lt;releases&gt;\n    &lt;enabled&gt;false&lt;/enabled&gt;\n    &lt;/releases&gt;\n    &lt;snapshots&gt;\n    &lt;enabled&gt;true&lt;/enabled&gt;\n    &lt;/snapshots&gt;\n&lt;/repository&gt;\n&lt;/repositories&gt;\n</code></pre> </li> </ol> <p>See JFrog Artifactory Documentation &gt; Package Management &gt; Maven Repository for guiding docs.</p>"},{"location":"Installing%20the%20SDK/Java/#installing-jnilibs","title":"Installing jniLibs","text":"<p>The jar files also contain the jniLibs folder. The jniLibs folder in turn contains the pre-built shared object libraries of the SDK. The structure of the folder is as shown below:</p> <pre><code>jniLibs\n\u251c\u2500\u2500 arm64-v8a\n\u2502   \u251c\u2500\u2500 libwalletsdk.so\n\u2502   \u2514\u2500\u2500 libc++_shared.so\n\u251c\u2500\u2500 armeabi-v7a\n\u2502   \u251c\u2500\u2500 libwalletsdk.so\n\u2502   \u2514\u2500\u2500 libc++_shared.so\n\u251c\u2500\u2500 x86\n\u2502   \u251c\u2500\u2500 libwalletsdk.so\n\u2502   \u2514\u2500\u2500 libc++_shared.so\n\u2514\u2500\u2500 x86_64\n    \u251c\u2500\u2500 libwalletsdk.so\n    \u2514\u2500\u2500 libc++_shared.so\n</code></pre> <p>The <code>jniLibs</code> folder should be placed as-is under the <code>src/main</code> folder of the corresponding Java project from the jar file.</p> <p>Warning</p> <p>Currently the moving of the jniLibs from the jar to the src/main folder is manual and not automated. Later it will be automated with a gradle plugin once the project is moved to open source. Not copying this generally will throw the error while initializing the constructor of the CryptpaySdk class <code>java.lang.UnsatisfiedLinkError: dlopen failed: library \"libwalletsdk.so\" not found</code>.</p>"},{"location":"Installing%20the%20SDK/Java/#future-releases-of-sdk","title":"Future releases of SDK","text":"<p>Future releases of the SDK will continue to be published to the private Maven repository. You will only need to update the dependency version in your pom.xml file to use the latest release and replace the jniLibs correspondingly.</p>"},{"location":"Installing%20the%20SDK/Java/#minimum-version-support","title":"Minimum version support","text":"<p>The following versions of the toolchain are used to build and compile the Java SDK and should be used as minimum versions for integrating the SDK. Versions lower than the mentioned might work, however are not guaranteed by the team. In case of issues, please contact the team with specific build or compile errors.</p> <ul> <li>Java Compiler: <code>17.0.10</code></li> <li>gradle: <code>Gradle 8.6</code></li> <li>Android SDK Command-line Tools:  <code>12.0</code></li> <li>Android SDK Platform: <code>Android SDK Platform 13</code></li> <li>Android API Level: <code>33</code></li> <li>Android NDK: <code>26.2.11394342</code></li> <li>Android Build Tools: <code>34.0.0</code></li> </ul>"},{"location":"Installing%20the%20SDK/Rust/","title":"Rust Installation","text":"<p>Info</p> <p>The Rust SDK is currently in a pre-release state and is not yet available on the crates.io registry. </p> <p>You can access the SDK by adding the following dependency to your <code>Cargo.toml</code> file:</p> <pre><code>[dependencies]\ncawaena-sdk = { git = \"https://github.com/ETOSPHERES-Labs/cawaena-sdk\", branch = \"main\", package =\"sdk\" }\n</code></pre> <p>You can also checkout the cawaena-sdk-quickstart-rs repository for a quickstart guide on how to use the SDK in your Rust project.</p>"},{"location":"Installing%20the%20SDK/Swift/","title":"Swift Installation","text":"<p>The swift SDK is now available through a private gitlab repository with binaries hosted on JFrog. You can add the repository as a <code>dependency</code> in your <code>Package.swift</code>. Before starting, make sure you have access to the Gitlab repository as it will be needed for the instructions below.</p> <p>We provide binaries for the following platforms:</p> <ul> <li><code>aarch64-apple-ios</code>: targets 64-bit ARM processors for iOS devices like iPhones and iPads.</li> <li><code>x86_64-apple-ios</code>: for 64-bit Intel processors for iOS simulators.</li> <li><code>aarch64-apple-ios-sim</code>: for 64-bit ARM processors running iOS simulators, typically used on Apple Silicon Macs.</li> <li><code>aarch64-apple-darwin</code>: for 64-bit ARM processors on macOS systems (eg. M1).</li> <li><code>x86_64-apple-darwin</code>: for 64-bit Intel processors on macOS systems.</li> </ul>"},{"location":"Installing%20the%20SDK/Swift/#using-cawaena-with-swift-package-manager","title":"Using Cawaena with Swift Package Manager","text":"<p>The Cawaena SDK can also be used as a Swift package. Follow these steps to integrate it into your project:</p> <p>Add the repository as a <code>dependency</code> in your <code>Package.swift</code> file:</p> <pre><code>import PackageDescription\n\nlet package = Package(\n    name: \"program\",\n    dependencies: [\n        .package(url: \"https://gitlab.inovel.de/zd0006/cryptpay-swift\", from: \"0.0.1\")\n    ],\n    targets: [\n        .executableTarget(\n            name: \"main\",\n            dependencies: [\n                .product(name: \"CryptpaySdk\", package: \"cryptpay-swift\")\n            ]),\n    ]\n)\n</code></pre> <p>The <code>CryptpaySdk</code> module will then be available for import in your project.</p>"},{"location":"Installing%20the%20SDK/Swift/#using-cawaena-with-xcode","title":"Using Cawaena with XCode","text":"<p>In XCode, go to File -&gt; Add Package Dependencies. In the top right search box, enter the url of the GitLab repository (<code>https://gitlab.inovel.de/zd0006/cryptpay-swift</code>) and select the Cawaena SDK when it appears in the list. Select Add Package and follow the on-screen instructions.</p>"},{"location":"Installing%20the%20SDK/Swift/#access-to-the-binaries-on-jfrog","title":"Access to the binaries on JFrog","text":"<p>To allow the Swift Package Manager and XCode to download the binaries stored in JFrog, you need to set up an access token in your <code>~/.netrc</code> file.</p> <ol> <li>Visit <code>JFrog</code> and log in. In the top right corner, click your name and then \"Edit Profile.\" Under \"Identity Tokens,\" click \"Generate an Identity Token\" and optionally give the token a name.</li> <li>If not already existing, create the file <code>.netrc</code> in your home folder and add the following lines (e.g., using <code>nano ~/.netrc</code>)</li> </ol> <pre><code>machine repo.farmunited.com\n    login &lt;your JFrog username&gt;\n    password &lt;your access token&gt;\n</code></pre> <ol> <li>You should now be able to access and use the package in your Swift projects!</li> </ol> <p>Note: you might need to restart XCode for the changes to take effect.</p>"},{"location":"Installing%20the%20SDK/Swift/#future-releases-of-sdk","title":"Future releases of SDK","text":"<p>Future releases of SDK will continue to be published on the private gitlab repository. You will only need to update the dependency version to use the latest release.</p>"},{"location":"Installing%20the%20SDK/Swift/#minimum-supported-version","title":"Minimum supported version","text":"<ul> <li>swift-tools - <code>5.8</code></li> <li>swiftlang- <code>swiftlang-5.8.0.124.2</code></li> <li>clang - <code>clang-1403.0.22.11.100</code></li> <li>iOS - <code>13</code></li> </ul>"},{"location":"SDK%20Configuration/Configuration/","title":"Configuring the SDK","text":"<p>The Cawaena SDK needs to be configured correctly for secure and functional usage. Misconfiguration might lead to potential information leaks as well as bad end-user experience.</p>"},{"location":"SDK%20Configuration/Configuration/#static-configuration","title":"Static Configuration","text":"<p>The static configuration is provided by passing a JSON formatted string to the SDK using the <code>set_config</code> function. It has the following format, whose fields are described in the sections below.</p> <pre><code>{\n    \"auth_provider\": \"&lt;authentication provider name&gt;\",\n    \"backend_url\": \"&lt;valid URL to the backend API&gt;\",\n    \"storage_path\": \"/path/to/valid/folder\",\n    \"log_level\": \"info\"\n}\n</code></pre>"},{"location":"SDK%20Configuration/Configuration/#configuring-authentication-provider","title":"Configuring authentication provider","text":"<p>The authentication provider is a setting which is configured in the beginning in conjunction with the Cawaena development team. The Cawaena SDK and backend support Oauth2.0/OpenID Connect<sup>1</sup> provider and can work with external authentication providers. The following information is needed by the Cawaena team to configure the backend to accept requests from the SDK:</p> <ol> <li>ISSUER - The issuer, which is part of the JWT claim in the <code>access_token</code>, created by the OAuth2.0 server. The issuer is generally the URL to the realm, but could also be different based on different settings.</li> <li>AUTHORITY - The authority is where the public keys/certificates are hosted, which are used by the OAuth2.0 server to sign the JWT <code>access_tokens</code>. This is mostly a URL of the following type: <code>{base_url}/auth/realms/{realm_name}/protocol/openid-connect/certs</code></li> <li>AZP - The authorized party, which is part of the JWT claim in the <code>access_token</code>, created by the OAuth2.0 server. The authorized party is typically the name of the 3rd-party client, which has requested the JWT Token for the user using various flows listed in the standard.</li> <li>NAME - A unique name to assign and identify this particular authentication provider settings in the backend as well as in the SDK. This is the name to specify in the <code>auth_provider</code> field of the configuration.</li> </ol> Info <p>The control of the client credentials, the flows used to fetch the JWT as well as the entire user management including user registration, email verification and user settings is out of scope for Cawaena backend and SDK. This should be managed by applications using the SDK themselves.</p> <p>Every time the OAuth client refreshes or fetches a new access token for the user, the access token can be updated in the SDK using the <code>refresh_access_token</code> function.</p> RustJavaSwiftTypescript <pre><code>async fn main() {\n    let mut sdk = Sdk::default();\n    sdk.set_config(\"...\").unwrap();\n\n    sdk.refresh_access_token(\"access_token\").await.unwrap();\n}\n</code></pre> <pre><code>package org.example.app;\nimport com.cawaena.Wallet;\n\npublic class app {\n    public static void main(){\n        Wallet sdk = new Wallet();\n\n        try {\n            sdk.setConfig(\"...\");\n            sdk.refreshAccessToken(\"accessToken\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre> <pre><code>import Foundation\nimport CawaenaSdk\n\nlet sdk = CawaenaSdk()\ntry await sdk.setConfig(config: \"...\")\n\ndo {\n    try await sdk.refreshAccessToken(access_token: \"access_token\")\n} catch {\n    print(error.localizedDescription)\n}\n</code></pre> <pre><code>import * as wasm from \"../pkg/cryptpay_sdk_wasm\";\n\nconst sdk = await new CawaenaSdk();\nawait sdk.setConfig(\"...\")\n\nawait sdk.refreshAccessToken(\"access_token\");\n</code></pre> <p>Warning</p> <p>The SDK is not responsible for refreshing the access token. Neither does it have the credentials, nor a way to obtain credentials for refreshing an access token for the user. This is the responsibility of the client application integrating the SDK. The refresh_access_token function should not be confused with refresh_token and should not be passed the value of refresh_token. The function needs the value of a valid access_token as a string.</p>"},{"location":"SDK%20Configuration/Configuration/#configuring-the-backend","title":"Configuring the backend","text":"<p>The Cawaena team provides the URL for the backend, which is specified as the<code>backend_url</code> field of the configuration. This information is part of the initial setup and is important before starting the SDK usage.</p>"},{"location":"SDK%20Configuration/Configuration/#configuring-the-storage-path-prefix","title":"Configuring the storage path prefix","text":"<p>For all platforms, except for when using the TypeScript/Javascript bindings, it is mandatory that the application has access to a file system where it is allowed read and write files and directories and sub-directories. This (existing) folder is specified as the <code>strorage_path</code> field in the configuration and accepts both releative and absolute paths. Absolute paths are, however, preferred and recommended.</p> Tip <p>It is recommended to use a path where only the application has file system rights. Allowing access to other applications is a potential security risk and may incur loss of funds for end-users.</p> Tip <p>For use in Android applications, it is important to extract the path where the app has permissions to create files and directories and use it as the storage path. This is generally something like <code>\\data\\data\\org.example.app\\</code> if the application package is <code>org.example.app</code>.</p>"},{"location":"SDK%20Configuration/Configuration/#logging-in-the-sdk-and-validating-configuration","title":"Logging in the SDK and validating configuration","text":"<p>Whenever the SDK is configured, the logger is automatically initialized. For all platforms except TypeScript/Javascript, whenever a valid log level is specified in the <code>log_level</code> field, the logger is initialized to append log messages to a <code>cryptpay_sdk.log</code> file in the specified <code>storage_path</code> folder. The different log levels that can be set for the logger are: <code>trace</code>, <code>debug</code>, <code>info</code>, <code>warn</code>, <code>error</code> and allow for fine-tuning the amount of log messages that are generated. A value of <code>off</code> can also be specified to disable logging completely. It is important and recommended to enable the logger since this information can be exported and analyzed during testing and integration, which can help diagnose any issues.</p>"},{"location":"SDK%20Configuration/Configuration/#complete-example","title":"Complete example","text":"<p>For a complete example of how to setup and configure the SDK before using any of its module functions, please see Example 0. Shared Setup Code.</p> <ol> <li> <p>The following information links could be used as reference for OAuth2.0 and OpenID Connect</p> <p>OAuth 2.0 Official Website</p> <p>OAuth 2.0 RFC</p> <p>OAuth 2.0 Simplified</p> <p>OAuth 2.0 Playground</p> <p>OpenID Connect Official Website</p> <p>OpenID Connect RFC</p> <p>OpenID Connect Playground</p> <p>OpenID Connect Introduction \u21a9</p> </li> </ol>"},{"location":"SDK%20Examples/Examples/","title":"Examples","text":"<p>The Cawaena SDK is built in <code>rust</code>. It is primarily an implementation of the various interfaces for managing users, wallets, on-boarding of users through KYC (Know Your Customer) processes, payment methods and listing usage information. The flows discussed in this document show examples using the rust language. For examples related to the specific language, refer to the corresponding pages.</p> <p>The Cawaena SDK can be used only if the following pre-requisites have been fulfilled and the information resulting from these conditions is available:</p> <ul> <li>Oauth2.0 Identity and Access Management Provider is configured correctly,</li> <li>The backend base URL of the Cawaena system is known,</li> <li>The path to a certain file storage is available, where the application has read/write rights to create, modify and delete files related to the SDK like log files, local key-value DBs, and wallet files.</li> </ul> <p>Once this information is available, the SDK can be instantiated and the basic functions can be used.</p> <p>The examples shows the usage of the SDK in rust for creating a user. The user credentials are taken from the environment but could also be easily a user input.</p> <p>The environment configuration to <code>Development</code> attaches the SDK to the development backend of Cawaena automatically. It also configures the authentication provider correctly with the one used by the development team internally. This configuration is used by Cawaena developers and is only restricted to the users controlled by the identity provider configured for Cawaena internal testing.</p>"},{"location":"SDK%20Examples/Examples/#0-shared-setup-code","title":"0. Shared Setup Code","text":"RustJavaSwiftJS/TS <pre><code>#![allow(clippy::unwrap_used, clippy::expect_used, dead_code)]\n\nuse sdk::{\n    core::{Config, Sdk},\n    types::{\n        networks::{Network, NetworkType},\n        newtypes::{AccessToken, EncryptionPin, PlainPassword},\n    },\n};\nuse std::path::Path;\nuse testing::{CleanUp, USER_SATOSHI};\n\npub async fn init_sdk() -&gt; (Sdk, CleanUp) {\n    dotenvy::dotenv().ok();\n\n    // for the examples we want logs to go to the console for easier troubleshooting\n    env_logger::builder().filter_level(log::LevelFilter::Info).init();\n\n    let user = &amp;USER_SATOSHI;\n\n    let cleanup = CleanUp::default();\n\n    let backend_url = std::env::var(\"EXAMPLES_BACKEND_URL\")\n        .expect(\"EXAMPLES_BACKEND_URL environment variable need to be set to run the examples\");\n\n    // construct the config to use for the SDK\n    let config = Config {\n        backend_url: backend_url.parse().expect(\"EXAMPLES_BACKEND_URL must be a valid URL\"),\n        path_prefix: Path::new(&amp;cleanup.path_prefix).into(),\n        auth_provider: \"standalone\".to_string(),\n        log_level: log::LevelFilter::Debug,\n    };\n    let mut sdk = Sdk::new(config).expect(\"should not fail to initialize sdk\"); // set the backend url if the environment variable is set\n\n    // generate access token\n    let access_token = testing::get_access_token(&amp;user.username, &amp;user.password)\n        .await\n        .access_token;\n    let access_token = AccessToken::try_from(access_token).unwrap();\n    sdk.refresh_access_token(Some(access_token)).await.unwrap();\n\n    // next - move setting network outside of init_sdk\n    sdk.set_networks(Some(vec![\n        Network {\n            id: String::from(\"67a1f08edf55756bae21e7eb\"),\n            name: String::from(\"IOTA\"),\n            currency: String::from(\"IOTA\"),\n            block_explorer_url: String::from(\"https://explorer.shimmer.network/testnet/\"),\n            enabled: true,\n            network_identifier: Some(String::from(\"iota_mainnet\")),\n            network_type: NetworkType::Stardust {\n                node_url: String::from(\"https://api.testnet.iotaledger.net\"),\n            },\n</code></pre> <pre><code>\n</code></pre> <pre><code>import CawaenaSdk\nimport Foundation\n\n// Struct to hold environment variables for examples\npublic struct Environment {\n  public let username: String\n  public let password: String\n  public let pin: String\n  public let mnemonic: String\n\n  public init() {\n    guard\n      let username = ProcessInfo.processInfo.environment[\"USERNAME\"],\n      let password = ProcessInfo.processInfo.environment[\"PASSWORD\"],\n      let mnemonic = ProcessInfo.processInfo.environment[\"MNEMONIC\"]\n    else {\n      fatalError(\"Missing environment variables\")\n    }\n\n    self.username = username\n    self.password = password\n    self.pin = \"1234\"\n    self.mnemonic = mnemonic\n  }\n}\n\n// Helper function to access env variables\npublic func getEnvironment() -&gt; Environment {\n  return Environment()\n}\n\n//  Create sdk instance and set env\npublic func initSdk(username: String, password: String) async throws -&gt; CawaenaSdk {\n  // remove user and wallet generated files\n  cleanup(atPaths: [\"sdk-user.db\", \"wallets\"])\n\n  let url = ProcessInfo.processInfo.environment[\"EXAMPLES_BACKEND_URL\"]!\n\n  // initialize the cawaena sdk\n  let sdk = CawaenaSdk()\n\n  // set the sdk config and validate it\n  try await sdk.setConfig(\n    \"\"\"\n    {\n      \"backend_url\": \"\\(url)\",\n      \"storage_path\": \".\",\n      \"log_level\": \"info\",\n      \"auth_provider\": \"standalone\"\n    }\n    \"\"\")\n\n  // get the access token\n  let access_token = try await generateAccessToken(username: username, password: password)\n  try await sdk.refreshAccessToken(access_token)\n  print(\"retrieved access token\")\n\n  try await sdk.setCurrency(Currency.Iota)\n\n  return sdk\n}\n\n// Enum with possible error cases which might happen during the generation of the access token call.\nenum TokenError: Error {\n  case missingEnvironmentVariable(String)\n  case invalidURL\n  case parsingError(String)\n  case accessTokenNotFound\n}\n\n// Struct to get the access token from the response\nstruct TokenResponse: Codable {\n  let accessToken: String\n}\n\n// Generate an access token by making a call to the KC API. This is mirroring the `hello.http` endpoint\nfunc generateAccessToken(username: String, password: String) async throws -&gt; String {\n\n  // access environment variables\n  guard\n    let kcURL = ProcessInfo.processInfo.environment[\"KC_URL\"],\n    let kcRealm = ProcessInfo.processInfo.environment[\"KC_REALM\"],\n    let clientId = ProcessInfo.processInfo.environment[\"KC_CLIENT_ID\"],\n    let clientSecret = ProcessInfo.processInfo.environment[\"KC_CLIENT_SECRET\"]\n  else {\n    throw TokenError.missingEnvironmentVariable(\"One or more environment variables are missing\")\n  }\n\n  let urlString = \"\\(kcURL)/realms/\\(kcRealm)/protocol/openid-connect/token\"\n  guard let url = URL(string: urlString) else {\n    throw TokenError.invalidURL\n  }\n\n  var request = URLRequest(url: url)\n  request.httpMethod = \"POST\"\n  request.setValue(\"application/x-www-form-urlencoded\", forHTTPHeaderField: \"Content-Type\")\n\n  // Construct body parameters\n  let bodyParameters = [\n    \"grant_type\": \"password\",\n    \"scope\": \"profile email openid\",\n    \"client_id\": clientId,\n    \"client_secret\": clientSecret,\n    \"username\": username,\n    \"password\": password,\n  ]\n  request.httpBody =\n    bodyParameters\n    .map { \"\\($0.key)=\\($0.value)\" }\n    .joined(separator: \"&amp;\")\n    .data(using: .utf8)\n\n  let (data, _) = try await URLSession.shared.data(for: request)\n\n  let jsonString = String(data: data, encoding: .utf8)\n  guard let jsonData = jsonString?.data(using: .utf8) else {\n    throw TokenError.parsingError(\"failed to parse json data from string\")\n  }\n\n  do {\n    // Parse the JSON data\n    if let json = try JSONSerialization.jsonObject(with: jsonData, options: []) as? [String: Any],\n      let accessToken = json[\"access_token\"] as? String\n    {\n      return accessToken\n    } else {\n      throw TokenError.accessTokenNotFound\n    }\n  } catch _ {\n    throw TokenError.parsingError(\"failed to serialize json data\")\n  }\n}\n\n// cleanup\nfunc cleanup(atPaths paths: [String]) {\n  let fileManager = FileManager.default\n\n  for path in paths {\n    do {\n      // Check if the file or directory exists\n      if fileManager.fileExists(atPath: path) {\n        // Remove the file or directory\n        try fileManager.removeItem(atPath: path)\n      } else {\n        print(\"File or directory does not exist: \\(path). Moving on ..\")\n      }\n    } catch {\n      print(\"Error removing file or directory at \\(path): \\(error)\")\n    }\n  }\n}\n</code></pre> <pre><code>import * as wasm from \"../pkg\";\nimport * as dotenv from 'dotenv';\nimport axios from 'axios';\nimport { LocalStorage } from \"node-localstorage\";\n\nexport async function initSdk(username: string) {\n    dotenv.config();\n\n    // setup localStorage to use a file-based mock version\n    globalThis.window = { localStorage: new LocalStorage('./local-storage') } as any;\n\n    // make sure the localStorage is clear to run each example in isolation\n    try {\n        window.localStorage.clear();\n    } catch (e) {\n        console.log(\"Could not clear local storage: \", e);\n    }\n\n    console.log(\"Starting SDK initialization...\");\n\n    const sdk = new wasm.CryptpaySdk();\n\n    // set the backend url if the environment variable is set\n    let url: string = (process.env.EXAMPLES_BACKEND_URL as string);\n    if (url == undefined) {\n        throw new Error(\"EXAMPLES_BACKEND_URL environment variable must be present\")\n    }\n\n    await sdk.setConfig(`\n    {\n        \"backend_url\": \"${url}\",\n        \"log_level\": \"info\",\n        \"auth_provider\": \"standalone\"\n    }\n    `);\n\n    await sdk.setCurrency(wasm.Currency.Iota);\n\n    // Generate access token\n    let access_token = await generateAccessToken(username);\n    await sdk.refreshAccessToken(access_token);\n    return sdk;\n}\n\n// Custom error class for handling token errors\nclass TokenError extends Error {\n    constructor(message: string) {\n        super(message);\n        this.name = \"TokenError\";\n    }\n\n    static missingEnvironmentVariable(message: string) {\n        return new TokenError(`Missing environment variable: ${message}`);\n    }\n\n    static invalidURL() {\n        return new TokenError('Invalid URL');\n    }\n\n    static parsingError(message: string) {\n        return new TokenError(`Parsing error: ${message}`);\n    }\n\n    static accessTokenNotFound() {\n        return new TokenError('Access token not found');\n    }\n}\n\n// Generate an access token by making a call to the KC API. This is mirroring the `hello.http` endpoint\nasync function generateAccessToken(username: string): Promise&lt;string&gt; {\n    // Access environment variables\n    const kcURL = process.env.KC_URL;\n    const kcRealm = process.env.KC_REALM;\n    const clientId = process.env.KC_CLIENT_ID;\n    const clientSecret = process.env.KC_CLIENT_SECRET;\n    const password = process.env.PASSWORD\n\n    if (!kcURL || !kcRealm || !clientId || !clientSecret || !password) {\n        throw TokenError.missingEnvironmentVariable('One or more environment variables are missing');\n    }\n\n\n    const urlString = `${kcURL}/realms/${kcRealm}/protocol/openid-connect/token`;\n\n    let env_data = {\n        grant_type: 'password',\n        scope: 'profile email openid',\n        client_id: clientId,\n        client_secret: clientSecret,\n        username: username,\n        password: password\n    };\n\n    try {\n        const response = await axios.post(urlString, env_data, {\n            headers: { 'content-type': 'application/x-www-form-urlencoded' },\n\n        });\n\n        const data = response.data;\n        if (data &amp;&amp; data.access_token) {\n            return data.access_token;\n        } else {\n            throw TokenError.accessTokenNotFound();\n        }\n    } catch (error: any) {\n        if (error.response) {\n            // Server responded with a status other than 2xx\n            throw TokenError.parsingError(`Server responded with status ${error.response.status}: ${error.response.statusText}`);\n        } else if (error.request) {\n            // No response was received\n            throw TokenError.invalidURL();\n        } else {\n            // Something happened in setting up the request\n            throw TokenError.parsingError(error.message);\n        }\n    }\n}\n</code></pre>"},{"location":"SDK%20Examples/Examples/#1-create-new-user","title":"1. Create New User","text":"RustJavaSwiftJS/TS <pre><code>mod utils;\nuse testing::USER_SATOSHI;\nuse utils::init_sdk;\n\n#[allow(clippy::unwrap_used, clippy::expect_used)]\n#[tokio::main]\nasync fn main() {\n    // Initialize SDK\n    let (mut sdk, _cleanup) = init_sdk().await;\n    let user: utils::TestUser = (*USER_SATOSHI).clone().into();\n\n    // Create new user\n    sdk.create_new_user(&amp;user.username).await.unwrap();\n    sdk.init_user(&amp;user.username).await.unwrap();\n}\n</code></pre> <pre><code>\n</code></pre> <pre><code>// The Swift Programming Language\n// https://docs.swift.org/swift-book\n\nimport CawaenaSdk\nimport Foundation\nimport utils\n\n// We use a DispatchGroup to make the program wait until async functions finish before exiting.\n// Not needed in long-running applications.\nlet group = DispatchGroup()\ngroup.enter()\n\nTask {\n    do {\n        // Get environment variables from the Utils module\n        let env = getEnvironment()\n\n        // Initialize SDK\n        let sdk = try await initSdk(username: env.username, password: env.password)\n\n        // Create new user\n        try await sdk.createNewUser(env.username)\n        print(\"created new user: \\(env.username)\")\n        try await sdk.initUser(env.username)\n        print(\"initialized new user: \\(env.username)\")\n\n    } catch let error as RustString {\n        fatalError(\"Create new user example failed: \\(error.toString())\")\n    } catch {\n        fatalError(\"Unexpected error occurred: \\(error)\")\n    }\n\n    group.leave()\n}\n\ngroup.wait()\n</code></pre> <pre><code>import * as wasm from \"../pkg/cryptpay_sdk_wasm\";// Import the WASM module\nimport { initSdk } from './utils';\n\nasync function main() {\n    let username = \"satoshi\";\n    const sdk = await initSdk(username);\n    await sdk.createNewUser(username);\n\n    console.log(\"user created successfully\");\n\n}\n\nmain();\n</code></pre>"},{"location":"SDK%20Examples/Examples/#2-onboard-user-postident","title":"2. Onboard User Postident","text":"RustJavaSwiftJS/TS <pre><code>mod utils;\nuse testing::USER_SATOSHI;\nuse utils::init_sdk;\n\n// ---------------------------------------------\n// Note: This examples does not work unless you do manual postident verification at https://postident-itu.deutschepost.de/testapp\n// ---------------------------------------------\n\n#[allow(clippy::unwrap_used, clippy::expect_used)]\n#[tokio::main]\nasync fn main() {\n    // Initialize SDK and create a new user\n    let (mut sdk, _cleanup) = init_sdk().await;\n    let user: utils::TestUser = (*USER_SATOSHI).clone().into();\n\n    sdk.create_new_user(&amp;user.username).await.unwrap();\n    sdk.init_user(&amp;user.username).await.unwrap();\n\n    // Exit if user is already verified\n    let is_verified = sdk.is_kyc_status_verified(&amp;user.username).await.unwrap();\n    if is_verified {\n        println!(\"User is already verified, please run the delete_user example first.\");\n        return;\n    }\n\n    // Create sap customer if not exists\n    if sdk.get_customer().await.is_err() {\n        sdk.create_customer(\"DE\").await.unwrap();\n    };\n\n    // Start KYC verification for postident\n    let new_case_id = sdk.start_kyc_verification_for_postident().await.unwrap();\n    println!(\"New postident user with case: {:#?}\", new_case_id);\n\n    // Do manual postident verification at\n    // https://postident-itu.deutschepost.de/testapp\n    let mut enter = String::new();\n    println!(\"Do postident KYC and hit enter to continue...\");\n    std::io::stdin()\n        .read_line(&amp;mut enter)\n        .expect(\"error: unable to read user input\");\n\n    // Finish KYC verification for postident\n    sdk.update_kyc_status_for_postident(&amp;new_case_id.case_id).await.unwrap();\n\n    // Check that the user is verified\n    let is_verified = sdk.is_kyc_status_verified(&amp;user.username).await.unwrap();\n    println!(\"IsVerified: {:#?}\", is_verified);\n}\n</code></pre> <pre><code>\n</code></pre> <pre><code>// The Swift Programming Language\n// https://docs.swift.org/swift-book\n\n// ! Need to do manual verification on postident: https://postident-itu.deutschepost.de/testapp\n\nimport CawaenaSdk\nimport Foundation\nimport utils\n\n// We use a DispatchGroup to make the program wait until async functions finish before exiting.\n// Not needed in long-running applications.\nlet group = DispatchGroup()\ngroup.enter()\n\nTask {\n    do {\n        // Get environment variables from the Utils module\n        let env = getEnvironment()\n\n        // Initialize SDK\n        let sdk = try await initSdk(username: env.username, password: env.password)\n\n        // Create new user\n        try await sdk.createNewUser(env.username)\n        print(\"created new user: \\(env.username)\")\n        try await sdk.initUser(env.username)\n        print(\"initialized new user: \\(env.username)\")\n\n        // Exit if user is already verified\n        let is_verified = try await sdk.isKycVerified(env.username)\n        print(\"is verified: \\(is_verified)\")\n        if is_verified {\n            print(\"User is already verified. No need to delete. Exiting\")\n            return\n        }\n\n        // Create sap customer if not exists\n        do {\n            try await sdk.getCustomer()\n            print(\"sap customer exists. Continue\")\n        } catch {\n            try await sdk.createCustomer(\"DE\")\n            print(\"created new sap customer\")\n        }\n\n        // Start KYC verification for postident\n        let new_user = try await sdk.initKycVerificationForPostident()\n        print(\"New postident user: \\(new_user.case_id.toString()), \\(new_user.case_url.toString())\")\n\n        // Do manual postident verification at https://postident-itu.deutschepost.de/testapp\n\n        // Finish KYC verification for postident\n        try await sdk.updateKycDetailsForPostident(new_user.case_id)\n\n        // Check that the user is verified.\n        // Should be true if the manual verification in postident is done.\n        // Here it will return false.\n        let verified = try await sdk.isKycVerified(env.username)\n        print(\"Is Verified: \\(verified)\")\n\n    } catch let error as RustString {\n        fatalError(\"Onboard user with postident example failed: \\(error.toString())\")\n    } catch {\n        fatalError(\"Unexpected error occurred: \\(error)\")\n    }\n\n    group.leave()\n}\n\ngroup.wait()\n</code></pre> <pre><code>//  Need to do manual verification on postident: https://postident-itu.deutschepost.de/testapp\nimport * as wasm from \"../pkg/cryptpay_sdk_wasm\";\nimport { initSdk } from './utils';\n\nasync function main() {\n    let username = \"satoshi\";\n    const sdk = await initSdk(username);\n    await sdk.createNewUser(username);\n    await sdk.initializeUser(username);\n\n    // Start KYC verification for Postident\n    let response = await sdk.startKycVerificationForPostident();\n    console.log(\"Postident case id:\", response.case_id);\n    console.log(\"Postident case url:\", response.case_url);\n\n    // --&gt; Do Postident KYC process with URL\n\n    // Get KYC details for Postident\n    let caseDetails = await sdk.getKycDetailsForPostident();\n    console.log(\"Case details:\", caseDetails);\n\n    // Update KYC status for Postident\n    await sdk.updateKycStatusForPostident(response.case_id);\n    console.log(\"Case status updated.\");\n\n    // Check if KYC is verified\n    let isVerified = await sdk.isKycVerified(username);\n    console.log(\"IsVerified:\", isVerified);\n\n}\n\nmain();\n</code></pre>"},{"location":"SDK%20Examples/Examples/#4-migrate-wallet-from-mnemonic","title":"4. Migrate Wallet From Mnemonic","text":"RustJavaSwiftJS/TS <pre><code>mod utils;\nuse testing::USER_SATOSHI;\nuse utils::init_sdk;\n\n#[allow(clippy::unwrap_used, clippy::expect_used)]\n#[tokio::main]\nasync fn main() {\n    // Initialize SDK\n    let (mut sdk, _cleanup) = init_sdk().await;\n    let user: utils::TestUser = (*USER_SATOSHI).clone().into();\n\n    // Create new user\n    sdk.create_new_user(&amp;user.username).await.unwrap();\n    sdk.init_user(&amp;user.username).await.unwrap();\n    sdk.set_wallet_password(&amp;user.pin, &amp;user.password).await.unwrap();\n\n    // Create new wallet\n    sdk.create_wallet_from_existing_mnemonic(&amp;user.pin, &amp;user.mnemonic)\n        .await\n        .unwrap();\n\n    // use wallet\n    let _address = sdk.generate_new_address(&amp;user.pin).await.unwrap();\n}\n</code></pre> <pre><code>\n</code></pre> <pre><code>// The Swift Programming Language\n// https://docs.swift.org/swift-book\n\nimport Foundation\nimport CawaenaSdk\nimport utils\n\n// We use a DispatchGroup to make the program wait until async functions finish before exiting.\n// Not needed in long-running applications.\nlet group = DispatchGroup()\ngroup.enter()\n\nTask {\n    do {\n        // Get environment variables from the Utils module\n        let env = getEnvironment()\n\n        // Initialize SDK\n        let sdk = try await initSdk(username: env.username, password: env.password)\n\n        // Create new user\n        try await sdk.createNewUser(env.username)\n        print(\"created new user: \\(env.username)\")\n        try await sdk.initUser(env.username)\n        print(\"initialized new user: \\(env.username)\")\n\n        // Migrate wallet\n        try await sdk.setWalletPassword(env.pin, env.password)\n        let _ = try await sdk.createWalletFromMnemonic(env.pin, env.mnemonic)\n        print(\"migrated wallet from mnemonic\")                     \n\n    } catch let error as RustString  {\n        fatalError(\"Migrate wallet from mnemonic example failed: \\(error.toString())\")\n    }  catch {\n        fatalError(\"Unexpected error occurred: \\(error)\")\n    }\n\n    group.leave()\n}\n\ngroup.wait()\n</code></pre> <pre><code>import * as wasm from \"../pkg/cryptpay_sdk_wasm\";\nimport { initSdk } from './utils';\n\nasync function main() {\n    let username = \"satoshi\";\n    let pin = \"1234\";\n    const sdk = await initSdk(username);\n    let password: string = (process.env.PASSWORD as string);\n    let mnemonic: string = (process.env.MNEMONIC as string);\n    await sdk.createNewUser(username);\n    await sdk.initializeUser(username);\n    await sdk.setWalletPassword(pin, password);\n\n    // Create new wallet from the mnemonic\n    await sdk.createWalletFromMnemonic(pin, mnemonic);\n\n    // use wallet\n    let _address = await sdk.generateNewAddress(pin);\n}\n\nmain();\n</code></pre>"},{"location":"SDK%20Examples/Examples/#5-migrate-wallet-from-backup","title":"5. Migrate Wallet From Backup","text":"RustJavaSwiftJS/TS <pre><code>use sdk::types::newtypes::PlainPassword;\nmod utils;\nuse testing::USER_SATOSHI;\nuse utils::init_sdk;\n\n#[allow(clippy::unwrap_used, clippy::expect_used)]\n#[tokio::main]\nasync fn main() {\n    // Initialize SDK\n    let (mut sdk, _cleanup) = init_sdk().await;\n    let user: utils::TestUser = (*USER_SATOSHI).clone().into();\n\n    // Create new user\n    sdk.create_new_user(&amp;user.username).await.unwrap();\n    sdk.init_user(&amp;user.username).await.unwrap();\n\n    // Create new wallet\n    sdk.set_wallet_password(&amp;user.pin, &amp;user.password).await.unwrap();\n    sdk.create_wallet_from_new_mnemonic(&amp;user.pin).await.unwrap();\n\n    // Create wallet backup and delete it\n    let backup_password = PlainPassword::try_from_string(\"backup_password\").unwrap();\n    let backup = sdk.create_wallet_backup(&amp;user.pin, &amp;backup_password).await.unwrap();\n    sdk.delete_wallet(&amp;user.pin).await.unwrap();\n\n    // Migrate wallet from backup\n    sdk.create_wallet_from_backup(&amp;user.pin, &amp;backup, &amp;backup_password)\n        .await\n        .unwrap();\n\n    // use wallet\n    let _address = sdk.generate_new_address(&amp;user.pin).await.unwrap();\n}\n</code></pre> <pre><code>\n</code></pre> <pre><code>// The Swift Programming Language\n// https://docs.swift.org/swift-book\n\nimport Foundation\nimport CawaenaSdk\nimport utils\n\n// We use a DispatchGroup to make the program wait until async functions finish before exiting.\n// Not needed in long-running applications.\nlet group = DispatchGroup()\ngroup.enter()\n\nTask {\n    do {\n        // Get environment variables from the Utils module\n        let env = getEnvironment()\n\n        // Initialize SDK\n        let sdk = try await initSdk(username: env.username, password: env.password)\n\n        // Create new user\n        try await sdk.createNewUser(env.username)\n        print(\"created new user: \\(env.username)\")\n        try await sdk.initUser(env.username)\n        print(\"initialized new user: \\(env.username)\")\n\n        // Create new wallet\n        try await sdk.setWalletPassword(env.pin, env.password)\n        let _ = try await sdk.createNewWallet(env.pin)\n        print(\"created new wallet\")\n\n        // Create backup\n        let backup_password = \"backup_password\"\n        let backup = try await sdk.createWalletBackup(env.pin, backup_password)\n\n        // Delete existing wallet\n        try await sdk.deleteWallet(env.pin)\n        print(\"deleted existing wallet\")\n\n        // Migrate wallet from backup\n        try await sdk.restoreWalletFromBackup(env.pin, backup, backup_password)\n        print(\"wallet restored from backup\")                      \n\n    } catch let error as RustString  {\n        fatalError(\"Migrate wallet from backup example failed: \\(error.toString())\")\n    }  catch {\n        fatalError(\"Unexpected error occurred: \\(error)\")\n    }\n\n    group.leave()\n}\n\ngroup.wait()\n</code></pre> <pre><code>import * as wasm from \"../pkg/cryptpay_sdk_wasm\";\nimport { initSdk } from './utils';\n\nasync function main() {\n    let username = \"satoshi\";\n    let pin = \"1234\";\n    const sdk = await initSdk(username);\n    let password: string = (process.env.PASSWORD as string);\n    let mnemonic: string = (process.env.MNEMONIC as string);\n    await sdk.createNewUser(username);\n    await sdk.initializeUser(username);\n    await sdk.setWalletPassword(pin, password);\n\n    // Create new wallet from the mnemonic\n    await sdk.createNewWallet(pin);\n\n    // Create wallet backup and delete it\n    let backup_password = \"backup_password\";\n\n    let backup = await sdk.createWalletBackup(pin, backup_password);\n    await sdk.deleteWallet(pin)\n\n    // Migrate wallet from backup\n    await sdk.createWalletFromBackup(pin, backup, backup_password);\n\n    // use wallet\n    let _address = await sdk.generateNewAddress(pin);\n}\n\nmain();\n</code></pre>"},{"location":"SDK%20Examples/Examples/#6-generate-new-receiver-address","title":"6. Generate New Receiver Address","text":"RustJavaSwiftJS/TS <pre><code>use testing::USER_SATOSHI;\nmod utils;\nuse utils::init_sdk;\n\n#[allow(clippy::unwrap_used)]\n#[tokio::main]\nasync fn main() {\n    // Initialize SDK\n    let (mut sdk, _cleanup) = init_sdk().await;\n    let user: utils::TestUser = (*USER_SATOSHI).clone().into();\n\n    // Create new user\n    sdk.create_new_user(&amp;user.username).await.unwrap();\n    sdk.init_user(&amp;user.username).await.unwrap();\n\n    // Create / init new wallet from mnemonic\n    sdk.set_wallet_password(&amp;user.pin, &amp;user.password).await.unwrap();\n    sdk.create_wallet_from_existing_mnemonic(&amp;user.pin, &amp;user.mnemonic)\n        .await\n        .unwrap();\n\n    // Generate address\n    let address = sdk.generate_new_address(&amp;user.pin).await.unwrap();\n    println!(\"Address: {}\", address);\n}\n</code></pre> <pre><code>\n</code></pre> <pre><code>// The Swift Programming Language\n// https://docs.swift.org/swift-book\n\nimport Foundation\nimport CawaenaSdk\nimport utils\n\n// We use a DispatchGroup to make the program wait until async functions finish before exiting.\n// Not needed in long-running applications.\nlet group = DispatchGroup()\ngroup.enter()\n\nTask {\n    do {\n        // Get environment variables from the Utils module\n        let env = getEnvironment()\n\n        // Initialize SDK\n        let sdk = try await initSdk(username: env.username, password: env.password)\n\n        // Create new user\n        try await sdk.createNewUser(env.username)\n        print(\"created new user: \\(env.username)\")\n        try await sdk.initUser(env.username)\n        print(\"initialized new user: \\(env.username)\")\n\n        // Migrate wallet\n        try await sdk.setWalletPassword(env.pin, env.password)\n        let _ = try await sdk.createWalletFromMnemonic(env.pin, env.mnemonic)\n        print(\"migrated wallet from mnemonic\")\n\n        // Generate address\n        let address = try await sdk.generateNewAddress(env.pin)\n        print(\"generated new receiver address: \\(address.toString())\")                  \n\n    } catch let error as RustString  {\n        fatalError(\"Generate new iota address example failed: \\(error.toString())\")\n    }  catch {\n        fatalError(\"Unexpected error occurred: \\(error)\")\n    }\n\n    group.leave()\n}\n\ngroup.wait()\n</code></pre> <pre><code>import * as wasm from \"../pkg/cryptpay_sdk_wasm\";\nimport { initSdk } from './utils';\n\nasync function main() {\n    let username = \"satoshi\";\n    let pin = \"1234\";\n\n    const sdk = await initSdk(username);\n    let password: string = (process.env.PASSWORD as string);\n    let mnemonic: string = (process.env.MNEMONIC as string);\n\n    await sdk.createNewUser(username);\n    await sdk.initializeUser(username);\n    await sdk.setWalletPassword(pin, password);\n\n    await sdk.createNewWallet(pin);\n    console.log(\"Wallet initialized!\");\n    let address = await sdk.generateNewAddress(pin);\n    console.log(\"Address:\", address);\n}\n\nmain();\n</code></pre>"},{"location":"SDK%20Examples/Examples/#7-get-balance","title":"7. Get Balance","text":"RustJavaSwiftJS/TS <pre><code>use testing::USER_SATOSHI;\nmod utils;\nuse utils::init_sdk;\n\n#[allow(clippy::unwrap_used)]\n#[tokio::main]\nasync fn main() {\n    // Initialize SDK\n    let (mut sdk, _cleanup) = init_sdk().await;\n    let user: utils::TestUser = (*USER_SATOSHI).clone().into();\n\n    // Create new user\n    sdk.create_new_user(&amp;user.username).await.unwrap();\n    sdk.init_user(&amp;user.username).await.unwrap();\n\n    // Create / init new wallet from mnemonic\n    sdk.set_wallet_password(&amp;user.pin, &amp;user.password).await.unwrap();\n    sdk.create_wallet_from_existing_mnemonic(&amp;user.pin, &amp;user.mnemonic)\n        .await\n        .unwrap();\n\n    // Generate address\n    let address = sdk.generate_new_address(&amp;user.pin).await.unwrap();\n    println!(\"Address: {}\", address);\n\n    // Get balance\n    let balance = sdk.get_balance(&amp;user.pin).await.unwrap();\n    println!(\"Balance: {:?}\", balance);\n}\n</code></pre> <pre><code>\n</code></pre> <pre><code>// The Swift Programming Language\n// https://docs.swift.org/swift-book\n\nimport Foundation\nimport CawaenaSdk\nimport utils\n\n// We use a DispatchGroup to make the program wait until async functions finish before exiting.\n// Not needed in long-running applications.\nlet group = DispatchGroup()\ngroup.enter()\n\nTask {\n    do {\n        // Get environment variables from the Utils module\n        let env = getEnvironment()\n\n        // Initialize SDK\n        let sdk = try await initSdk(username: env.username, password: env.password)\n\n        // Create new user\n        try await sdk.createNewUser(env.username)\n        print(\"created new user: \\(env.username)\")\n        try await sdk.initUser(env.username)\n        print(\"initialized new user: \\(env.username)\")\n\n        // Migrate wallet\n        try await sdk.setWalletPassword(env.pin, env.password)\n        let _ = try await sdk.createWalletFromMnemonic(env.pin, env.mnemonic)\n        print(\"migrated wallet from mnemonic\")\n\n        // Generate address\n        let address = try await sdk.generateNewAddress(env.pin)\n        print(\"generated new receiver address: \\(address.toString())\")\n\n        // Get wallet balance\n        let balance = try await sdk.getWalletBalance(env.pin)\n        print(\"balance: \\(balance)\")                    \n\n    } catch let error as RustString  {\n        fatalError(\"Get wallat balance failed: \\(error.toString())\")\n    }  catch {\n        fatalError(\"Unexpected error occurred: \\(error)\")\n    }\n\n    group.leave()\n}\n\ngroup.wait()\n</code></pre> <pre><code>import * as wasm from \"../pkg/cryptpay_sdk_wasm\";\nimport { initSdk } from './utils';\n\nasync function main() {\n    console.log(\"start\");\n    let username = \"satoshi\";\n    let pin = \"1234\";\n    const sdk = await initSdk(username);\n    let password: string = (process.env.PASSWORD as string);\n    let mnemonic: string = (process.env.MNEMONIC as string);\n    await sdk.createNewUser(username);\n    await sdk.initializeUser(username);\n    await sdk.setWalletPassword(pin, password);\n\n    await sdk.createWalletFromMnemonic(pin, mnemonic);\n\n    let address = await sdk.generateNewAddress(pin);\n    console.log(\"Address:\", address);\n\n    let balance = await sdk.getWalletBalance(pin);\n    console.log(\"Balance:\", balance);\n\n}\n\nmain();\n</code></pre>"},{"location":"SDK%20Examples/Examples/#8-create-purchase-request","title":"8. Create Purchase Request","text":"RustJavaSwiftJS/TS <pre><code>use rust_decimal_macros::dec;\nuse sdk::types::currencies::CryptoAmount;\nuse testing::USER_SATOSHI;\nmod utils;\nuse utils::init_sdk;\n\n#[allow(clippy::unwrap_used)]\n#[tokio::main]\nasync fn main() {\n    // Initialize SDK\n    let (mut sdk, _cleanup) = init_sdk().await;\n    let user: utils::TestUser = (*USER_SATOSHI).clone().into();\n\n    // Create new user\n    sdk.create_new_user(&amp;user.username).await.unwrap();\n    sdk.init_user(&amp;user.username).await.unwrap();\n\n    // Create / init new wallet from mnemonic\n    sdk.set_wallet_password(&amp;user.pin, &amp;user.password).await.unwrap();\n    sdk.create_wallet_from_existing_mnemonic(&amp;user.pin, &amp;user.mnemonic)\n        .await\n        .unwrap();\n\n    // Generate address\n    let address = sdk.generate_new_address(&amp;user.pin).await.unwrap();\n    println!(\"Address: {}\", address);\n\n    // Get balance\n    let balance = sdk.get_balance(&amp;user.pin).await.unwrap();\n    println!(\"Balance: {:?}\", balance);\n\n    // Create purchase request\n    let product_hash = \"2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824\";\n    let app_data = \"{\\\"imageUrl\\\":\\\"https://httpbin.org/\\\",\\\"imageId\\\":\\\"a846ad10-fc69-4b22-b442-5dd740ace361\\\"}\";\n    let purchase_type = \"CLIK\";\n\n    let amount = CryptoAmount::try_from(dec!(2.0)).unwrap();\n    let purchase_id = sdk\n        .create_purchase_request(\"alice\", amount, product_hash, app_data, purchase_type)\n        .await\n        .unwrap();\n    println!(\"Purchase_id {} \", purchase_id); // print the purchase id to facilitate debugging\n}\n</code></pre> <pre><code>\n</code></pre> <pre><code>// The Swift Programming Language\n// https://docs.swift.org/swift-book\n\nimport CawaenaSdk\nimport Foundation\nimport utils\n\n// We use a DispatchGroup to make the program wait until async functions finish before exiting.\n// Not needed in long-running applications.\nlet group = DispatchGroup()\ngroup.enter()\n\nTask {\n    do {\n        // Get environment variables from the Utils module\n        let env = getEnvironment()\n\n        // Initialize SDK\n        let sdk = try await initSdk(username: env.username, password: env.password)\n\n        // Create new user\n        try await sdk.createNewUser(env.username)\n        print(\"created new user: \\(env.username)\")\n        try await sdk.initUser(env.username)\n        print(\"initialized new user: \\(env.username)\")\n\n        // Migrate wallet\n        try await sdk.setWalletPassword(env.pin, env.password)\n        let _ = try await sdk.createWalletFromMnemonic(env.pin, env.mnemonic)\n        print(\"migrated wallet from mnemonic\")\n\n        // Generate address\n        let address = try await sdk.generateNewAddress(env.pin)\n        print(\"generated new receiver address: \\(address.toString())\")\n\n        // Get wallet balance\n        let balance = try await sdk.getWalletBalance(env.pin)\n        print(\"balance: \\(balance)\")\n\n        // Create purchase request\n        let product_hash = \"2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824\"\n        let app_data =\n            \"{\\\"imageUrl\\\":\\\"https://httpbin.org/\\\",\\\"imageId\\\":\\\"a846ad10-fc69-4b22-b442-5dd740ace361\\\"}\"\n        let purchase_type = \"CLIK\"\n\n        let purchase_id = try await sdk.createPurchaseRequest(\n            \"alice\", 2, product_hash, app_data, purchase_type)\n        print(\"Purchase Request created: \\(purchase_id.toString())\")\n\n    } catch let error as RustString {\n        fatalError(\"Create purchase request example failed: \\(error.toString())\")\n    } catch {\n        fatalError(\"Unexpected error occurred: \\(error)\")\n    }\n\n    group.leave()\n}\n\ngroup.wait()\n</code></pre> <pre><code>import { debug } from \"util\";\nimport * as wasm from \"../pkg/cryptpay_sdk_wasm\";\nimport { initSdk } from './utils';\n\nasync function main() {\n    let username = \"satoshi\";\n    let pin = \"1234\";\n    let receiver = \"alice\";\n    const sdk = await initSdk(username);\n    let mnemonic: string = (process.env.MNEMONIC as string);\n    let password: string = (process.env.PASSWORD as string);\n\n    await sdk.createNewUser(username);\n    await sdk.initializeUser(username);\n    await sdk.setWalletPassword(pin, password);\n    await sdk.createWalletFromMnemonic(pin, mnemonic);\n    let address = await sdk.generateNewAddress(pin);\n    debug(`Generated new IOTA receiver address: ${address}`);\n    let balance = await sdk.getWalletBalance(pin);\n\n    console.log(\"balance : \", balance);\n\n    let product_hash = \"2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824\";\n    let app_data = JSON.stringify({\n        \"imageUrl\": \"https://httpbin.org/\",\n        \"imageId\": \"a846ad10-fc69-4b22-b442-5dd740ace361\"\n    });\n\n    let purchase_type = \"CLIK\";\n\n    let purchase_id = await sdk.createPurchaseRequest(receiver, 2.0, product_hash, app_data, purchase_type);\n    console.log(\"Purchase ID:\", purchase_id);\n\n}\n\nmain();\n</code></pre>"},{"location":"SDK%20Examples/Examples/#9-onboard-a-user-on-viviswap","title":"9. Onboard a User on Viviswap","text":"RustJavaSwiftJS/TS <pre><code>use fake::{\n    faker::name::{en::LastName, raw::FirstName},\n    locales::EN,\n    Fake,\n};\nuse sdk::types::viviswap::{ViviswapVerificationStatus, ViviswapVerificationStep};\nuse std::io::Write;\nuse testing::USER_SATOSHI;\nmod utils;\nuse utils::init_sdk;\n\n// ---------------------------------------------\n// Note: This example will not run until the end because the user already exists in Viviswap db and it will not create a new one.\n// ---------------------------------------------\n\n#[allow(clippy::unwrap_used, clippy::expect_used)]\n#[tokio::main]\nasync fn main() {\n    // Initialize SDK and create a new user\n    let (mut sdk, _cleanup) = init_sdk().await;\n    let user: utils::TestUser = (*USER_SATOSHI).clone().into();\n\n    sdk.create_new_user(&amp;user.username).await.unwrap();\n    sdk.init_user(&amp;user.username).await.unwrap();\n\n    // Exit if user is already verified\n    let is_verified = sdk.is_kyc_status_verified(&amp;user.username).await.unwrap();\n    if is_verified {\n        println!(\"User is already verified, please run the delete_user example first.\");\n        return;\n    }\n\n    // Create sap customer if not exists\n    if sdk.get_customer().await.is_err() {\n        sdk.create_customer(\"DE\").await.unwrap();\n    };\n\n    // Start KYC verification for viviswap\n    // The user already exists in viviswap db. Therefore, the test will fail here.\n    let new_user = sdk\n        .start_kyc_verification_for_viviswap(&amp;format!(\"{}@gmail.com\", user.username), true)\n        .await\n        .unwrap();\n    println!(\"New Viviswap user: {:#?}\", new_user);\n\n    // Get KYC status for viviswap\n    let status = sdk.get_kyc_details_for_viviswap().await.unwrap();\n    println!(\"Status: {:#?}\", status);\n\n    // Update KYC status for viviswap\n    let is_individual = Some(true);\n    let is_pep = Some(false);\n    let is_us_citizen = Some(false);\n    let is_regulatory_disclosure = Some(true);\n    let country_of_residence = Some(\"DE\".into());\n    let nationality = Some(\"DE\".to_string());\n    let full_name = Some(format!(\n        \"{} {}\",\n        FirstName(EN).fake::&lt;String&gt;(),\n        LastName().fake::&lt;String&gt;()\n    ));\n    let date_of_birth = Some(\"2001-11-05\".to_string());\n\n    let details = sdk\n        .update_kyc_partially_status_for_viviswap(\n            is_individual,\n            is_pep,\n            is_us_citizen,\n            is_regulatory_disclosure,\n            country_of_residence,\n            nationality,\n            full_name,\n            date_of_birth,\n        )\n        .await\n        .unwrap();\n    println!(\"Details: {:#?}\", details);\n\n    sdk.submit_kyc_partially_status_for_viviswap().await.unwrap();\n\n    // Create a waiting loop that prints a dot every 5 seconds for 30 secounds\n    println!(\"Waiting for KYC verification to complete\");\n    for _ in 0..12 {\n        tokio::time::sleep(tokio::time::Duration::from_secs(6)).await;\n        print!(\".\");\n        std::io::stdout().flush().unwrap();\n        let kyc_details = sdk.get_kyc_details_for_viviswap().await.unwrap();\n        if kyc_details.verified_step == ViviswapVerificationStep::Personal {\n            break;\n        }\n    }\n    println!();\n\n    // Check that the user is verified\n    let is_verified = sdk.is_kyc_status_verified(&amp;user.username).await.unwrap();\n    println!(\"IsVerified: {:#?}\", is_verified);\n\n    let kyc_details = sdk.get_kyc_details_for_viviswap().await.unwrap();\n    println!(\"KycDetails: {:#?}\", kyc_details);\n    assert!(kyc_details.verification_status == ViviswapVerificationStatus::Unverified);\n    assert!(kyc_details.verified_step == ViviswapVerificationStep::Personal);\n    assert!(kyc_details.submission_step == ViviswapVerificationStep::Identity);\n}\n</code></pre> <pre><code>\n</code></pre> <pre><code>// The Swift Programming Language\n// https://docs.swift.org/swift-book\n\n// Onboard with viviswap example\n// The user already exists in viviswap db. Therefore, the test will fail here.\n\nimport CawaenaSdk\nimport Foundation\nimport utils\n\n// We use a DispatchGroup to make the program wait until async functions finish before exiting.\n// Not needed in long-running applications.\nlet group = DispatchGroup()\ngroup.enter()\n\nTask {\n    do {\n        // Get environment variables from the Utils module\n        let env = getEnvironment()\n\n        // Initialize SDK\n        let sdk = try await initSdk(username: env.username, password: env.password)\n\n        // Create new user\n        try await sdk.createNewUser(env.username)\n        print(\"created new user: \\(env.username)\")\n        try await sdk.initUser(env.username)\n        print(\"initialized new user: \\(env.username)\")\n\n        // Exit if user is already verified\n        let is_verified = try await sdk.isKycVerified(env.username)\n        print(\"is verified: \\(is_verified)\")\n        if is_verified {\n            print(\"User is already verified. No need to delete. Exiting\")\n            return\n        }\n\n        // Create sap customer if not exists\n        do {\n            try await sdk.getCustomer()\n            print(\"sap customer exists. Continue\")\n        } catch {\n            try await sdk.createCustomer(\"DE\")\n            print(\"created new sap customer\")\n        }\n\n        // Start KYC verification for viviswap\n        let new_user = try await sdk.startKycVerificationForViviswap(\n            \"swift_example@gmail.com\", true)\n        print(\"New viviswap user: \\(new_user)\")\n\n        // Get KYC status for viviswap\n        let status = try await sdk.getKycDetailsForViviswap()\n        print(\"Status: \\(status)\")\n\n        // Update KYC status for viviswap\n        var isIndividual: Bool? = true\n        var isPep: Bool? = false\n        var isUsCitizen: Bool? = false\n        var isRegulatoryDisclosure: Bool? = true\n        var countryOfResidence: String? = \"DE\"\n        var nationality: String? = \"DE\"\n        var fullName: String? = \"fake fake\"\n        var dateOfBirth: String? = \"2001-11-05\"\n\n        let details =\n            try await sdk\n            .updateKycPartiallyStatusForViviswap(\n                isIndividual,\n                isPep,\n                isUsCitizen,\n                isRegulatoryDisclosure,\n                countryOfResidence,\n                nationality,\n                fullName,\n                dateOfBirth\n            )\n        print(\"Details: \\(details)\")\n        try await sdk.submitKycPartiallyStatusForViviswap()\n\n        // Create a waiting loop that prints a dot every 5 seconds for 30 seconds\n        print(\"Waiting for KYC verification to complete\")\n        for _ in 0..&lt;12 {\n            sleep(6)\n            print(\".\")\n            fflush(stdout)\n            let kycDetails = try await sdk.getKycDetailsForViviswap()\n            if kycDetails.verified_step == .Personal {\n                break\n            }\n        }\n\n        // Check that the user is verified\n        let isVerified = try await sdk.isKycVerified(env.username)\n        print(\"IsVerified: \\(isVerified)\")\n\n    } catch let error as RustString {\n        fatalError(\"Onboard user with viviswap example failed: \\(error.toString())\")\n    } catch {\n        fatalError(\"Unexpected error occurred: \\(error)\")\n    }\n\n    group.leave()\n}\n\ngroup.wait()\n</code></pre> <pre><code>import * as wasm from \"../pkg/cryptpay_sdk_wasm\";\nimport { initSdk } from './utils';\n\nasync function main() {\n    let username = \"satoshi\";\n    const sdk = await initSdk(username);\n    await sdk.createNewUser(username);\n    await sdk.initializeUser(username);\n\n    let is_verified = await sdk.isKycVerified(username)\n\n    if (is_verified) {\n        console.log(\"user is verified\");\n        return;\n    }\n\n    try {\n\n        await sdk.getCustomer();\n        console.log(\"sap customer exists. Continue\");\n\n    } catch (error) {\n\n        await sdk.createCustomer(\"DE\");\n        console.log(\"created new sap customer\");\n\n    }\n\n    // Start KYC verification for viviswap\n    // The user already exists in viviswap db. Therefore, the test will fail here.\n\n    let newUser = await sdk.startKycVerificationForViviswap(\"wasmtest@gmail.com\", true);\n    console.log(`New viviswap user: ${newUser}`);\n}\n\n\nmain();\n</code></pre>"},{"location":"SDK%20Examples/Examples/#10-verify-pin","title":"10. Verify Pin","text":"RustJavaSwiftJS/TS <pre><code>mod utils;\nuse testing::USER_SATOSHI;\nuse utils::init_sdk;\n\n#[allow(clippy::unwrap_used, clippy::expect_used)]\n#[tokio::main]\nasync fn main() {\n    // Initialize SDK\n    let (mut sdk, _cleanup) = init_sdk().await;\n    let user: utils::TestUser = (*USER_SATOSHI).clone().into();\n\n    // Create new user\n    sdk.create_new_user(&amp;user.username).await.unwrap();\n    sdk.init_user(&amp;user.username).await.unwrap();\n\n    // Create new wallet\n    sdk.set_wallet_password(&amp;user.pin, &amp;user.password).await.unwrap();\n    sdk.create_wallet_from_new_mnemonic(&amp;user.pin).await.unwrap();\n\n    // Verify pin\n    sdk.verify_pin(&amp;user.pin).await.unwrap();\n}\n</code></pre> <pre><code>\n</code></pre> <pre><code>// The Swift Programming Language\n// https://docs.swift.org/swift-book\n\nimport Foundation\nimport CawaenaSdk\nimport utils\n\n// We use a DispatchGroup to make the program wait until async functions finish before exiting.\n// Not needed in long-running applications.\nlet group = DispatchGroup()\ngroup.enter()\n\nTask {\n    do {\n        // Get environment variables from the Utils module\n        let env = getEnvironment()\n\n        // Initialize SDK\n        let sdk = try await initSdk(username: env.username, password: env.password)\n\n        // Create new user\n        try await sdk.createNewUser(env.username)\n        print(\"created new user: \\(env.username)\")\n        try await sdk.initUser(env.username)\n        print(\"initialized new user: \\(env.username)\")\n\n        // Create new wallet\n        try await sdk.setWalletPassword(env.pin, env.password)        \n        let _ = try await sdk.createNewWallet(env.pin)\n\n        // Verify pin\n        try await sdk.verifyPin(env.pin)\n        print(\"pin verified\")                      \n\n    } catch let error as RustString  {\n        fatalError(\"Verify pin example failed: \\(error.toString())\")\n    }  catch {\n        fatalError(\"Unexpected error occurred: \\(error)\")\n    }\n\n    group.leave()\n}\n\ngroup.wait()\n</code></pre> <pre><code>import * as wasm from \"../pkg/cryptpay_sdk_wasm\";\nimport { initSdk } from './utils';\n\nasync function main() {\n    let username = \"satoshi\";\n    let pin = \"1234\";\n    const sdk = await initSdk(username);\n    let mnemonic: string = (process.env.MNEMONIC as string);\n    let password: string = (process.env.PASSWORD as string);\n\n    await sdk.createNewUser(username);\n    await sdk.initializeUser(username);\n\n    await sdk.setWalletPassword(pin, password);\n    await sdk.createWalletFromMnemonic(pin, mnemonic);\n\n    await sdk.verifyPin(pin);\n    console.log(\"Pin verified successfully\");\n\n}\n\nmain();\n</code></pre>"},{"location":"SDK%20Examples/Examples/#11-reset-pin","title":"11. Reset Pin","text":"RustJavaSwiftJS/TS <pre><code>use sdk::types::newtypes::EncryptionPin;\nmod utils;\nuse testing::USER_SATOSHI;\nuse utils::init_sdk;\n\n// ---------------------------------------------\n// Note: This examples does not work. It gets stuck. Does not pass or fail.\n// ---------------------------------------------\n\n#[allow(clippy::unwrap_used, clippy::expect_used)]\n#[tokio::main]\nasync fn main() {\n    // Initialize SDK\n    let (mut sdk, _cleanup) = init_sdk().await;\n    let user: utils::TestUser = (*USER_SATOSHI).clone().into();\n\n    // Create new user\n    sdk.create_new_user(&amp;user.username).await.unwrap();\n    sdk.init_user(&amp;user.username).await.unwrap();\n\n    // Create new wallet\n    sdk.set_wallet_password(&amp;user.pin, &amp;user.password).await.unwrap();\n    sdk.create_wallet_from_new_mnemonic(&amp;user.pin).await.unwrap();\n\n    // Reset pin\n    let new_pin = EncryptionPin::try_from_string(\"123456\").unwrap();\n    sdk.change_pin(&amp;user.pin, &amp;new_pin).await.unwrap();\n\n    // Verify pin\n    sdk.verify_pin(&amp;new_pin).await.unwrap();\n}\n</code></pre> <pre><code>\n</code></pre> <pre><code>// The Swift Programming Language\n// https://docs.swift.org/swift-book\n\nimport Foundation\nimport CawaenaSdk\nimport utils\n\n// We use a DispatchGroup to make the program wait until async functions finish before exiting.\n// Not needed in long-running applications.\nlet group = DispatchGroup()\ngroup.enter()\n\nTask {\n    do {\n        // Get environment variables from the Utils module\n        let env = getEnvironment()\n        let new_pin = \"4321\";\n\n        // Initialize SDK\n        let sdk = try await initSdk(username: env.username, password: env.password)\n\n        // Create new user\n        try await sdk.createNewUser(env.username)\n        print(\"created new user: \\(env.username)\")\n        try await sdk.initUser(env.username)\n        print(\"initialized new user: \\(env.username)\")\n\n        // Create new wallet\n        try await sdk.setWalletPassword(env.pin, env.password)        \n        let _ = try await sdk.createNewWallet(env.pin)\n        print(\"created new wallet\")\n\n        // Reset pin\n        try await sdk.resetPin(env.pin, new_pin)\n        print(\"pin reseted\")\n\n        // Verify new pin\n        try await sdk.verifyPin(new_pin)\n        print(\"new pin verified\")                     \n\n    } catch let error as RustString  {\n        fatalError(\"Reset pin example failed: \\(error.toString())\")\n    }  catch {\n        fatalError(\"Unexpected error occurred: \\(error)\")\n    }\n\n    group.leave()\n}\n\ngroup.wait()\n</code></pre> <pre><code>import * as wasm from \"../pkg/cryptpay_sdk_wasm\";\nimport { initSdk } from './utils';\n\nasync function main() {\n    let username = \"satoshi\";\n    let pin = \"1234\";\n    let new_pin = \"54321\";\n    const sdk = await initSdk(username);\n    let mnemonic: string = (process.env.MNEMONIC as string);\n    let password: string = (process.env.PASSWORD as string);\n\n    await sdk.createNewUser(username);\n    await sdk.initializeUser(username);\n    await sdk.setWalletPassword(pin, password);\n    await sdk.createWalletFromMnemonic(pin, mnemonic);\n\n    await sdk.resetPin(pin, new_pin);\n    console.log(\"Reset pin successful\");\n\n    await sdk.verifyPin(new_pin);\n    console.log(\"new pin verified\");\n}\n\nmain();\n</code></pre>"},{"location":"SDK%20Examples/Examples/#12-change-password","title":"12. Change Password","text":"RustJavaSwiftJS/TS <pre><code>use sdk::types::newtypes::PlainPassword;\nmod utils;\nuse testing::USER_SATOSHI;\nuse utils::init_sdk;\n\n#[allow(clippy::unwrap_used, clippy::expect_used)]\n#[tokio::main]\nasync fn main() {\n    // Initialize SDK\n    let (mut sdk, _cleanup) = init_sdk().await;\n    let user: utils::TestUser = (*USER_SATOSHI).clone().into();\n\n    // Create new user\n    sdk.create_new_user(&amp;user.username).await.unwrap();\n    sdk.init_user(&amp;user.username).await.unwrap();\n\n    // Create new wallet\n    sdk.set_wallet_password(&amp;user.pin, &amp;user.password).await.unwrap();\n    sdk.create_wallet_from_new_mnemonic(&amp;user.pin).await.unwrap();\n\n    // Change password\n    let new_password = PlainPassword::try_from_string(\"StrongP@ssw0rd\").unwrap();\n    sdk.set_wallet_password(&amp;user.pin, &amp;new_password).await.unwrap();\n\n    // use wallet\n    let _address = sdk.generate_new_address(&amp;user.pin).await.unwrap();\n}\n</code></pre> <pre><code>\n</code></pre> <pre><code>// The Swift Programming Language\n// https://docs.swift.org/swift-book\n\nimport CawaenaSdk\nimport Foundation\nimport utils\n\n// We use a DispatchGroup to make the program wait until async functions finish before exiting.\n// Not needed in long-running applications.\nlet group = DispatchGroup()\ngroup.enter()\n\nTask {\n    do {\n        // Get environment variables from the Utils module\n        let env = getEnvironment()\n        let new_password = \"StrongP@ssw0rd\"\n\n        // Initialize SDK\n        let sdk = try await initSdk(username: env.username, password: env.password)\n\n        // Create new user\n        try await sdk.createNewUser(env.username)\n        print(\"created new user: \\(env.username)\")\n        try await sdk.initUser(env.username)\n        print(\"initialized new user: \\(env.username)\")\n\n        // Create new wallet\n        try await sdk.setWalletPassword(env.pin, env.password)\n        let _ = try await sdk.createNewWallet(env.pin)\n        print(\"created new wallet\")\n\n        // Change password\n        try await sdk.setWalletPassword(env.pin, new_password)\n        print(\"password changed\")\n\n    } catch let error as RustString {\n        fatalError(\"Change password example failed: \\(error.toString())\")\n    } catch {\n        fatalError(\"Unexpected error occurred: \\(error)\")\n    }\n\n    group.leave()\n}\n\ngroup.wait()\n</code></pre> <pre><code>import * as wasm from \"../pkg/cryptpay_sdk_wasm\";\nimport { initSdk } from './utils';\n\nasync function main() {\n    let username = \"satoshi\";\n    let pin = \"1234\";\n    let new_pin = \"54321\";\n    const sdk = await initSdk(username);\n    let mnemonic: string = (process.env.MNEMONIC as string);\n    let password: string = (process.env.PASSWORD as string);\n\n    await sdk.createNewUser(username);\n    await sdk.initializeUser(username);\n    await sdk.setWalletPassword(pin, password);\n    await sdk.createWalletFromMnemonic(pin, mnemonic);\n\n    let new_password = \"new password\"\n    await sdk.setWalletPassword(pin, new_password);\n    console.log(\"change password successful\");\n\n    // use wallet\n    let _address = await sdk.generateNewAddress(pin);\n}\n\nmain();\n</code></pre>"},{"location":"SDK%20Examples/Examples/#13-send-amount","title":"13. Send Amount","text":"RustJavaSwiftJS/TS <pre><code>mod utils;\nuse rust_decimal_macros::dec;\nuse testing::USER_SATOSHI;\nuse utils::init_sdk;\n\n#[allow(clippy::unwrap_used, clippy::expect_used)]\n#[tokio::main]\nasync fn main() {\n    // Initialize SDK\n    let user: utils::TestUser = (*USER_SATOSHI).clone().into();\n    let (mut sdk, _cleanup) = init_sdk().await;\n\n    // Create new user\n    sdk.create_new_user(&amp;user.username).await.unwrap();\n    sdk.init_user(&amp;user.username).await.unwrap();\n\n    // Create / init new wallet from mnemonic\n    sdk.set_wallet_password(&amp;user.pin, &amp;user.password).await.unwrap();\n    sdk.create_wallet_from_existing_mnemonic(&amp;user.pin, &amp;user.mnemonic)\n        .await\n        .unwrap();\n\n    // Generate new address\n    let recipient_address = sdk.generate_new_address(&amp;user.pin).await.unwrap();\n    println!(\"address: {recipient_address}\");\n\n    // Send amount\n    let amount = dec!(2.0).try_into().unwrap();\n    sdk.send_amount(&amp;user.pin, &amp;recipient_address, amount, None, None, None)\n        .await\n        .unwrap();\n}\n</code></pre> <pre><code>\n</code></pre> <pre><code>// The Swift Programming Language\n// https://docs.swift.org/swift-book\n\nimport CawaenaSdk\nimport Foundation\nimport utils\n\n// We use a DispatchGroup to make the program wait until async functions finish before exiting.\n// Not needed in long-running applications.\nlet group = DispatchGroup()\ngroup.enter()\n\nTask {\n    do {\n        // Get environment variables from the Utils module\n        let env = getEnvironment()\n\n        // Initialize SDK\n        let sdk = try await initSdk(username: env.username, password: env.password)\n\n        // Create new user\n        try await sdk.createNewUser(env.username)\n        print(\"created new user: \\(env.username)\")\n        try await sdk.initUser(env.username)\n        print(\"initialized new user: \\(env.username)\")\n\n        // Migrate wallet\n        try await sdk.setWalletPassword(env.pin, env.password)\n        let _ = try await sdk.createWalletFromMnemonic(env.pin, env.mnemonic)\n        print(\"migrated wallet from mnemonic\")\n\n        // Generate address\n        let address = try await sdk.generateNewAddress(env.pin)\n        print(\"generated new receiver address: \\(address.toString())\")\n\n        // Get wallet balance\n        let balance = try await sdk.getWalletBalance(env.pin)\n        print(\"balance: \\(balance)\")\n\n        // Send amount\n        try await sdk.sendAmount(env.pin, address.toString(), 1, nil, nil, \"swift bindings test\")\n        print(\"sent amount of 1\")\n\n        // Get new balance\n        let new_balance = try await sdk.getWalletBalance(env.pin)\n        print(\"new balance: \\(new_balance)\")\n\n    } catch let error as RustString {\n        fatalError(\"Send amount example failed: \\(error.toString())\")\n    } catch {\n        fatalError(\"Unexpected error occurred: \\(error)\")\n    }\n\n    group.leave()\n}\n\ngroup.wait()\n</code></pre> <pre><code>import * as wasm from \"../pkg/cryptpay_sdk_wasm\";\nimport { initSdk } from './utils';\n\nasync function main() {\n    let username = \"satoshi\";\n    let pin = \"1234\";\n    const sdk = await initSdk(username);\n    let mnemonic: string = (process.env.MNEMONIC as string);\n    let password: string = (process.env.PASSWORD as string);\n\n    await sdk.createNewUser(username);\n    await sdk.initializeUser(username);\n    await sdk.setWalletPassword(pin, password);\n\n    await sdk.createWalletFromMnemonic(pin, mnemonic);\n\n    let recipient_address = await sdk.generateNewAddress(pin);\n    console.log(\"address\", recipient_address);\n\n    let balance_before = await sdk.getWalletBalance(pin);\n    console.log(\"balance before sending amount\", balance_before);\n\n    await sdk.sendAmount(pin, recipient_address, 1.0);\n\n    let balance_after = await sdk.getWalletBalance(pin);\n    console.log(\"balance after sending amount\", balance_after);\n\n}\n\nmain();\n</code></pre>"},{"location":"SDK%20Examples/Examples/#14-get-exchange-rate","title":"14. Get Exchange Rate","text":"RustJavaSwiftJS/TS <pre><code>mod utils;\nuse testing::USER_SATOSHI;\nuse utils::init_sdk;\n\n#[allow(clippy::unwrap_used, clippy::expect_used)]\n#[tokio::main]\nasync fn main() {\n    // Initialize SDK\n    let (mut sdk, _cleanup) = init_sdk().await;\n    let user: utils::TestUser = (*USER_SATOSHI).clone().into();\n\n    // Create new user\n    sdk.create_new_user(&amp;user.username).await.unwrap();\n    sdk.init_user(&amp;user.username).await.unwrap();\n\n    // Get exchange rate\n    let exchange_rate = sdk.get_exchange_rate().await.unwrap();\n    println!(\"Exchange rate: {}\", exchange_rate);\n}\n</code></pre> <pre><code>\n</code></pre> <pre><code>// The Swift Programming Language\n// https://docs.swift.org/swift-book\n\nimport CawaenaSdk\nimport Foundation\nimport utils\n\n// We use a DispatchGroup to make the program wait until async functions finish before exiting.\n// Not needed in long-running applications.\nlet group = DispatchGroup()\ngroup.enter()\n\nTask {\n    do {\n        // Get environment variables from the Utils module\n        let env = getEnvironment()\n\n        // Initialize SDK\n        let sdk = try await initSdk(username: env.username, password: env.password)\n\n        try await sdk.createNewUser(env.username)\n        print(\"created new user: \\(env.username)\")\n        try await sdk.initUser(env.username)\n        print(\"initialized new user: \\(env.username)\")\n\n        let exchange_rate = try await sdk.getExchangeRate()\n        print(\"exchange rate: \\(exchange_rate)\")\n\n    } catch let error as RustString {\n        fatalError(\"Get exchange rate example failed: \\(error.toString())\")\n    } catch {\n        fatalError(\"Unexpected error occurred: \\(error)\")\n    }\n\n    group.leave()\n}\n\ngroup.wait()\n</code></pre> <pre><code>import * as wasm from \"../pkg/cryptpay_sdk_wasm\";\nimport { initSdk } from './utils';\n\nasync function main() {\n\n    let username = \"satoshi\";\n    let pin = \"1234\";\n    const sdk = await initSdk(username);\n    await sdk.createNewUser(username);\n    await sdk.initializeUser(username);\n    let course = await sdk.getExchangeRate();\n    console.log(course);\n}\n\nmain();\n</code></pre>"},{"location":"SDK%20Examples/Examples/#15-claim-outputs","title":"15. Claim Outputs","text":"RustJavaSwiftJS/TS <pre><code>mod utils;\nuse testing::USER_SATOSHI;\nuse utils::init_sdk;\n\n#[allow(clippy::unwrap_used, clippy::expect_used)]\n#[tokio::main]\nasync fn main() {\n    // Initialize SDK\n    let (mut sdk, _cleanup) = init_sdk().await;\n    let user: utils::TestUser = (*USER_SATOSHI).clone().into();\n\n    // Create new user\n    sdk.create_new_user(&amp;user.username).await.unwrap();\n    sdk.init_user(&amp;user.username).await.unwrap();\n\n    // Create new wallet\n    sdk.set_wallet_password(&amp;user.pin, &amp;user.password).await.unwrap();\n    sdk.create_wallet_from_new_mnemonic(&amp;user.pin).await.unwrap();\n\n    // Claim output\n    sdk.claim_outputs(&amp;user.pin).await.unwrap();\n}\n</code></pre> <pre><code>\n</code></pre> <pre><code>// The Swift Programming Language\n// https://docs.swift.org/swift-book\n\nimport CawaenaSdk\nimport Foundation\nimport utils\n\n// We use a DispatchGroup to make the program wait until async functions finish before exiting.\n// Not needed in long-running applications.\nlet group = DispatchGroup()\ngroup.enter()\n\nTask {\n    do {\n        // Get environment variables from the Utils module\n        let env = getEnvironment()\n\n        // Initialize SDK\n        let sdk = try await initSdk(username: env.username, password: env.password)\n\n        // Create new user\n        try await sdk.createNewUser(env.username)\n        print(\"created new user: \\(env.username)\")\n        try await sdk.initUser(env.username)\n        print(\"initialized new user: \\(env.username)\")\n\n        // Create new wallet\n        try await sdk.setWalletPassword(env.pin, env.password)\n        let _ = try await sdk.createNewWallet(env.pin)\n        print(\"created new wallet\")\n\n        // Claim output\n        try await sdk.claimOutputs(env.pin)\n        print(\"claim output success\")\n\n    } catch let error as RustString {\n        fatalError(\"Claim output example failed: \\(error.toString())\")\n    } catch {\n        fatalError(\"Unexpected error occurred: \\(error)\")\n    }\n\n    group.leave()\n}\n\ngroup.wait()\n</code></pre> <pre><code>import * as wasm from \"../pkg/cryptpay_sdk_wasm\";\nimport { initSdk } from './utils';\n\nasync function main() {\n    let username = \"satoshi\";\n    let pin = \"1234\";\n    const sdk = await initSdk(username);\n    let mnemonic: string = (process.env.MNEMONIC as string);\n    let password: string = (process.env.PASSWORD as string);\n\n    await sdk.createNewUser(username);\n    await sdk.initializeUser(username);\n    await sdk.setWalletPassword(pin, password);\n    await sdk.createWalletFromMnemonic(pin, mnemonic);\n    console.log(\"Wallet initialized!\");\n\n    await sdk.claimOutputs(pin);\n    console.log(\"Outputs claimed!\");\n}\n\nmain();\n</code></pre>"},{"location":"SDK%20Examples/Examples/#16-get-purchase-list","title":"16. Get Purchase List","text":"RustJavaSwiftJS/TS <pre><code>mod utils;\nuse testing::USER_SATOSHI;\nuse utils::init_sdk;\n\n#[allow(clippy::unwrap_used, clippy::expect_used)]\n#[tokio::main]\nasync fn main() {\n    // Initialize SDK\n    let (mut sdk, _cleanup) = init_sdk().await;\n    let user: utils::TestUser = (*USER_SATOSHI).clone().into();\n\n    // Create new user\n    sdk.create_new_user(&amp;user.username).await.unwrap();\n    sdk.init_user(&amp;user.username).await.unwrap();\n\n    // Create new wallet\n    sdk.set_wallet_password(&amp;user.pin, &amp;user.password).await.unwrap();\n    sdk.create_wallet_from_new_mnemonic(&amp;user.pin).await.unwrap();\n\n    // Get tx list\n    let tx_list = sdk.get_tx_list(0, 10).await.unwrap();\n    tx_list\n        .txs\n        .iter()\n        .for_each(|tx| println!(\"tx reference id: {:?}\", tx.reference_id));\n}\n</code></pre> <pre><code>\n</code></pre> <pre><code>// The Swift Programming Language\n// https://docs.swift.org/swift-book\n\nimport Foundation\nimport CawaenaSdk\nimport utils\n\n// We use a DispatchGroup to make the program wait until async functions finish before exiting.\n// Not needed in long-running applications.\nlet group = DispatchGroup()\ngroup.enter()\n\nTask {\n    do {\n        // Get environment variables from the Utils module\n        let env = getEnvironment()\n\n        // Initialize SDK\n        let sdk = try await initSdk(username: env.username, password: env.password)\n\n        // Create new user\n        try await sdk.createNewUser(env.username)\n        print(\"created new user: \\(env.username)\")\n        try await sdk.initUser(env.username)\n        print(\"initialized new user: \\(env.username)\")\n\n        // Create new wallet\n        try await sdk.setWalletPassword(env.pin, env.password)\n        let _ = try await sdk.createNewWallet(env.pin)\n        print(\"created new wallet\")\n\n        // Get tx list\n        let tx_list = try await sdk.getTransactionList(0, 10)\n        // need to properly print the list\n        print(\"Tx list: \\(tx_list)\")             \n\n    } catch let error as RustString  {\n        fatalError(\"Get transaction list example failed: \\(error.toString())\")\n    }  catch {\n        fatalError(\"Unexpected error occurred: \\(error)\")\n    }\n\n    group.leave()\n}\n\ngroup.wait()\n</code></pre> <pre><code>import * as wasm from \"../pkg/cryptpay_sdk_wasm\";\nimport { initSdk } from './utils';\n\n\nasync function main() {\n    let username = \"satoshi\";\n    let start = 0;\n    let limit = 10;\n    let pin = \"1234\"; // Define the PIN\n    const sdk = await initSdk(username); // Initialize the SDK\n    let mnemonic: string = (process.env.MNEMONIC as string);\n    let password: string = (process.env.PASSWORD as string);\n\n    await sdk.createNewUser(username); //Creating a new user \n    await sdk.initializeUser(username); // Initialize the user\n\n    await sdk.setWalletPassword(pin, password);\n    await sdk.createWalletFromMnemonic(pin, mnemonic); // Initialize the wallet\n    console.log(\"Wallet initialized!\");\n\n    let transactions = await sdk.getTransactionList(0, 10);  // Get the transaction list\n    console.log(\"Transactions: \" + JSON.stringify(transactions));\n}\n\nmain();\n</code></pre>"},{"location":"SDK%20Examples/Examples/#17-create-customer","title":"17. Create Customer","text":"RustJavaSwiftJS/TS <pre><code>mod utils;\nuse testing::USER_SATOSHI;\nuse utils::init_sdk;\n\n#[allow(clippy::unwrap_used, clippy::expect_used)]\n#[tokio::main]\nasync fn main() {\n    // Initialize SDK and create a new user\n    let (mut sdk, _cleanup) = init_sdk().await;\n    let user: utils::TestUser = (*USER_SATOSHI).clone().into();\n\n    sdk.create_new_user(&amp;user.username).await.unwrap();\n    sdk.init_user(&amp;user.username).await.unwrap();\n\n    // Create sap customer if not exists\n    if sdk.get_customer().await.is_err() {\n        sdk.create_customer(\"DE\").await.unwrap();\n    } else {\n        println!(\"Customer already exists\")\n    }\n}\n</code></pre> <pre><code>\n</code></pre> <pre><code>// The Swift Programming Language\n// https://docs.swift.org/swift-book\n\nimport Foundation\nimport CawaenaSdk\nimport utils\n\n// We use a DispatchGroup to make the program wait until async functions finish before exiting.\n// Not needed in long-running applications.\nlet group = DispatchGroup()\ngroup.enter()\n\nTask {\n    do {\n        // Get environment variables from the Utils module\n        let env = getEnvironment()\n\n        // Initialize SDK\n        let sdk = try await initSdk(username: env.username, password: env.password)\n\n        // Create new user\n        try await sdk.createNewUser(env.username)\n        print(\"created new user: \\(env.username)\")\n        try await sdk.initUser(env.username)\n        print(\"initialized new user: \\(env.username)\")\n\n        // Create sap customer if not exists\n        do {\n            try await sdk.getCustomer()\n            print(\"sap customer exists. Continue\")\n        } catch {\n            try await sdk.createCustomer(\"DE\")\n            print(\"created new sap customer\")\n        }            \n\n    } catch let error as RustString  {\n        fatalError(\"Create customer example failed: \\(error.toString())\")\n    }  catch {\n        fatalError(\"Unexpected error occurred: \\(error)\")\n    }\n\n    group.leave()\n}\n\ngroup.wait()\n</code></pre> <pre><code>import * as wasm from \"../pkg/cryptpay_sdk_wasm\";\nimport { initSdk } from './utils';\n\nasync function main() {\n    let username = \"satoshi\";\n    const country_code = \"DE\";\n    const sdk = await initSdk(username);\n    await sdk.createNewUser(username);\n    await sdk.initializeUser(username);\n\n    try {\n        await sdk.getCustomer(); // Get customer details\n        console.log(\"Customer already exists.\");\n    } catch (error) {\n        console.log(error);\n        await sdk.createCustomer(country_code);\n        console.log(\"user created successfully\");\n    }\n\n}\n\nmain();\n</code></pre>"},{"location":"SDK%20Examples/Examples/#18-delete-user","title":"18. Delete User","text":"RustJavaSwiftJS/TS <pre><code>use sdk::types::newtypes::AccessToken;\nmod utils;\nuse testing::USER_ARCHIVEME;\nuse utils::init_sdk;\n\n// ---------------------------------------------\n// Note: Do not run this example with user `satoshi` because it will then be unverified and it will affect other examples / tests.\n// ---------------------------------------------\n\n#[allow(clippy::unwrap_used, clippy::expect_used)]\n#[tokio::main]\nasync fn main() {\n    // Initialize SDK\n    let (mut sdk, _cleanup) = init_sdk().await;\n    let user: utils::TestUser = (*USER_ARCHIVEME).clone().into();\n\n    // the `init_sdk()` function generates an access token for `satoshi`.\n    // in this example we use `archiveme` user. Therefore, we generate a new access token for the `archiveme` user.\n    let access_token = testing::get_access_token(&amp;user.username, user.password.as_str())\n        .await\n        .access_token;\n    let access_token = AccessToken::try_from(access_token).unwrap();\n    sdk.refresh_access_token(Some(access_token)).await.unwrap();\n\n    // Create new user\n    sdk.create_new_user(&amp;user.username).await.unwrap();\n    sdk.init_user(&amp;user.username).await.unwrap();\n\n    // Create new wallet\n    sdk.set_wallet_password(&amp;user.pin, &amp;user.password).await.unwrap();\n    sdk.create_wallet_from_new_mnemonic(&amp;user.pin).await.unwrap();\n\n    // Delete user\n    sdk.delete_user(Some(&amp;user.pin)).await.unwrap();\n    tokio::time::sleep(tokio::time::Duration::from_secs(2)).await;\n}\n</code></pre> <pre><code>\n</code></pre> <pre><code>// The Swift Programming Language\n// https://docs.swift.org/swift-book\n\nimport Foundation\nimport CawaenaSdk\nimport utils\n\n// We use a DispatchGroup to make the program wait until async functions finish before exiting.\n// Not needed in long-running applications.\nlet group = DispatchGroup()\ngroup.enter()\n\nTask {\n    do {\n        // Get environment variables from the Utils module\n        let env = getEnvironment()\n        let username_archive = ProcessInfo.processInfo.environment[\"ARCHIEVEME\"]!;\n\n        // Initialize SDK\n        let sdk = try await initSdk(username: username_archive, password: env.password)\n\n        // Create new user\n        try await sdk.createNewUser(username_archive)\n        print(\"created new user: \\(username_archive)\")\n        try await sdk.initUser(username_archive)\n        print(\"initialized new user: \\(username_archive)\")\n\n        // Create new wallet\n        try await sdk.setWalletPassword(env.pin, env.password)\n        let _ = try await sdk.createNewWallet(env.pin)\n        print(\"created new wallet\")\n\n        print(\"deleting user and wallet\")\n        try await sdk.deleteUser(env.pin)\n\n        // check verification after deletion. Should be false\n        let verified = try await sdk.isKycVerified(username_archive)\n        print(\"is verified: \\(verified)\")\n\n    } catch let error as RustString  {\n        fatalError(\"Delete user example failed: \\(error.toString())\")\n    }  catch {\n        fatalError(\"Unexpected error occurred: \\(error)\")\n    }\n\n    group.leave()\n}\n\ngroup.wait()\n</code></pre> <pre><code>import * as wasm from \"../pkg/cryptpay_sdk_wasm\";\nimport { initSdk } from './utils';\n\nasync function main() {\n    let username = \"archiveme\";\n    let pin = \"1234\";\n\n    const sdk = await initSdk(username);\n    let password: string = (process.env.PASSWORD as string);\n    let mnemonic: string = (process.env.MNEMONIC as string);\n\n    await sdk.createNewUser(username);\n    await sdk.initializeUser(username);\n    await sdk.setWalletPassword(pin, password);\n    await sdk.createWalletFromMnemonic(pin, mnemonic);\n    await sdk.deleteUser(pin);\n    console.log(\"user deleted_successfully\");\n}\n\nexport { main }\n</code></pre>"},{"location":"SDK%20Examples/Examples/#19-get-wallet-transaction-list","title":"19. Get Wallet Transaction List","text":"RustJavaSwiftJS/TS <pre><code>mod utils;\nuse testing::USER_SATOSHI;\nuse utils::init_sdk;\n\n#[allow(clippy::unwrap_used, clippy::expect_used)]\n#[tokio::main]\nasync fn main() {\n    // Initialize SDK\n    let (mut sdk, _cleanup) = init_sdk().await;\n    let user: utils::TestUser = (*USER_SATOSHI).clone().into();\n\n    // Create new user\n    sdk.create_new_user(&amp;user.username).await.unwrap();\n    sdk.init_user(&amp;user.username).await.unwrap();\n\n    // Create new wallet\n    sdk.set_wallet_password(&amp;user.pin, &amp;user.password).await.unwrap();\n    sdk.create_wallet_from_new_mnemonic(&amp;user.pin).await.unwrap();\n\n    // Get wallet tx list\n    let wallet_tx_list = sdk.get_wallet_tx_list(&amp;user.pin, 0, 10).await.unwrap();\n    wallet_tx_list\n        .transactions\n        .iter()\n        .for_each(|tx| println!(\"Wallet transaction id: {:?}\", tx.transaction_id));\n}\n</code></pre> <pre><code>\n</code></pre> <pre><code>// The Swift Programming Language\n// https://docs.swift.org/swift-book\n\nimport Foundation\nimport CawaenaSdk\nimport utils\n\n// We use a DispatchGroup to make the program wait until async functions finish before exiting.\n// Not needed in long-running applications.\nlet group = DispatchGroup()\ngroup.enter()\n\nTask {\n    do {\n        // Get environment variables from the Utils module\n        let env = getEnvironment()\n\n        // Initialize SDK\n        let sdk = try await initSdk(username: env.username, password: env.password)\n\n        // Create new user\n        try await sdk.createNewUser(env.username)\n        print(\"created new user: \\(env.username)\")\n        try await sdk.initUser(env.username)\n        print(\"initialized new user: \\(env.username)\")\n\n        // Create new wallet\n        try await sdk.setWalletPassword(env.pin, env.password)\n        let _ = try await sdk.createNewWallet(env.pin)\n        print(\"created new wallet\")\n\n        // Get wallet tx list\n        let tx_list = try await sdk.getWalletTransactionList(env.pin, 0, 10)\n        // need to properly print the list\n        print(\"Tx list: \\(tx_list)\")\n\n    } catch let error as RustString  {\n        fatalError(\"Get wallet transaction list example failed: \\(error.toString())\")\n    }  catch {\n        fatalError(\"Unexpected error occurred: \\(error)\")\n    }\n\n    group.leave()\n}\n\ngroup.wait()\n</code></pre> <pre><code>import * as wasm from \"../pkg/cryptpay_sdk_wasm\";\nimport { initSdk } from './utils';\n\n\nasync function main() {\n    let username = \"satoshi\";\n    let pin = \"1234\"; // Define the PIN\n\n    const sdk = await initSdk(username); // Initialize the SDK\n    let mnemonic: string = (process.env.MNEMONIC as string);\n    let password: string = (process.env.PASSWORD as string);\n\n    await sdk.createNewUser(username); //Creating a new user \n    await sdk.initializeUser(username); // Initialize the user\n    await sdk.setWalletPassword(pin, password);\n    await sdk.createWalletFromMnemonic(pin, mnemonic); // Initialize the wallet\n    console.log(\"Wallet initialized!\");\n\n    let transactions = await sdk.getWalletTransactionList(pin, 0, 10);  // Get the transaction list\n    console.log(\"Wallet transactions list: \" + JSON.stringify(transactions));\n}\n\nmain();\n</code></pre>"},{"location":"SDK%20Examples/Examples/#20-send-compliment","title":"20. Send Compliment","text":"RustJavaSwiftJS/TS <pre><code>use api_types::api::transactions::ApiTxStatus;\nuse rust_decimal_macros::dec;\nuse sdk::types::{currencies::CryptoAmount, newtypes::AccessToken};\nuse std::time::Duration;\nuse testing::USER_HANS34;\nmod utils;\nuse tokio::time;\nuse utils::init_sdk;\n\n#[allow(clippy::unwrap_used)]\n#[tokio::main]\nasync fn main() {\n    // Initialize SDK for sender, create new user and migrate wallet\n    let (mut sdk, _cleanup) = init_sdk().await;\n    let user: utils::TestUser = (*USER_HANS34).clone().into();\n\n    // the `init_sdk()` function generates an access token for `satoshi`.\n    // in this example we use `hans34` user. Therefore, we generate a new access token for the `hans34` user.\n    let access_token = testing::get_access_token(&amp;user.username, user.password.as_str())\n        .await\n        .access_token;\n    let access_token = AccessToken::try_from(access_token).unwrap();\n    sdk.refresh_access_token(Some(access_token)).await.unwrap();\n\n    // Create new user\n    sdk.create_new_user(&amp;user.username).await.unwrap();\n    sdk.init_user(&amp;user.username).await.unwrap();\n\n    // Create / init new wallet from mnemonic\n    sdk.set_wallet_password(&amp;user.pin, &amp;user.password).await.unwrap();\n    sdk.create_wallet_from_existing_mnemonic(&amp;user.pin, &amp;user.mnemonic)\n        .await\n        .unwrap();\n\n    // Generate address and get balance\n    let address = sdk.generate_new_address(&amp;user.pin).await.unwrap(); // this is needed, otherwise the balance will be 0 and tx will fail\n    let balance = sdk.get_balance(&amp;user.pin).await.unwrap();\n    println!(\"Balance: {:#?} on address {}\", balance, address);\n\n    // Create purchase request\n    let product_hash = \"2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824\";\n    let app_data = \"{\\\"imageUrl\\\":\\\"https://httpbin.org/\\\",\\\"imageId\\\":\\\"a846ad10-fc69-4b22-b442-5dd740ace361\\\"}\";\n    let purchase_type = \"CLIK\";\n\n    let amount = CryptoAmount::try_from(dec!(2.0)).unwrap();\n    let purchase_id = sdk\n        .create_purchase_request(\"alice\", amount, product_hash, app_data, purchase_type)\n        .await\n        .unwrap();\n    println!(\"Purchase_id {} \", purchase_id); // print the purchase id to facilitate debugging\n\n    // Wait 3 min while tx status becomes valid\n    let result = time::timeout(Duration::from_secs(3 * 60), async {\n        loop {\n            time::sleep(Duration::from_secs(5)).await;\n            let details = sdk.get_purchase_details(&amp;purchase_id).await.unwrap();\n            match details.status {\n                ApiTxStatus::Valid =&gt; {\n                    println!(\"Purchase request valid, moving on...\");\n                    break;\n                }\n                ApiTxStatus::Invalid(r) =&gt; {\n                    panic!(\"Purchase request invalid! Reason: {:?}. Exiting\", r);\n                }\n                ApiTxStatus::WaitingForVerification(r) =&gt; {\n                    panic!(\"Purchase request waiting for verification! Reason: {:?}.\", r);\n                }\n                _ =&gt; {}\n            }\n        }\n    })\n    .await;\n    if result.is_err() {\n        panic!(\"Timeout reached while waiting for purchase request to become valid\");\n    }\n\n    // Step 4: Confirm purchase request (perform actual wallet transaction)\n    sdk.confirm_purchase_request(&amp;user.pin, &amp;purchase_id).await.unwrap();\n\n    // Wait 3 min while tx status becomes completed\n    let result = time::timeout(Duration::from_secs(3 * 60), async {\n        loop {\n            time::sleep(Duration::from_secs(5)).await;\n            let status = sdk.get_purchase_details(&amp;purchase_id).await.unwrap().status;\n            println!(\" - Status: {:?}\", status);\n            if status == ApiTxStatus::Completed {\n                println!(\"Purchase request completed, done!\");\n                break;\n            } else if status == ApiTxStatus::Failed {\n                panic!(\"Purchase request failed\");\n            }\n        }\n    })\n    .await;\n    if result.is_err() {\n        panic!(\"Timeout reached while waiting for purchase request to complete\");\n    }\n\n    // Check new balance\n    let balance = sdk.get_balance(&amp;user.pin).await.unwrap();\n    println!(\"New Balance: {:#?}\", balance);\n}\n</code></pre> <pre><code>\n</code></pre> <pre><code>// The Swift Programming Language\n// https://docs.swift.org/swift-book\n\nimport CawaenaSdk\nimport Foundation\nimport utils\n\n// We use a DispatchGroup to make the program wait until async functions finish before exiting.\n// Not needed in long-running applications.\nlet group = DispatchGroup()\ngroup.enter()\n\nTask {\n    do {\n        // Get environment variables from the Utils module\n        let env = getEnvironment()\n        let username_alice = ProcessInfo.processInfo.environment[\"ALICE\"]!\n        let mnemonic_alice = ProcessInfo.processInfo.environment[\"MNEMONIC_ALICE\"]!\n\n        // Initialize SDK\n        let sdk = try await initSdk(username: username_alice, password: env.password)\n\n        // Create new user\n        try await sdk.createNewUser(username_alice)\n        print(\"created new user: \\(username_alice)\")\n        try await sdk.initUser(username_alice)\n        print(\"initialized new user: \\(username_alice)\")\n\n        // Migrate wallet\n        try await sdk.setWalletPassword(env.pin, env.password)\n        let _ = try await sdk.createWalletFromMnemonic(env.pin, mnemonic_alice)\n        print(\"migrated wallet from mnemonic\")\n\n        // Generate address\n        let address = try await sdk.generateNewAddress(env.pin)\n        print(\"generated new receiver address: \\(address.toString())\")\n\n        let balance = try await sdk.getWalletBalance(env.pin)\n        print(\"balance: \\(balance)\")\n\n        // Create purchase request\n        let product_hash = \"2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824\"\n        let app_data = \"swift example\"\n        let purchase_type = \"CLIK\"\n\n        let purchase_id = try await sdk.createPurchaseRequest(\n            \"satoshi\", 3, product_hash, app_data, purchase_type)\n        print(\"Purchase Request created: \\(purchase_id.toString())\")\n\n        // Wait 3 min while tx status becomes valid\n        let timeoutDate1 = Date().addingTimeInterval(3 * 60)\n        test: while Date() &lt; timeoutDate1 {\n            try await Task.sleep(nanoseconds: 5 * 1_000_000_000)\n            let details = try await sdk.getPurchaseDetails(purchase_id.toString())\n            let status = details.status\n            print(\" - Status: \\(status)\")\n            switch status {\n            case .Valid:\n                print(\"Purchase request valid, moving on...\")\n                break test\n            case .WaitingForVerification:\n                fatalError(\"Purchase request invalid! Reason: \\(details.invalid_reasons). Exiting\")\n            case .Invalid:\n                fatalError(\"Purchase request invalid! Reason: \\(details.invalid_reasons). Exiting\")\n            default:\n                continue\n            }\n        }\n        if Date() &gt;= timeoutDate1 {\n            fatalError(\"Timeout reached while waiting for purchase request to become valid\")\n        }\n\n        // Step 4: Confirm purchase request (perform actual wallet transaction)\n        try await sdk.confirmPurchaseRequest(env.pin, purchase_id.toString())\n\n        // Wait 3 min while tx status becomes completed\n        let timeoutDate2 = Date().addingTimeInterval(3 * 60)\n        test2: while Date() &lt; timeoutDate2 {\n            try await Task.sleep(nanoseconds: 5 * 1_000_000_000)\n            let status = try await sdk.getPurchaseDetails(purchase_id.toString()).status\n            print(\" - Status: \\(status)\")\n            if status == .Completed {\n                print(\"Purchase request completed, done!\")\n                break test2\n            } else if status == .Failed {\n                fatalError(\"Purchase request failed\")\n            }\n        }\n        if Date() &gt;= timeoutDate2 {\n            fatalError(\"Timeout reached while waiting for purchase request to complete\")\n        }\n\n        // Check new balance\n        let new_balance = try await sdk.getWalletBalance(env.pin)\n        print(\"New Balance: \\(new_balance)\")\n\n    } catch let error as RustString {\n        fatalError(\"Send compliment example failed: \\(error.toString())\")\n    } catch {\n        fatalError(\"Unexpected error occurred: \\(error)\")\n    }\n\n    group.leave()\n}\n\ngroup.wait()\n</code></pre> <pre><code>import * as wasm from \"../pkg/cryptpay_sdk_wasm\";\nimport { initSdk } from './utils';\n\n// Send compliment example with sender `alice` and receiver `satoshi`\n\nconst sleep = (delay: number) =&gt; new Promise((resolve) =&gt; setTimeout(resolve, delay));\nconst timeoutMs = 3 * 60 * 1000;\nconst timeoutPromise = new Promise&lt;never&gt;((_, reject) =&gt;\n    setTimeout(() =&gt; reject(new Error(\"Timeout reached!\")), timeoutMs)\n);\n\nasync function main() {\n    let username = \"alice\";\n    let pin = \"1234\";\n\n    // Initialize SDK\n    const sdk = await initSdk(username);\n\n    // Get env variables\n    let mnemonic: string = (process.env.MNEMONIC_ALICE as string);\n    let password: string = (process.env.PASSWORD as string);\n\n    // Create new user and initialize it\n    await sdk.createNewUser(username);\n    await sdk.initializeUser(username);\n\n\n    // Create new wallet and initialize it\n    await sdk.setWalletPassword(pin, password);\n    await sdk.createWalletFromMnemonic(pin, mnemonic);\n\n    // Generate new receiver address and fetch current balance\n    let address = await sdk.generateNewAddress(pin);\n    console.log(\"Address:\", address);\n\n    let balance = await sdk.getWalletBalance(pin);\n    console.log(\"Balance:\", balance);\n\n    // Create new purchase request\n    let product_hash = \"2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824\";\n    let app_data = \"wasm send compliment example\";\n    let purchase_type = \"CLIK\";\n\n    let purchase_id = await sdk.createPurchaseRequest(\"satoshi\", 2, product_hash, app_data, purchase_type);\n    console.log(\"Purchase Request created: \", purchase_id);\n\n    // Wait 3 min while transaction status becomes `Valid`\n    console.log(\"Waiting until transaction status is `Valid`..\");\n    await Promise.race([\n        (async () =&gt; {\n            while (true) {\n                await sleep(5000);\n\n                let details = await sdk.getPurchaseDetails(purchase_id);\n                console.log(\"Details: \", details);\n\n                if (details.status == wasm.TxStatus.Valid) {\n                    console.log(\"Purchase request valid, moving on...\");\n                    return;\n                } else if (details.status == wasm.TxStatus.WaitingForVerification || details.status == wasm.TxStatus.Invalid) {\n                    throw new Error(\"Purchase request invalid. Reason: \" + details.invalid_reasons);\n                }\n            }\n        })(),\n        timeoutPromise\n    ]);\n\n    // When the transaction is Valid, confirm it\n    await sdk.confirmPurchaseRequest(pin, purchase_id);\n\n    // Wait 3 min while transaction status is `Complete`\n    console.log(\"Waiting until transaction status is `Complete`..\");\n    await Promise.race([\n        (async () =&gt; {\n            while (true) {\n                await sleep(5000);\n\n                let details = await sdk.getPurchaseDetails(purchase_id);\n                console.log(\"Details: \", details);\n\n                if (details.status == wasm.TxStatus.Completed) {\n                    console.log(\"Purchase request completed, done!\");\n                    return;\n                } else if (details.status == wasm.TxStatus.Failed) {\n                    throw new Error(\"Purchase request failed\");\n                }\n            }\n        })(),\n        timeoutPromise\n    ]);\n\n    // Get new balance after sending the compliment\n    let new_balance = await sdk.getWalletBalance(pin);\n    console.log(\"New Balance:\", new_balance);\n\n    // Forcefully exit the process to ensure it completes.\n    // The process may hang if there are pending operations or unresolved promises\n    // This ensures that the script terminates properly without delays\n    process.exit();\n}\n\nmain();\n</code></pre>"},{"location":"SDK%20Examples/Examples/#22-initialize-wallet-from-shares","title":"22. Initialize Wallet from Shares","text":"Rust <pre><code>use sdk::{ErrorKind, WalletError};\nuse testing::USER_SATOSHI;\nuse utils::init_sdk;\nmod utils;\n\n#[allow(clippy::unwrap_used, clippy::expect_used)]\n#[tokio::main]\nasync fn main() {\n    dotenvy::dotenv().ok();\n\n    // Initialize SDK\n    let (mut sdk, _cleanup) = init_sdk().await;\n    let user: utils::TestUser = (*USER_SATOSHI).clone().into();\n\n    // Create new user\n    sdk.create_new_user(&amp;user.username).await.unwrap();\n    sdk.init_user(&amp;user.username).await.unwrap();\n\n    // use wallet without creating a new one first\n    let output = sdk.generate_new_address(&amp;user.pin).await;\n\n    match output {\n        Ok(_address) =&gt; {\n            println!(\"Wallet initialized successfully\");\n        }\n\n        Err(sdk::Error::Wallet(WalletError::WalletNotInitialized(ErrorKind::MissingPassword))) =&gt; {\n            // Wallet requires a password, try again with the password provided\n            sdk.set_wallet_password(&amp;user.pin, &amp;user.password).await.unwrap();\n\n            let result = sdk.generate_new_address(&amp;user.pin).await;\n            if result.is_ok() {\n                println!(\"Wallet initialized successfully with password set\");\n            } else {\n                panic!(\"Unexpected result after providing password: {:?}\", result);\n            }\n        }\n\n        Err(sdk::Error::Wallet(WalletError::WalletNotInitialized(ErrorKind::SetRecoveryShare))) =&gt; {\n            // Ask user for recovery share\n            let share = \"&lt;User Input&gt;\".parse().unwrap();\n\n            sdk.set_recovery_share(share).await.unwrap();\n\n            let result = sdk.generate_new_address(&amp;user.pin).await;\n            if result.is_ok() {\n                println!(\"Wallet initialized successfully with recovery share\");\n            } else {\n                panic!(\"Unexpected result after setting recovery share: {:?}\", result);\n            }\n        }\n\n        Err(sdk::Error::Wallet(WalletError::WalletNotInitialized(ErrorKind::UseMnemonic))) =&gt; {\n            sdk.set_wallet_password(&amp;user.pin, &amp;user.password).await.unwrap();\n            sdk.create_wallet_from_existing_mnemonic(&amp;user.pin, &amp;user.mnemonic)\n                .await\n                .unwrap();\n\n            let result = sdk.generate_new_address(&amp;user.pin).await;\n            if result.is_ok() {\n                println!(\"Wallet initialized successfully from mnemonic\");\n            } else {\n                panic!(\"Unexpected result after creating wallet from mnemonic: {:?}\", result);\n            }\n        }\n        other =&gt; panic!(\"unexpected result: {other:?}\"),\n    }\n\n    // Ensure the wallet is functioning\n    let address = sdk.generate_new_address(&amp;user.pin).await.unwrap();\n    let balance = sdk.get_balance(&amp;user.pin).await.unwrap();\n    println!(\"New address : {address} , Wallet balance: , {balance:?}\");\n}\n</code></pre>"},{"location":"SDK%20Modules/Managing%20user/","title":"User management","text":"<p>The SDK is designed to allow multiple users working with their own wallets on the same end devices sharing the same storage space. This makes it easy for a single person to have multiple alias users for different purposes and use different wallets for each of them to have a clear separation of risks.</p> <p>The user initialization is done by two main operations in the SDK.</p> <p>Creating a new user : This creates a new user in the in-memory database. All the properties of the user, like his selected KYC process, his KYC status, his access token for the backend, pin, encrypted password, etc... are set with the default values. A salt is generated for the user, which will be used later for encrypting the password.</p> <p>Initializing a user : This function initializes the user for a new session. It also checks that a valid access token has been provided by updating the KYC status of the user from the backend in the SDK internal state.</p>"},{"location":"SDK%20Modules/Managing%20user/#creating-a-new-user","title":"Creating a new user","text":"<p>User creation in the SDK is compulsory. This user is only a local user which might be already existing in the identity management provider.  </p> Note <p>The user might already exist in the OAuth system, as well as every where else, including Cawaena backend. However, the SDK associates the local user to the system user only when an access token is provided.</p> <p>The SDK supports multi-user environments and switching between users is fairly simple. Creating a user in the SDK informs the SDK about the user and allows the SDK to manage the user's state locally, whilst syncing it with the backend periodically.</p> <p>This allows the SDK to be used across multiple devices, and ideally on the same device, on multiple storage path prefixes. This means, that changing the storage path prefix would result in the SDK unknowing the existence of the user and would require to create the user once again.</p> <p>Creating a new user can be done using the <code>create_new_user</code> function which takes the <code>username</code> input parameter. Before creating a user, it is important that at least the storage path is set in the SDK.</p> <p>The <code>username</code> should always match the <code>preferred_username</code> claim on the JWT <code>access_token</code>, otherwise the SDK would not be able to access the backend services for that user. Through this, the newly created SDK local user gets recognized in the system as a valid user.</p> Tip <p>The application can extract the <code>preferred_username</code> information automatically from the JWT claim and set the username directly, instead of asking the user to enter the input. A user might mistype or misunderstand and enter a username which might later not work. This would lead to a bad end-user experience and should be avoided.</p> <p>Note</p> <p>The code snippets provided are intended as pseudo-code to demonstrate logic and workflows. They are not guaranteed to compile, execute, or function as-is. Users should adapt and validate them according to their specific requirements and development environment.</p> RustJavaSwiftTypescript <pre><code>async fn main() {\n    let mut sdk = Sdk::default();\n    sdk.set_config(...).unwrap();\n\n    sdk.create_new_user(\"username\").await.unwrap();\n}\n</code></pre> <pre><code>package org.example.app;\nimport com.cawaena.Wallet;\n\npublic class app {\n    public static void main(){\n        Wallet sdk = new Wallet();\n\n        try {\n            sdk.setConfig(\"...\");\n            sdk.createNewUser(\"username\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre> <pre><code>import Foundation\nimport CawaenaSdk\n\nlet sdk = CawaenaSdk()\ntry await sdk.setConfig(config: \"...\")\n\ndo {\n    try await sdk.createNewUser(username: \"username\")\n} catch {\n    print(error.localizedDescription)\n}\n</code></pre> <pre><code>import * as wasm from \"../pkg/cryptpay_sdk_wasm\";\n\nconst sdk = await new CawaenaSdk();\nawait sdk.setConfig(\"...\")\n\nawait sdk.createNewUser(\"username\");\n</code></pre>"},{"location":"SDK%20Modules/Managing%20user/#initializing-a-user-and-access-token-refresh","title":"Initializing a user and access token refresh","text":"<p>The user is created and needs to be initialized before any state updates or wallet-related operations can be performed for this user. This allows the SDK to create multiple users and by using the initializing function, only the selected user is activated for the session. Without initializing a user, all operations related to the user would fail or conversely the previously initialized user's session will be used and might corrupt the state! To protect this from happening, before initializing the user, a corresponding access token is required. An invalid access token would result in failure of the initialization.</p> <p>The access token brings the following safe operations for the SDK:</p> <ol> <li>Only the correct user with the username would be initialized. Mismatch would cause an error.</li> <li>The application can only initialize a user, only after the authorization of the actual person, since they would need to share their credentials for creating an access token.</li> <li>Any user whose rights have been revoked, due to misuse reports, would not be able to use the system as the access token would be invalid and generating a new one would not also work.</li> </ol> <p>Warning</p> <p>The user management is local to the end devices and deleting the application data, cache, temporary data files, etc... or changing the storage path prefix in the configuration would result in a loss of state and that would require the application to re-create and re-initialize user.</p> RustJavaSwiftTypescript <pre><code>async fn main() {\n    let mut sdk = Sdk::default();\n    sdk.set_config(...).unwrap();\n\n    sdk.create_new_user(\"username\").await.unwrap();\n\n    sdk.refresh_access_token(\"access_token\").await.unwrap();\n    sdk.init_user(\"username\").await.unwrap();\n\n    // other SDK functions now use the initialized user\n}\n</code></pre> <pre><code>package org.example.app;\nimport com.cawaena.Wallet;\n\npublic class app {\n    public static void main(){\n        Wallet sdk = new Wallet();\n\n        try {\n            sdk.setConfig(\"...\");\n            sdk.createNewUser(\"username\");\n            sdk.refreshAccessToken(\"accessToken\");\n            sdk.initializeUser(\"username\");\n            // other SDK functions now use the initialized user\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre> <pre><code>import Foundation\nimport CawaenaSdk\n\nlet sdk = CawaenaSdk()\ntry await sdk.setConfig(config: \"...\")\n\ndo {\n    try await sdk.createNewUser(username: \"username\")\n    try await sdk.refreshAccessToken(access_token: \"access_token\")\n    try await sdk.initUser(username: \"username\")\n    // other SDK functions now use the initialized user\n} catch {\n    print(error.localizedDescription)\n}\n</code></pre> <pre><code>import * as wasm from \"../pkg/cryptpay_sdk_wasm\";\n\nconst sdk = await new CawaenaSdk();\nawait sdk.setConfig(\"...\")\n\nawait sdk.createNewUser(\"username\");\nawait sdk.refreshAccessToken(\"access_token\");\nawait sdk.initializeUser(\"username\");\n// other SDK functions now use the initialized user\n</code></pre>"},{"location":"SDK%20Modules/Managing%20user/#deleting-a-user","title":"Deleting a user","text":"<p>Deleting the user is simply deleting the user entity from the local database, while maintaining entries for other users. The delete user also calls the backend API to trigger an archiving action for the user. Deleting the user also deletes all the local data files for the user, which in this case are files related to the wallet. Since, this is a one-way operation a user is required to enter the pin, that they have set for the wallet. If there is no wallet setup, the pin can be skipped and the user is simply deleted locally and archived in the backend.</p> <p>Danger</p> <p>Deleting a user not only deletes the user in the system but also deletes all local files and information from the device. This means, that the wallet is also deleted. Hence, a pin is used to verify if the user wishes to delete all this information. Deletion of a wallet without having a backup file or without the mnemonic is extremely dangerous as it can potentially lead to permanent loss of funds.</p> RustJavaSwiftTypescript <pre><code>async fn main() {\n    let mut sdk = Sdk::default();\n    sdk.set_config(...).unwrap();\n\n    sdk.create_new_user(\"username\").await.unwrap();\n    sdk.refresh_access_token(\"access_token\").await.unwrap();\n    sdk.init_user(\"username\").await.unwrap();\n\n    let pin = \"1234\"; \n    // only if wallet was created by the user, a pin value is required.\n    // otherwise, it is None.\n    sdk.delete_user(Some(pin)).await.unwrap();\n}\n</code></pre> <pre><code>package org.example.app;\nimport com.cawaena.Wallet;\n\npublic class app {\n    public static void main(){\n        Wallet sdk = new Wallet();\n\n        try {\n            sdk.setConfig(\"...\");\n            sdk.createNewUser(\"username\");\n\n            sdk.refreshAccessToken(\"accessToken\");\n            sdk.initializeUser(\"username\");\n\n            String pin = \"1234\"; \n            // only if wallet was created by the user, a pin value is required.\n            // otherwise, it is null.\n            sdk.deleteUser(pin)\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre> <pre><code>import Foundation\nimport CawaenaSdk\n\nlet sdk = CawaenaSdk()\ntry await sdk.setConfig(config: \"...\")\n\ndo {\n    try await sdk.createNewUser(username: \"username\")\n\n    try await sdk.refreshAccessToken(access_token: \"access_token\")\n    try await sdk.initUser(username: \"username\")\n\n    let pin = \"1234\"; \n    // only if wallet was created by the user, a pin value is required.\n    // otherwise, it is nil.\n    try await sdk.deleteUser(pin: pin)\n} catch {\n    print(error.localizedDescription)\n}\n</code></pre> <pre><code>import * as wasm from \"../pkg/cryptpay_sdk_wasm\";\n\nconst sdk = await new CawaenaSdk();\nawait sdk.setConfig(\"...\")\n\nawait sdk.createNewUser(\"username\");\nawait sdk.refreshAccessToken(\"access_token\");\nawait sdk.initializeUser(\"username\");\n\nlet pin = \"1234\"; \n// only if wallet was created by the user, a pin value is required.\n// otherwise, it is null.\nawait sdk.deleteUser(pin);\n</code></pre>"},{"location":"SDK%20Modules/Managing%20user/#user-lifecycle-overview","title":"User lifecycle overview","text":"<pre><code>      Username    Refresh access   Username              Pin              \n         |            token          |                      |             \n         |             |             |                      |             \n         |             |             |                      |             \n         |             |             |                      |             \n    +----v---------+   |     +-------v------+        +------v---------+   \n    |              |   |     |              |        |                |   \n    |  Create      |   |     | Initialize   |        |     Delete     |   \n    |  new         +---v-----&gt; User         +--------&gt;     User       |   \n    |  User        |         |              |        |                |   \n    +--------------+         +-----+--------+        +----------------+   \nOnce                                |\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nMultiple                            |\nTimes                   +-----------v-----------------+\n                        |  User           Wallet      |\n                        |  State          Operations  |\n                        |  Change                     |\n                        +-----------------------------+\n</code></pre>"},{"location":"SDK%20Modules/Managing%20wallet/","title":"Wallet management","text":"<p>The SDK provides users with the opportunity to host their own wallets on their personal end-devices in a safe and easy manner. Before discussing wallet management, some information on wallets and what they are is needed to understand how to manage non-custodial hot wallets.</p>"},{"location":"SDK%20Modules/Managing%20wallet/#the-iota-wallet","title":"The IOTA wallet","text":"<p>The wallet used within the SDK is the official wallet developed by the IOTA Foundation and maintained in its own SDK found here. The wallet internally uses the stronghold secret management engine also developed by the IOTA Foundation found here. The secret management engine not only stores sensitive data in files but also uses obfuscation and mechanisms against memory dumps to protect the secrets while they are being operated upon in the memory. Stronghold also provides functions for BIP-0032 derivation using the BIP-0044 derivation path mechanism described here. The word list used by the wallet is the word list described in BIP-0039 here.</p> <p>The various coin types supported by BIP-0044 can be found in the list here. Both <code>IOTA</code> and <code>SMR</code> are supported and have the coin types <code>4218</code> and <code>4219</code> respectively.</p> <p>Currently, in its base implementation the IOTA SDK also needs an in-memory key-value store to manage some metadata related to the stronghold engine and other wallet settings. The IOTA SDK uses a rocksdb implementation in rust for this purpose. There are a few noteworthy problems with rocksdb:</p> <ul> <li>rocksdb is not light-weight for mobile end devices and the resulting binaries of the sdk take long to build and are bigger in storage requirements.</li> <li>rocksdb does not support all mobile platforms</li> <li>rocksdb is not maintained on the latest sdks of the android and iOS mobile platforms</li> </ul> <p>After investigation, it was found that the in-memory key-value store was used only for storing some metadata keys and not necessarily need high-performance query execution. Luckily, the IOTA SDK implemented the rocksdb connection as a <code>Storage</code> trait. Since, the SDK already used jammdb for its internal key-value store, a fork was created and the trait was implemented using <code>jammdb</code>. A pull request was created to the upstream, but the dev team at IOTA Foundation recommended to maintain the fork for now, as there would be some new breaking changes coming and the pull request can be created at a later point. The fork is updated regularly and maintained here.</p>"},{"location":"SDK%20Modules/Managing%20wallet/#hot-wallets-the-swift-side-of-crypto","title":"Hot Wallets: The Swift Side of Crypto","text":"<p>Picture a hot wallet as the bustling city centre of your digital finances. Hot wallets are online, connected to the internet, and readily available for transactions. They provide users with quick access to their cryptocurrencies, making them ideal for active trading and daily transactions. Think of them as your go-to pocket wallet for everyday spending in the digital realm.</p> <p>However, convenience comes at a cost. The very connectivity that makes hot wallets user-friendly also renders them more vulnerable to cyber threats. Hacking attempts and online attacks pose a constant risk, making it crucial for users to exercise caution and implement additional security measures when relying on hot wallets.</p>"},{"location":"SDK%20Modules/Managing%20wallet/#pin-and-password-in-the-sdk","title":"Pin and password in the SDK","text":"<p>Generally, the password requirements for any application need to meet today's standards. This might become difficult for the user to remember their wallet stronghold password and also an irritating experience to enter it every time even for the smallest of transactions. On the other side, for a secure wallet application, the SDK should not rely on the interfacing application to do password management for a secret manager used internally. This has a lot of side effects, such as, the application might bypass the SDK logic for protecting access to the secret by simply using the password against the file, with no knowledge of the SDK. This is a security risk and cannot be accepted.</p> <p>The end devices today support pin entry mostly protected by biometric authentication for ease but secure user experience, when it comes to accessing a restricted OS functionality. Taking all this in account, the SDK was designed to provide the end users possibilities to set up their wallet using a <code>password</code> and a <code>pin</code>.</p> <ul> <li> <p>The password stays with the SDK in an encrypted form and only the pin can be used to decrypt it. Thus, for every operation with the secret manager, where a password is needed, the user must only enter the pin. This solves the problem of user experience.</p> </li> <li> <p>The issue of password management is also solved, since now the SDK internally manages the password, while still relying completely on the user to unblock it using the pin. The SDK cannot act in its own interest even if there was a malicious code trying to unblock the wallet! The probability distribution of the pin, being relatively weak, (4 to 6 digit), is improved through the addition of a pseudo random salt, which in combination with a hash function results in an encryption password of significant strength and quasi-random probability distribution. This is used then to encrypt the password for the secret manager.</p> </li> </ul> <p>Thus an attacker would need information on the salt, the encrypted password, pin and the stronghold file to be able to gain access to the wallet functions. This is tough and would need somehow physical access to the end device, and to the end user. Security of end-user and their devices is out of the scope for Cawaena ecosystem.</p>"},{"location":"SDK%20Modules/Managing%20wallet/#creating-the-wallet","title":"Creating the wallet","text":"<p>The stronghold secret manager requires a file path for the wallet and a password to unlock this file. This password disables other applications from interpreting the files created by the stronghold engine and needs to come from the user.</p> <p>The IOTA SDK offers an account manager structure which comprises of various fields to work with the wallet and the internal wallet accounts. The SDK creates a standard account <code>standalone</code> for its usage. There might be other accounts that could exist and are not operated upon by the SDK. The following ways can be used to create a wallet in the SDK:</p>"},{"location":"SDK%20Modules/Managing%20wallet/#create-a-new-wallet","title":"Create a new wallet","text":"<p>This does not require any user input except <code>username</code>,  <code>password</code> and <code>pin</code>. But, this should be a multi-step process. The created wallet returns a mnemonic. The app should immediately delete the wallet. In the second step the migration of the wallet with the mnemonic should be carried out and the wallet is only loaded with the mnemonic entered by the user. This approach protects the user against creating a wallet without never confirming the mnemonic back to the SDK and also by deleting a wallet, the SDK can ensure that there is actually no wallet created whose mnemonic was never entered from outside the application. This forces applications to have their end-users the mnemonic either memorized or input from a copy.</p> Info <p>A fresh wallet can be created by a random seed, using the stronghold secret manager. It needs the password and username. The username is part of the file path and helps distinguish across different user wallets on the same end device. It returns the mnemonic, and this needs to be securely stored by the user, otherwise access to the funds on the wallet addresses would get limited. A node url for the DLT network can also be selected. Currently, the PoW is set to local, however it might change based on the used node url and its support for PoW.</p> <p>Note</p> <p>The code snippets provided are intended as pseudo-code to demonstrate logic and workflows. They are not guaranteed to compile, execute, or function as-is. Users should adapt and validate them according to their specific requirements and development environment.</p> RustJavaSwiftTypescript <pre><code>async fn main() {\n    let mut sdk = Sdk::default();\n    sdk.set_config(...).unwrap();\n\n    // Generate access token\n    // Create and initialize the user\n\n    let mnemonic = sdk.create_new_wallet(\"pin\", \"password\").await.unwrap();\n    sdk.verify_mnemonic(\"pin\", \"password\", &amp;mnemonic).await.unwrap();\n}\n</code></pre> <pre><code>package org.example.app;\nimport com.cawaena.Wallet;\n\npublic class app {\n    public static void main(){\n        Wallet sdk = new Wallet();\n        sdk.setConfig(\"...\");\n\n        // Generate access token\n        // Create and initialize the user\n\n        try {\n            String mnemonic = sdk.createNewWallet(\"pin\", \"password\");\n            sdk.verifyMnemonic(\"pin\", \"password\", mnemonic); \n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre> <pre><code>import CawaenaSdk\nimport Foundation\n\nlet sdk = CawaenaSdk()\ntry await sdk.setConfig(config: \"...\")\n\n// Generate access token\n// Create and initialize the user\n\ndo {\n    mnemonic = try await sdk.createNewWallet(pin: \"pin\", password: \"password\")\n    try await sdk.verifyMnemonic(pin: \"pin\", password: \"password\", mnemonic: mnemonic)\n} catch {\n    print(error.localizedDescription)\n}\n</code></pre> <pre><code>import * as wasm from \"../pkg/cryptpay_sdk_wasm\";\n\nconst sdk = await new CawaenaSdk();\nawait sdk.setConfig(\"...\")\n\n// Generate access token\n// Create and initialize the user\n\nawait sdk.setWalletPassword(\"pin\", \"password\");\nlet mnemonic = await sdk.createNewWallet(\"pin\");\nawait sdk.verifyMnemonic(\"pin\", mnemonic)\n</code></pre>"},{"location":"SDK%20Modules/Managing%20wallet/#migrate-an-existing-wallet","title":"Migrate an existing wallet","text":"<p>This just performs the second step of the create fresh wallet process and needs in addition to the <code>mnemonic</code> also the <code>username</code>, <code>password</code> and <code>pin</code>.</p> RustJavaSwiftTypescript <pre><code>async fn main() {\n    let mut sdk = Sdk::default();\n    sdk.set_config(...).unwrap();\n\n    // Generate access token\n    // Create and initialize the user\n\n    sdk.create_wallet_from_mnemonic(\"pin\", \"password\", \"mnemonic\").await.unwrap();\n}\n</code></pre> <pre><code>package org.example.app;\nimport com.cawaena.Wallet;\n\npublic class app {\n    public static void main(){\n        Wallet sdk = new Wallet();\n        sdk.setConfig(\"...\");\n\n        // Generate access token\n        // Create and initialize the user\n\n        try {\n            sdk.createWalletFromMnemonic(\"pin\", \"password\", \"mnemonic\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre> <pre><code>import CawaenaSdk\nimport Foundation\n\nlet sdk = CawaenaSdk()\ntry await sdk.setConfig(config: \"...\")\n\n// Generate access token\n// Create and initialize the user\n\ndo {\n    try await sdk.createWalletFromMnemonic(pin: \"pin\", password: \"password\", mnemonic: \"mnemonic\")\n} catch {\n    print(error.localizedDescription)\n}\n</code></pre> <pre><code>import * as wasm from \"../pkg/cryptpay_sdk_wasm\";\n\nconst sdk = await new CawaenaSdk();\nawait sdk.setConfig(\"...\")\n\n// Generate access token\n// Create and initialize the user\n\nawait sdk.setWalletPassword(\"pin\", \"password\");\nawait sdk.createWalletFromMnemonic(\"pin\", \"mnemonic\");\n</code></pre>"},{"location":"SDK%20Modules/Managing%20wallet/#create-wallet-from-a-backup-file","title":"Create wallet from a backup file","text":"<p>The SDK provides functionality to create a backup file in <code>kdbx</code> format as a byte array. Backups can only be created if a wallet exists.</p> <p>To create the backup, the following are required:</p> <ul> <li><code>pin</code>: This is the same PIN that was set for the wallet.</li> <li><code>backup_password</code>: A new, separate password set specifically for securing the backup file. This is not the same password used for the wallet.</li> </ul> <p>To restore the backup, the following are required:</p> <ul> <li>The kdbx <code>backup bytes</code>.</li> <li>A <code>new pin</code> used to create the new wallet.</li> <li>The <code>backup_password</code> used during the backup process.</li> </ul> RustJavaSwiftTypescript <pre><code>async fn main() {\n    let mut sdk = Sdk::default();\n    sdk.set_config(...).unwrap();\n\n    // Generate access token\n    // Create and initialize the user\n\n    let backup_bytes: Vec&lt;u8&gt; = sdk.create_wallet_backup(\"pin\", \"backup_password\").await.unwrap();\n    sdk.create_wallet_from_backup(\"new pin\", &amp;backup_bytes, \"backup_password\").await.unwrap();\n}\n</code></pre> <pre><code>package org.example.app;\nimport com.cawaena.Wallet;\n\npublic class app {\n    public static void main(){\n        Wallet sdk = new Wallet();\n        sdk.setConfig(\"...\");\n\n        // Generate access token\n        // Create and initialize the user\n\n        try {\n            byte[] backup_bytes = sdk.createWalletBackup(\"pin\", \"backup_password\");\n            sdk.createWalletFromBackup(\"new pin\", backup_bytes, \"backup_password\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre> <pre><code>import CawaenaSdk\nimport Foundation\n\nlet sdk = CawaenaSdk()\ntry await sdk.setConfig(config: \"...\")\n\n// Generate access token\n// Create and initialize the user\n\ndo {\n    let backup_bytes = try await sdk.createWalletBackup(pin: \"pin\", password: \"backup_path\")\n    try await sdk.restoreWalletFromBackup(pin: \"new pin\", backup: backup_bytes, backup_password: \"backup_password\")\n} catch {\n    print(error.localizedDescription)\n}\n</code></pre> <pre><code>import * as wasm from \"../pkg/cryptpay_sdk_wasm\";\n\nconst sdk = await new CawaenaSdk();\nawait sdk.setConfig(\"...\")\n\n// Generate access token\n// Create and initialize the user\n\nlet backup_bytes = await sdk.createWalletBackup(\"pin\", \"backup_password\");\nawait sdk.createWalletFromBackup(\"new pin\", backup_bytes, \"backup_password\");\n</code></pre>"},{"location":"SDK%20Modules/Managing%20wallet/#deleting-the-wallet","title":"Deleting the wallet","text":"<p>This function just deletes the wallet files and is a one-way function, to be used under extreme caution, as it could result in permanent loss of funds. Note that, similar to any other wallet operation, deleting the wallet is also a wallet operation and requires the wallet to be correctly initialized. Without initialization, the deletion of wallet would fail.</p> RustJavaSwiftTypescript <pre><code>async fn main() {\n    let mut sdk = Sdk::default();\n    sdk.set_config(...).unwrap();\n\n    // Generate access token\n    // Create and initialize new user\n    // Create a new wallet\n\n    sdk.delete_wallet();\n}\n</code></pre> <pre><code>package org.example.app;\nimport com.cawaena.Wallet;\n\npublic class app {\n    public static void main(){\n        Wallet sdk = new Wallet();\n        sdk.setConfig(\"...\");\n\n        // Generate access token\n        // Create and initialize new user\n        // Create a new wallet\n\n        try {\n            sdk.deleteWallet();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre> <pre><code>import CawaenaSdk\nimport Foundation\n\nlet sdk = CawaenaSdk()\ntry await sdk.setConfig(config: \"...\")\n\n// Generate access token\n// Create and initialize new user\n// Create a new wallet\n\ndo {\n    try await sdk.deleteWallet()\n} catch {\n    print(error.localizedDescription)\n}\n</code></pre> <pre><code>import * as wasm from \"../pkg/cryptpay_sdk_wasm\";\n\nconst sdk = await new CawaenaSdk();\nawait sdk.setConfig(\"...\")\n\n// Generate access token\n// Create and initialize the user\n// Create a new wallet\n\nawait sdk.deleteWallet(\"pin\")\n</code></pre>"},{"location":"SDK%20Modules/Managing%20wallet/#password-and-pin-utilities","title":"Password and pin utilities","text":"<p>In addition to creating, migrating, backups and initialization, the wallet module also performs auxiliary operations for pin and password management. It supports function to reset the pin using password, verify the pin, or change the wallet password using the current password and pin. Wallet initialization is again a pre-requisite, since the pin and password operations are related to the wallet and can only be performed once a wallet is initialized successfully.</p> RustJavaSwiftTypescript <pre><code>async fn main() {\n    let mut sdk = Sdk::default();\n    sdk.set_config(...).unwrap();\n\n    // Generate access token\n    // Create and initialize new user\n    // Create a new wallet\n\n    // Try to verify the pin\n    sdk.verify_pin(\"pin\");\n    // or reset the pin to a new one\n    sdk.reset_pin(\"password\", \"new_pin\")\n    // or change the password\n    sdk.change_password(\"pin\", \"password\", \"new_password\");\n}\n</code></pre> <pre><code>package org.example.app;\nimport com.cawaena.Wallet;\n\npublic class app {\n    public static void main(){\n        Wallet sdk = new Wallet();\n        sdk.setConfig(\"...\");\n\n        // Generate access token\n        // Create and initialize new user\n        // Create a new wallet\n\n        try {\n            // Try to verify the pin\n            sdk.pinVerify(\"pin\");\n            // or reset the pin to a new one\n            sdk.pinReset(\"password\", \"new_pin\");\n            // or change the password\n            sdk.passwordChange(\"pin\", \"password\", \"new_password\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre> <pre><code>import CawaenaSdk\nimport Foundation\n\nlet sdk = CawaenaSdk()\ntry await sdk.setConfig(config: \"...\")\n\n// Generate access token\n// Create and initialize new user\n// Create a new wallet\n\ndo {\n    // Try to verify the pin\n    try await sdk.verifyPin(pin: \"pin\")\n    // or reset the pin to a new one\n    try await sdk.resetPin(password: \"password\", new_pin: \"new_pin\")\n    // or change the password\n    try await sdk.changePassword(pin: \"pin\", current_password: \"password\", new_password: \"new_password\")\n} catch {\n    print(error.localizedDescription)\n}\n</code></pre> <pre><code>import * as wasm from \"../pkg/cryptpay_sdk_wasm\";\n\nconst sdk = await new CawaenaSdk();\nawait sdk.setConfig(\"...\")\n\n// Generate access token\n// Create and initialize the user\n// Create a new wallet\n\n// Try to verify the pin\nawait sdk.verifyPin(\"pin\");\n// or reset the pin to a new one\nawait sdk.resetPin(\"pin\", \"new_pin\");\n// or change the password\nawait sdk.setWalletPassword(\"pin\", \"new_password\");\n</code></pre>"},{"location":"SDK%20Modules/Managing%20wallet/#wallet-flows","title":"Wallet flows","text":"<pre><code>                Mnemonic  Username  Password  Pin  backup password         Pin                            Pin        \n                   | ^         |      |       |      |                     |                              |          \n                   | |         |      |       |      |                     |                              |          \n                   | |         |      |       |      |                     |                              |          \n                   | |         |      |       |      |                     |                              |          \n                   | |         |      |       |      |                     |                              |          \n                   | |         |      |       |      |                     |                              |          \n                   | |         |      |       |      |                     |                              |          \n    Inputs         v |         v      v       v      v                     v                              v          \n-------------------------------------------------------------------------------------------------------------------  \n                                                                |                           |                        \n                                           +-------------+      |                           |                        \n                                           |             |      |                           |                        \n                                           | Create      |      |      +-------------+      |                        \n                                           | New         +---+  |      |             |      |        +--------------+\n                                           | Wallet      |   |  |      |  Initialize |      |        |              |\n                                           |             |   |  |      |  Wallet     +------+--------&gt;   Delete     |\n                                           +-------------+   |  +------&gt;             |      |        |   wallet     |\n                                                             |  |      |             |      |        |   (external) |\n                                                             |  |      +------+------+      |        |              |\n                         +----------+      +-------------+   |  |             |             |        +--------------+\n                         |          |      |             |   |  |             |             |                        \n                         | Mnemonic |      | Migrate     |   |  |             |             |                        \n                 +-------&gt;          +------&gt; Existing    |   |  |             |             |                        \n                 |       |          |      | Wallet      |   |  |      +------v------+      |                        \n                 |       |          |      |             |   |  |      |             |      |                        \n                 |       +----------+      +-------------+   |  |      |  User       |      |                        \n                 |                                           |  |      |  Wallet     |      |                        \n                 |                                           |  |      |  Functions  |      |                        \n                 |           +------+      +-------------+   |  |      |             |      |                        \n                 |           |      |      |             |   |  |      +-------------+      |                        \n                 |           |Backup|      | Create      |   |  |                           |                        \n                 |           | File +------&gt; Wallet      |   |  |                           |                        \n                 |           |      |      | From        |   |  |                           |                        \n                 |           |      |      | Backup      |   |  |                           |                        \n                 |           +------+      +-------------+   |  |                           |                        \n                 |                                           |  |                           |                        \n                 |                                           |  |                           |                        \n                 |    +-------------+      +-------------+   |  |                           |                        \n                 |    |             |      |             |   |  |                           |                        \n                 |    | Verify      |      |  Delete     |   |  |                           |                        \n                 +----+ Mnemonic    &lt;------+  wallet     &lt;---+  |                           |                        \n                      |             |      | (internal)  |      |                           |                        \n                      |             |      |             |      |                           |                        \n                      +-------------+      +-------------+      |                           |                        \n                                                                |                           |                        \n                                                                |                           |                        \n                                             Once(setup)        |        Multiple times     |       Once (tear down) \n                                                                |                           |                        \n</code></pre>"},{"location":"SDK%20Modules/Transactions_Swaps_Purchases/","title":"Transactions, Swaps and Purchases","text":"<p>The SDK is primarily used to perform transactions. The type of transactions that the SDK currently facilitates are</p> <ol> <li>Wallet transactions</li> <li>Swap transactions</li> <li>Purchase transactions</li> </ol>"},{"location":"SDK%20Modules/Transactions_Swaps_Purchases/#wallet-transactions-flow","title":"Wallet transactions flow","text":"<pre><code>+---------------+                      +---------------+\n|               |                      |               |\n|               |                      | Wallet        |\n| Wallet        +----------------------&gt; Address       |\n| Address       |                      | Receiver      |\n| Sender        |                      |               |\n+---------------+                      +---------------+\n</code></pre> <p>The wallet transaction is a simple transfer of funds from one address to another facilitated by the DLT network node and the wallet software running within the SDK.</p>"},{"location":"SDK%20Modules/Transactions_Swaps_Purchases/#swap-transactions-flow","title":"Swap transactions flow","text":"<p>A swap is simply an exchange of value from one currency to another. In the current scenario, the swap is always between SMR &lt;--&gt; EURO currencies. This is executed at viviswap exchange.</p> <p>For payments in EURO, only the SEPA transfer method is currently supported. See the german explanation here and the english explanation here</p> <p>The EURO payment needs the user to setup and add their IBAN (International Bank Account Number) to the viviswap exchange. Through this, the viviswap uses SEPA transfers to this IBAN, whenever a swap is triggered from SMR to EURO. The other way around, currently, since direct debit is not setup from the bank of viviswap, the user has to transfer manually from exactly this IBAN (viviswap verifies it in every transfer) to the IBAN owned by viviswap with the amount and a reference number provided by viviswap.</p> <ol> <li><code>get_iban_for_viviswap</code>: This function allows the user query their own IBAN saved at viviswap.</li> <li><code>ensure_detail</code>: This function verifies if a detail created at viviswap is legitimate, syntactically and semantically. A detail is basically an address for a particular payment method. The various payment methods used by viviswap are SMR, IOTA, BTC, ETH, etc... for crypto-currencies and PAYPAL, SEPA, etc... for EURO payments. For example, the address for the payment method SMR would be shimmer wallet address and the address for the payment method SEPA would be the IBAN.</li> <li><code>update_iban_for_viviswap</code>: This function updates the IBAN of the user in the viviswap exchange. The update is actually an advanced <code>upsert</code> action. The update would insert the IBAN if none exists and also replace the existing IBAN with the new one.</li> <li><code>create_deposit_with_viviswap</code>: This function creates details of a fiat to crypto swap. Deposit is to be understood as deposit of funds to a crypto currency address. Currently, the swap is between EURO to SMR. Since, there is no direct debit authorization available, creating the deposit generally means getting information about the bank details of viviswap and the reference number, and advising the user to make a SEPA transfer in the required amount.</li> <li><code>create_detail_for_viviswap</code>: This function creates a user detail for a payment method. This could be adding the crypto address for a certain payment method to the viviswap exchange. This detail with its id can then be directly used for the swaps.</li> <li><code>get_payment_method_id_viviswap</code>: This is a generic function and has to be called once to cache the UUIDs of all the payment methods supported by viviswap.</li> <li><code>create_withdrawal_with_viviswap</code>: This function is the opposite of deposit. Withdrawal is to be understood as withdrawal of funds from a crypto currency address. If a pin is provided, the function automatically immediately transfers money from the crypto address of the user to that of viviswap and ideally viviswap would automatically transfer the funds to the IBAN created in their system. If no pin is provided, the user is shown the crypto address of the chosen payment method and the user can decide to transfer the funds to this address at any point.</li> <li><code>get_swap_list</code>: This function gives the list of swaps performed at viviswap.</li> <li><code>get_swap_details</code>: This function gives details about a swap, like information on fees, exchange rate, the swap status, etc...</li> <li><code>get_exchange_rate</code>: This function provides the exchange rate for the involved currencies in the swap. Currently, the exchange rate is always provided with EURO as base currency, i.e. it is either SMR/EURO or IOTA/EUR or BTC/EURO and so on... An inversion of the exchange rate gives the reverse rate and should be calculated by simply inverting the value. As confirmed by viviswap, there are no vertical spreads to be considered here!</li> </ol> <pre><code>                              Deposit Flow                        \n\n\n            +------------+            |          +------------+   \n            |            |            |          |            |   \n            | User       |            |          | Viviswap   |   \n            | Wallet     &lt;------------+----------+ Wallet     |   \n            | Address    |            |          | Address    |   \n            |            |            |          |            |   \n            +------------+            |          +------^-----+   \n                                      |                 |         \n                                      |                 |         \n                                      |                 |         \n                                      |                 |Trigger  \n                                      |                 |         \n                                      |                 |         \n                                      |                 |         \n            +------------+            |            +----+-------+ \n            |            |            |            |            | \nUser        | User       |     Bank   |            |  Viviswap  | \n------------&gt; IBAN       +------------+------------&gt;  IBAN      | \nAction      |            |     Ref.   |            |            | \n            |            |     Nr.    |            |            | \n            +------^-----+            |            +------------+ \n                   |                  |                           \n                   |                  |                           \n                   |                  |                           \n                   |                  |                           \n                   |                  |                           \n                   |                  |             +------------+\n                   +------------------+-------------+            |\n                                      |             |  Create    |\n           Update  -------------------+-------------&gt;  Deposit   |\n           User           Payment     |             |  Detail    |\n           IBAN           Detail      |             |            |\n                                      |             +------------+\n                                      |                           \n                                      |                           \n                              User    |    Viviswap               \n</code></pre> <pre><code>                 Withdraw Flow                       \n\n                                   +------------+    \n                                   |            |    \n  User                    |        |  Create    |    \n  ------------------------+--------&gt;  Withdraw  |    \n  Action                  |        |  Detail    |    \n              Viviswap    |        |            |    \n      +-------------------+--------+------------+    \n      |       Address     |                          \n      |                   |                          \n+-----v------+            |          +------------+  \n|            |            |          |            |  \n| User       |            |          | Viviswap   |  \n| Wallet     +------------+----------&gt; Wallet     |  \n| Address    |            |          | Address    |  \n|            |            |          |            |  \n+------------+            |          +------+-----+  \n                          |                 |        \n                          |                 |        \n                          |                 |        \n                          |                 |Trigger \n                          |                 |        \n                          |                 |        \n                          |                 |        \n+------------+            |            +----v-------+\n|            |            |            |            |\n| User       |            |            |  Viviswap  |\n| IBAN       &lt;------------+------------+  IBAN      |\n|            |            |            |            |\n|            |            |            |            |\n+------------+            |            +------------+\n                          |                          \n                          |                          \n                          |                          \n                  User    |    Viviswap              \n</code></pre>"},{"location":"SDK%20Modules/Transactions_Swaps_Purchases/#purchase-transactions-flow","title":"Purchase transactions flow","text":"<p>The purchase transaction is a process different than a swap or a wallet transaction. The purchase is a process of exchanging funds for an underlying artefact. An artefact can be something promised between two parties like a photo, video, or a compliment on a photo, sensor data, services, licenses, etc... The SDK is only interested in creation, querying and confirmation of these purchase requests. The rest of the business logic flow is handled by the corresponding service in Cawaena infrastructure. The transfer of artefact can happen only after a successful execution of the purchase request. This information can be verified at all times by querying the status of the purchase request and the details of the purchase request.</p> <p>A purchase request can be created at any time and is unique per purchase. A purchase id is returned by the infrastructure to track this particular request. Currently, polling is used to wait for the purchase request to be valid. It can be invalid for multiple reasons, as defined in the infrastructure. In case the request turns out to be valid, then the details (supplemented by the infrastructure) are fetched and a confirmation is done through the sdk.</p> <p>The confirmation of a purchase request means that funds are required to be released from the wallet and this operation needs the pin from the user, to avoid creation and confirmation of purchase request which might not have been authorized by the user. The confirmation triggers a wallet transaction to the recipient's wallet address as well as to the system's wallet address. The purchase details deliver this information for each individual purchase request. The result of the wallet transaction is then added to the purchase request and sent to the infrastructure as part of the confirmation body, so that the infrastructure can search for the transaction on the DLT network.</p> <pre><code>                                        |                      \n                                        |                      \n                                        |                      \n                 +-------------+        |                      \n                 |             |        |                      \n       User      | Create      |        |                      \n     +-----------&gt; Purchase    +--------+-+     +-------------+\n     | Request   | Request     |        | |     |             |\n     |           |             |        | |     |  (Polling)  |\n     |           +-------------+        | +-----&gt;  Get        |\n     |                                  |       |  Purchase   |\n     |                                  |       |  Status     |\n     |                                  |       +------+------+\n     |      Pin                         |              |       \n     +-------------------+              |              |Valid  \n                         |              |              |       \n                         |              |       +------v------+\n                  +------v------+       |       |             |\n                  |             |       |       |  Get        |\n    Wallet        | Confirm     &lt;-------+-------+  Purchase   |\n&lt;-----------------+ Purchase    |       |       |  Details    |\n    Transaction   | Request     |       |       |             |\n                  |             |       |       +-------------+\n                  +-------------+       |                      \n                                        |                      \n                                        |                      \n                                        |                      \n                                        |                      \n                               Once     |   Multiple times     \n                                        |                      \n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/","title":"API Reference","text":""},{"location":"SDK%20Reference/SDK%20API%20Reference/#levels-and-repeats","title":"Levels and Repeats","text":"Category Description Levels Basic The functions at these levels are absolutely necessary to use the SDK. Without calling these functions, the SDK is never in a correct state. Optional functions can be skipped, since they will take default values, if that is the requirement. Usage The functions at these levels can only be called once all basic level functions have successfully executed. Repeats Handle The functions need to be called every time a new SDK Handle (object) needs to be created via a constructor or after garbage collection of any existing old handles. User The functions need to be called every time a new SDK user needs to be created. Application The functions can be called any time while using the SDK, however they may fail, if the certain dependencies are not fulfilled."},{"location":"SDK%20Reference/SDK%20API%20Reference/#usage-infos-and-warnings","title":"Usage infos and warnings","text":"<p>Warning</p> <ul> <li>Viviswap and Postident KYC onboarding will not work if the user is already kyc verified.</li> <li>KYC onboarding with another provider will not work if the user is already started kyc onboarding with one of the other providers.</li> <li>Restoring a wallet backup may fail, if the wallet is already existing.</li> <li>Initializing User and initializing wallet may fail, if the user and wallet are already initialized. Since, there is no de-init function, the  SDK handle needs to be closed, or a new handle needs to be created to re init. </li> <li>Multiple handles to the wallet may also fail, since only atomic access are allowed.</li> <li>Deleting a user may fail if the backend cannot be reached.</li> </ul>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#javascript-typescript","title":"JavaScript / TypeScript","text":"<p>The API reference for the JS/TS bindings are available here. Please consult the tables below for the dependencies between each function.</p>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#java","title":"Java","text":"<p>The Javadoc API reference for the Java bindings is available here. Please consult the tables below for the dependencies between each function.</p>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#rust","title":"Rust","text":"<p>The Rustdoc API reference is available here. Please consult the tables below for the dependencies between each function.</p>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#java_1","title":"Java","text":"<p>The Javadoc API reference for the Java bindings is available here. Please consult the tables below for the dependencies between each function.</p>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#rust_1","title":"Rust","text":"<p>The Rustdoc API reference is available here. Please consult the tables below for the dependencies between each function.</p>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#sdk-initialization-and-configuration","title":"SDK Initialization and Configuration","text":""},{"location":"SDK%20Reference/SDK%20API%20Reference/#instantiating-the-sdk","title":"Instantiating the SDK","text":"Method Arguments Returns Dependencies Level Repeat Constructor Returns an <code>Error</code> if there is an issue in loading the dynamically or statically linked binary shared library, otherwise the handle to the SDK Basic Handle RustJavaTypescriptSwift <p>constructor</p> <p>constructor</p> <p>constructor</p> <p>Not available yet!</p> <pre><code>import CryptpaySdk\nlet sdk = CryptpaySdk()\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#set-configuration","title":"Set configuration","text":"Method Arguments Returns Dependencies Level Repeat Set the SDK configuration parameters. <code>config</code> - The JSON formatted string containing the configuration parameters. See SDK Configuration for more information of the available options. Constructor Basic Handle RustJavaTypescriptSwift <p>set_config</p> <p>setConfig</p> <p>setConfig</p> <p>Not available yet!</p> <pre><code>public func setConfig(config: String) throws\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#get-supported-networks","title":"Get supported networks","text":"Method Arguments Returns Dependencies Level Repeat Get the supported networks. Returns a list of ApiNetwork. Constructor, Set Configuration, Refresh access token, User initialization Basic RustJavaTypescriptSwift <p>getNetworks</p> <p>getNetworks</p> <p>getNetworks</p> <p>Not available yet!</p> <pre><code>public func getNetworks() throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#set-network","title":"Set network","text":"Method Arguments Returns Dependencies Level Repeat Sets the network <code>network_id</code> - The network_id as string. Constructor Basic Handle RustJavaTypescriptSwift <p>set_network</p> <p>setNetwork</p> <p>setNetwork</p> <p>Not available yet!</p> <pre><code>public func setNetwork(network_id: String) throws \n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#get-build-information","title":"Get build information","text":"Method Arguments Returns Dependencies Level Repeat Get the SDK build information Returns a multi-line String containing: <code>Branch name</code> (e.g. main), <code>Commit hash</code> (e.g. 92cedead), <code>Build time</code> (e.g. 2024-10-29 12:10:09 +00:00), <code>Rust version</code> (e.g. 1.80.1 3f5fd8dd4 2024-08-06), <code>Toolchain channel</code> (e.g. stable-x86_64-unknown-linux-gnu) Usage Application RustJavaTypescriptSwift <p>get_build_info</p> <p>getBuildInfo</p> <p>getBuildInfo</p> <p>Not available yet!</p> <pre><code>public func getBuildInfo() throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#user-functions","title":"User functions","text":""},{"location":"SDK%20Reference/SDK%20API%20Reference/#creating-a-new-user","title":"Creating a new user","text":"Method Arguments Returns Dependencies Level Repeat Create a new user <code>username</code> - The username of the new user. Constructor, Set Configuration Basic User RustJavaTypescriptSwift <p>create_new_user</p> <p>createNewUser</p> <p>createNewUser</p> <p>Not available yet!</p> <pre><code>public func createNewUser(username: String) throws\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#initializing-a-user","title":"Initializing a user","text":"Method Arguments Returns Dependencies Level Repeat Initialize a user <code>username</code> - The username of the user to initialize. Constructor, Set Configuration, Refresh access token, Create new user Usage Application RustJavaTypescriptSwift <p>init_user</p> <p>initializeUser</p> <p>initializeUser</p> <p>Not available yet!</p> <pre><code>public func initUser(username: String) throws \n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#refreshing-access-token","title":"Refreshing access token","text":"Method Arguments Returns Dependencies Level Repeat Refresh access token <code>access_token</code> - The new access token to be set. Constructor, Set Configuration Basic Application RustJavaTypescriptSwift <p>refresh_access_token</p> <p>refreshAccessToken</p> <p>refreshAccessToken</p> <p>Not available yet!</p> <pre><code>public func refreshAccessToken(access_token: String) throws \n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#checking-kyc-status","title":"Checking KYC status","text":"Method Arguments Returns Dependencies Level Repeat Check if the user's KYC status is verified <code>username</code> - The username of the user to check KYC status for. Returns <code>true</code> if the KYC status is verified, or <code>false</code> if it is not verified. User initialization Usage Application RustJavaTypescriptSwift <p>is_kyc_status_verified</p> <p>isKycVerified</p> <p>isKycVerified</p> <p>Not available yet!</p> <pre><code>public func isKycVerified(username: String) throws\n-&gt; Bool\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#delete-user","title":"Delete user","text":"Method Arguments Returns Dependencies Level Repeat Delete the currently active user and their wallet <code>pin</code> - The PIN of the user to be deleted. Required only if the user has created a wallet. User initialization Usage Application RustJavaTypescriptSwift <p>delete_user</p> <p>deleteUser</p> <p>deleteUser</p> <p>Not available yet!</p> <pre><code>public func deleteUser(pin: String) throws\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#wallet-functions","title":"Wallet functions","text":""},{"location":"SDK%20Reference/SDK%20API%20Reference/#create-new-wallet","title":"Create new wallet","text":"Method Arguments Returns Dependencies Level Repeat Creates a new wallet for the user with the specified PIN and password <code>pin</code> - The PIN for the wallet Returns the mnemonic phrase of the newly created wallet if successful. User initialization Usage User RustJavaTypescriptSwift <p>create_wallet_from_new_mnemonic</p> <p>createNewWallet</p> <p>createNewWallet</p> <p>Not available yet!</p> <pre><code>public func createNewWallet(pin: String) throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#create-new-wallet-from-mnemonic","title":"Create new wallet from mnemonic","text":"Method Arguments Returns Dependencies Level Repeat Create a wallet from existing mnemonic <code>pin</code> - The PIN for the wallet, <code>mnemonic</code> - The mnemonic to migrate from User initialization Usage User RustJavaTypescriptSwift <p>create_wallet_from_existing_mnemonic</p> <p>createWalletFromMnemonic</p> <p>createWalletFromMnemonic</p> <p>Not available yet!</p> <pre><code>public func createWalletFromMnemonic(pin: String, mnemonic: String) throws\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#create-new-wallet-from-backup","title":"Create new wallet from backup","text":"Method Arguments Returns Dependencies Level Repeat Create a wallet from existing backup <code>pin</code> - The PIN for the wallet, <code>backup</code> - The bytes representing the backup file contents, <code>backup_password</code> - The password used when creating the backup User initialization Usage Application RustJavaTypescriptSwift <p>create_wallet_from_backup</p> <p>createWalletFromBackup</p> <p>createWalletFromBackup</p> <p>Not available yet!</p> <pre><code>public func restoreWalletFromBackup(pin: String, backup: RustVec&lt;UInt8&gt;, backup_password: String) throws\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#create-a-wallet-backup","title":"Create a wallet backup","text":"Method Arguments Returns Dependencies Level Repeat Create a wallet backup <code>backup_password</code> - The password for the backup Returns the bytes of the created backup file if successful. User initialization Usage Application RustJavaTypescriptSwift <p>create_wallet_backup</p> <p>createWalletBackup</p> <p>createWalletBackup</p> <p>Not available yet!</p> <pre><code>public func createWalletBackup(backup_password: String) throws -&gt; RustVec&lt;UInt8&gt;\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#verify-mnemonic","title":"Verify mnemonic","text":"Method Arguments Returns Dependencies Level Repeat Verifies the mnemonic by checking if it matches the stored mnemonic <code>pin</code> - The PIN for the wallet, <code>mnemonic</code> - The mnemonic to verify Returns <code>true</code> or <code>false</code> whether the mnemonic is successfully verified. User initialization Usage User RustJavaTypescriptSwift <p>verify_mnemonic</p> <p>verifyMnemonic</p> <p>verifyMnemonic</p> <p>Not available yet!</p> <pre><code>public func verifyMnemonic(pin: String, mnemonic: String) throws -&gt; Bool\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#delete-wallet","title":"Delete wallet","text":"<p>Warning</p> <p>Deletes the currently active wallet, potentially resulting in loss of funds if the mnemonic or wallet is not backed up.</p> Method Arguments Returns Dependencies Level Repeat Delete the currently active wallet <code>pin</code> - The PIN for the wallet Wallet initialization Usage Application RustJavaTypescriptSwift <p>delete_wallet</p> <p>deleteWallet</p> <p>deleteWallet</p> <p>Not available yet!</p> <pre><code>public func deleteWallet(pin: String) throws\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#verify-pin","title":"Verify pin","text":"Method Arguments Returns Dependencies Level Repeat Verifies the pin for the wallet <code>pin</code> - The pin to verify Wallet initialization Usage Application RustJavaTypescriptSwift <p>verify_pin</p> <p>pinVerify</p> <p>verifyPin</p> <p>Not available yet!</p> <pre><code>public func verifyPin(pin: String) throws\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#reset-pin","title":"Reset pin","text":"Method Arguments Returns Dependencies Level Repeat Resets the pin for the wallet with a new pin by using the existing pin <code>pin</code> - The current pin for the wallet, <code>new_pin</code> - The new pin to set for the wallet Wallet initialization Usage Application RustJavaTypescriptSwift <p>change_pin</p> <p>pinReset</p> <p>resetPin</p> <p>Not available yet!</p> <pre><code>public func resetPin(pin: String, new_pin: String) throws \n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#set-wallet-password","title":"Set wallet password","text":"Method Arguments Returns Dependencies Level Repeat Set the password for the wallet using the provided pin and new password. If the password is already set, this changes it to the new password. Use <code>is_wallet_password_set</code> to check if the password is already set. <code>pin</code> - The new or existing PIN for the wallet, <code>new_password</code> - The new password to set for the wallet Wallet initialization Usage Application RustJavaTypescriptSwift <p>set_wallet_password</p> <p>setWalletPassword</p> <p>setWalletPassword</p> <p>Not available yet!</p> <pre><code>public func setWalletPassword(pin: String, new_password: String) throws\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#is-wallet-password-set","title":"Is wallet password set","text":"Method Arguments Returns Dependencies Level Repeat Check if the password is already set. Useful to prompt the user to setup one if it has not yet been done. See also <code>set_wallet_password</code> for how to set a new password and change an existing password. Returns <code>true</code> or <code>false</code> whether or not the password is already set. Wallet initialization Usage Application RustJavaTypescriptSwift <p>is_wallet_password_set</p> <p>isWalletPasswordSet</p> <p>isWalletPasswordSet</p> <p>Not available yet!</p> <pre><code>public func isWalletPasswordSet() throws\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#generate-a-new-address","title":"Generate a new address","text":"Method Arguments Returns Dependencies Level Repeat Generates a new receiver address for the wallet based on the selected network. <code>pin</code> - The PIN for the wallet Returns the generated address as a <code>String</code> if successful. Wallet initialization, Set network Usage Application RustJavaTypescriptSwift <p>generate_new_address</p> <p>generateNewAddress</p> <p>generateNewAddress</p> <p>Not available yet!</p> <pre><code>public func generateNewAddress(pin: String) throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#get-balance","title":"Get balance","text":"Method Arguments Returns Dependencies Level Repeat Fetches the balance of the user from the wallet <code>pin</code> - The PIN for the wallet Returns the balance as a <code>f64</code> if successful. Wallet initialization Usage Application RustJavaTypescriptSwift <p>get_balance</p> <p>getWalletBalance</p> <p>getWalletBalance</p> <p>Not available yet!</p> <pre><code>public func getBalance(pin: String) throws -&gt; Float\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#get-wallet-transactions","title":"Get wallet transactions","text":"Method Arguments Returns Dependencies Level Repeat Wallet transaction list <code>pin</code> - The PIN for the wallet, <code>start</code> - The starting page number for paginatation, <code>limit</code> - The page limit size for each page Returns the list of transactions made on the wallet as an array of <code>WalletTxInfo</code> object or a serialized JSON of the same, if successful. Wallet initialization Usage Application RustJavaTypescriptSwift <p>get_wallet_tx_list</p> <p>getWalletTransactionList</p> <p>getWalletTransactionList</p> <p>Not available yet!</p> <pre><code>public func getWalletTransactionList(pin: String, start: UInt64, limit: UInt64) throws -&gt; Rustvec&lt;WalletTxInfo&gt;\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#wallettxinfo","title":"WalletTxInfo","text":"RustJSON <pre><code>pub struct WalletTxInfo {\n/// Transaction creation date\npub date: String,\n/// Contains block id\npub block_id: Option&lt;String&gt;,\n/// Transaction id for particular transaction\npub transaction_id: String,\n/// Describes type of transaction\npub incoming: bool,\n/// Amount of transfer\npub amount: f64,\n/// Name of the network [convert network_id to string based on the value]\npub network: String,\n/// Status of the transfer\npub status: String,\n/// Url of network\npub explorer_url: Option&lt;String&gt;,\n}\n</code></pre> <pre><code>{\n    \"$schema\": \"&lt;http://json-schema.org/draft-07/schema#&gt;\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"date\": {\n            \"type\": \"string\",\n            \"description\": \"Transaction creation date\"\n        },\n        \"block_id\": {\n            \"type\": [\"string\", \"null\"],\n            \"description\": \"Contains block id\"\n        },\n        \"transaction_id\": {\n            \"type\": \"string\",\n            \"description\": \"Transaction id for particular transaction\"\n        },\n        \"incoming\": {\n            \"type\": \"boolean\",\n            \"description\": \"Describes type of transaction\"\n        },\n        \"amount\": {\n            \"type\": \"number\",\n            \"description\": \"Amount of transfer\"\n        },\n        \"network\": {\n            \"type\": \"string\",\n            \"description\": \"Name of the network [convert network_id to string based on the value]\"\n        },\n        \"status\": {\n            \"type\": \"string\",\n            \"description\": \"Status of the transfer\"\n        },\n        \"explorer_url\": {\n            \"type\": [\"string\", \"null\"],\n            \"description\": \"Url of network\"\n        }\n    },\n    \"required\": [\"date\", \"transaction_id\", \"incoming\", \"amount\", \"network\", \"status\"]\n}\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#get-wallet-transaction","title":"Get wallet transaction","text":"Method Arguments Returns Dependencies Level Repeat Single wallet transaction <code>pin</code> - The PIN for the wallet, <code>tx_id</code> - The transaction id on the network Returns the transactions made on the wallet with the given id as <code>WalletTxInfo</code> object or a serialized JSON of the same, if successful. Wallet initialization Usage Application RustJavaTypescriptSwift <p>get_wallet_tx</p> <p>getWalletTransaction</p> <p>getWalletTransaction</p> <p>Not available yet!</p> <pre><code>public func getWalletTransaction(pin: String, transactionId: String) throws -&gt; WalletTxInfo\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#set-recovery-share","title":"Set recovery share","text":"Method Arguments Returns Dependencies Level Repeat Sets the recovery share for the users wallet. <code>share</code> - The recovery share to upload. User initialization Usage Application RustJavaTypescriptSwift <p>set_recovery_share</p> <p>setRecoveryShare</p> <p>setRecoveryShare</p> <p>Not available yet!</p> <pre><code>public func setRecoveryShare(share: String) throws\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#get-recovery-share","title":"Get recovery share","text":"Method Arguments Returns Dependencies Level Repeat Get the recovery share for the users wallet. User initialization Usage Application RustJavaTypescriptSwift <p>get_recovery_share</p> <p>getRecoveryShare</p> <p>getRecoveryShare</p> <p>Not available yet!</p> <pre><code>public func getRecoveryShare() throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#viviswap-functions","title":"Viviswap functions","text":""},{"location":"SDK%20Reference/SDK%20API%20Reference/#start-kyc-verification-for-viviswap","title":"Start KYC Verification for viviswap","text":"Method Arguments Returns Dependencies Level Repeat Create a new viviswap user and initialize KYC verification <code>mail</code> - The email address of the user, <code>terms_accepted</code> - A boolean indicating whether the terms have been accepted Returns <code>NewViviswapUser</code> object if successful. User initialization Usage Application RustJavaTypescriptSwift <p>start_kyc_verification_for_viviswap</p> <p>startViviswapKyc</p> <p>startKycVerificationForViviswap</p> <p>Not available yet!</p> <pre><code>public func startKycVerificationForViviswap(mail: String, termsAccepted: Bool) throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#newviviswapuser","title":"NewViviswapUser","text":"RustJSON <pre><code>pub struct NewViviswapUser {\n/// Username of new viviswap user\npub username: String,\n}\n</code></pre> <pre><code>{\n    \"$schema\": \"&lt;http://json-schema.org/draft-07/schema#&gt;\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"username\": {\n            \"type\": \"string\",\n            \"description\": \"Username of new viviswap user\"\n        }\n    },\n    \"required\": [\"username\"]\n}\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#get-kyc-details-for-viviswap","title":"Get KYC details for viviswap","text":"Method Arguments Returns Dependencies Level Repeat Get current kyc status of viviswap Returns <code>ViviswapKycStatus</code> object if successful. User initialization Usage Application RustJavaTypescriptSwift <p>get_kyc_details_for_viviswap</p> <p>getViviswapKyc</p> <p>getKycDetailsForViviswap</p> <p>Not available yet!</p> <pre><code>public func getKycDetailsForViviswap() throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#viviswapkycstatus","title":"ViviswapKycStatus","text":"RustJSON <pre><code>pub struct ViviswapKycStatus {\n    /// full name of the user\n    pub full_name: String,\n    /// the current submission step in the KYC onboarding process for the user\n    pub submission_step: ViviswapVerificationStep,\n    /// the current verified step in the KYC onboarding process for the user\n    pub verified_step: ViviswapVerificationStep,\n    /// the user verification status\n    pub verification_status: ViviswapVerificationStatus,\n    /// The monthly swap limit in euros\n    pub monthly_limit_eur: f32,\n}\npub enum ViviswapVerificationStep {\n    /// no verification step (no next verification step available)\n    Undefined,\n    /// general verification step\n    General,\n    /// personal verification step\n    Personal,\n    /// residence verification step\n    Residence,\n    /// identity verification step\n    Identity,\n    /// amla general verification step\n    Amla,\n    /// document verification step\n    Documents,\n}\npub enum ViviswapVerificationStatus {\n    /// The user is fully verified\n    Verified,\n    /// The user is not verified\n    Unverified,\n    /// The user is partially verified\n    PartiallyVerified,\n}\n</code></pre> <pre><code>{\n    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"full_name\": {\n            \"type\": \"string\",\n            \"description\": \"Full name of the user\"\n        },\n        \"submission_step\": {\n            \"type\": \"string\",\n            \"enum\": [\"Undefined\", \"General\", \"Personal\", \"Residence\", \"Identity\", \"Amla\", \"Documents\"],\n            \"description\": \"The current submission step in the KYC onboarding process for the user\"\n        },\n        \"verified_step\": {\n            \"type\": \"string\",\n            \"enum\": [\"Undefined\", \"General\", \"Personal\", \"Residence\", \"Identity\", \"Amla\", \"Documents\"],\n            \"description\": \"The current verified step in the KYC onboarding process for the user\"\n        },\n        \"verification_status\": {\n            \"type\": \"string\",\n            \"enum\": [\"Verified\", \"Unverified\", \"PartiallyVerified\"],\n            \"description\": \"The user verification status\"\n        },\n        \"monthly_limit_eur\": {\n            \"type\": \"number\",\n            \"description\": \"The monthly swap limit in euros\"\n        }\n    },\n    \"required\": [\"full_name\", \"submission_step\", \"verified_step\", \"verification_status\", \"monthly_limit_eur\"]\n}\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#update-partial-kyc-for-viviswap","title":"Update partial KYC for viviswap","text":"Method Arguments Returns Dependencies Level Repeat Update the kyc details for viviswap to be submitted <code>is_individual</code> - Whether the user is an individual, <code>is_pep</code> - Whether the user is a politically exposed person, <code>is_us_citizen</code> - Whether the user is a US citizen, <code>is_regulatory_disclosure</code> - Whether the user has accepted the regulatory disclosure, <code>country_of_residence</code> - The country of residence of the user, <code>nationality</code> - The nationality of the user, <code>full_name</code> - The full name of the user, <code>date_of_birth</code> - The date of birth of the user Returns <code>ViviswapPartiallyKycDetails</code> object containing the partially updated KYC details. User initialization Usage Application RustJavaTypescriptSwift <p>update_kyc_partially_status_for_viviswap</p> <p>updateViviswapKycPartial</p> <p>updateKycPartiallyStatusForViviswap</p> <p>Not available yet!</p> <pre><code>public func updateKycPartiallyStatusForViviswap(\n    isIndividual: Bool,\n    isPep: Bool,\n    isUsCitizen: Bool,\n    isRegulatoryDisclosure: Bool,\n    countryOfResidence: String,\n    nationality: String,\n    fullName: String,\n    dateOfBirth: String\n) throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#viviswappartiallykycdetails","title":"ViviswapPartiallyKycDetails","text":"RustJSON <pre><code>pub struct ViviswapPartiallyKycDetails {\n    /// Is the user an individual\n    pub is_individual: Option&lt;bool&gt;,\n    /// Is the user a politically exposed person\n    pub is_pep: Option&lt;bool&gt;,\n    /// Is the user a US citizen\n    pub is_us_citizen: Option&lt;bool&gt;,\n    /// Is the regulatory disclosure confirmed by user\n    pub is_regulatory_disclosure: Option&lt;bool&gt;,\n    /// The country of tax residence of the user\n    pub country_of_residence: Option&lt;String&gt;,\n    /// The user's nationality\n    pub nationality: Option&lt;String&gt;,\n    /// The full name of the user as per his legal documents\n    pub full_name: Option&lt;String&gt;,\n    /// The date of birth of the user as per his legal documents\n    pub date_of_birth: Option&lt;String&gt;,\n}\n</code></pre> <pre><code>{\n    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"is_individual\": {\n            \"type\": [\"boolean\", \"null\"],\n            \"description\": \"Is the user an individual\"\n        },\n        \"is_pep\": {\n            \"type\": [\"boolean\", \"null\"],\n            \"description\": \"Is the user a politically exposed person\"\n        },\n        \"is_us_citizen\": {\n            \"type\": [\"boolean\", \"null\"],\n            \"description\": \"Is the user a US citizen\"\n        },\n        \"is_regulatory_disclosure\": {\n            \"type\": [\"boolean\", \"null\"],\n            \"description\": \"Is the regulatory disclosure confirmed by user\"\n        },\n        \"country_of_residence\": {\n            \"type\": [\"string\", \"null\"],\n            \"description\": \"The country of tax residence of the user\"\n        },\n        \"nationality\": {\n            \"type\": [\"string\", \"null\"],\n            \"description\": \"The user's nationality\"\n        },\n        \"full_name\": {\n            \"type\": [\"string\", \"null\"],\n            \"description\": \"The full name of the user as per his legal documents\"\n        },\n        \"date_of_birth\": {\n            \"type\": [\"string\", \"null\"],\n            \"description\": \"The date of birth of the user as per his legal documents\"\n        }\n    }\n}\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#submit-partial-kyc-for-viviswap","title":"Submit partial KYC for viviswap","text":"Method Arguments Returns Dependencies Level Repeat Submit the kyc details for viviswap User initialization Usage Application RustJavaTypescriptSwift <p>submit_kyc_partially_status_for_viviswap</p> <p>submitViviswapKycPartial</p> <p>submitKycPartiallyStatusForViviswap</p> <p>Not available yet!</p> <pre><code>public func submitKycPartiallyStatusForViviswap() throws\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#get-iban-for-viviswap","title":"Get IBAN for viviswap","text":"Method Arguments Returns Dependencies Level Repeat Get current iban of viviswap user Returns <code>ViviswapAddressDetail</code> object if successful. Wallet initialization, Get KYC Details for viviswap Usage Application RustJavaTypescriptSwift <p>get_iban_for_viviswap</p> <p>getIbanViviswap</p> <p>getIbanViviswap</p> <p>Not available yet!</p> <pre><code>public func getIbanViviswap() throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#viviswapaddressdetail","title":"ViviswapAddressDetail","text":"RustJSON <pre><code>pub struct ViviswapAddressDetail {\n    /// the unique id of the address detail\n    pub id: String,\n    /// the address used in the detail\n    pub address: String,\n    /// the status from viviswap, whether the address is verified\n    pub is_verified: bool,\n}\n</code></pre> <pre><code>{\n    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"id\": {\n            \"type\": \"string\",\n            \"description\": \"The unique id of the address detail\"\n        },\n        \"address\": {\n            \"type\": \"string\",\n            \"description\": \"The address used in the detail\"\n        },\n        \"is_verified\": {\n            \"type\": \"boolean\",\n            \"description\": \"The status from viviswap, whether the address is verified\"\n        }\n    },\n    \"required\": [\"id\", \"address\", \"is_verified\"]\n}\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#update-iban-for-viviswap","title":"Update IBAN for viviswap","text":"Method Arguments Returns Dependencies Level Repeat Update IBAN of viviswap user <code>pin</code> - The user's PIN, <code>address</code> - The new IBAN address Returns <code>ViviswapAddressDetail</code> object if successful. Wallet initialization, Get KYC Details for viviswap Usage Application RustJavaTypescriptSwift <p>update_iban_for_viviswap</p> <p>updateIbanViviswap</p> <p>updateIbanViviswap</p> <p>Not available yet!</p> <pre><code>public func updateIbanViviswap(pin: String, address: String) throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#create-deposit-with-viviswap","title":"Create deposit with viviswap","text":"Method Arguments Returns Dependencies Level Repeat Create deposit for viviswap user <code>pin</code> - The PIN for the wallet Returns <code>ViviswapDeposit</code> object if successful. Wallet initialization, Get KYC Details for viviswap, Update IBAN Usage Application RustJavaTypescriptSwift <p>create_deposit_with_viviswap</p> <p>depositWithViviswap</p> <p>createDepositWithViviswap</p> <p>Not available yet!</p> <pre><code>public func depositWithViviswap(pin: String) throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#viviswapdeposit","title":"ViviswapDeposit","text":"RustJSON <pre><code>pub struct ViviswapDeposit {\n    /// The unique UUID of the contract\n    pub contract_id: String,\n    /// The deposit address (crypto) where the swap will put the funds from fiat\n    pub deposit_address: String,\n    /// The details of the deposit (for the user)\n    pub details: ViviswapDepositDetails,\n}\npub struct ViviswapDepositDetails {\n    /// The reference to be entered by the user in his SEPA bank transfer\n    pub reference: String,\n    /// The name of the beneficiary receiving the SEPA transfer\n    pub beneficiary: String,\n    /// The name of the bank of the beneficiary\n    pub name_of_bank: String,\n    /// The address of the bank of the beneficiary\n    pub address_of_bank: String,\n    /// The IBAN of the beneficiary\n    pub iban: String,\n    /// The BIC/SWIFT code for the SEPA transfer\n    pub bic: String,\n}\n</code></pre> <pre><code>{\n    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"contract_id\": {\n            \"type\": \"string\",\n            \"description\": \"The unique UUID of the contract\"\n        },\n        \"deposit_address\": {\n            \"type\": \"string\",\n            \"description\": \"The deposit address (crypto) where the swap will put the funds from fiat\"\n        },\n        \"details\": {\n            \"type\": \"object\",\n            \"description\": \"The details of the deposit (for the user)\",\n            \"properties\": {\n                \"reference\": {\n                    \"type\": \"string\",\n                    \"description\": \"The reference to be entered by the user in his SEPA bank transfer\"\n                },\n                \"beneficiary\": {\n                    \"type\": \"string\",\n                    \"description\": \"The name of the beneficiary receiving the SEPA transfer\"\n                },\n                \"name_of_bank\": {\n                    \"type\": \"string\",\n                    \"description\": \"The name of the bank of the beneficiary\"\n                },\n                \"address_of_bank\": {\n                    \"type\": \"string\",\n                    \"description\": \"The address of the bank of the beneficiary\"\n                },\n                \"iban\": {\n                    \"type\": \"string\",\n                    \"description\": \"The IBAN of the beneficiary\"\n                },\n                \"bic\": {\n                    \"type\": \"string\",\n                    \"description\": \"The BIC/SWIFT code for the SEPA transfer\"\n                }\n            },\n            \"required\": [\"reference\", \"beneficiary\", \"name_of_bank\", \"address_of_bank\", \"iban\", \"bic\"]\n        }\n    },\n    \"required\": [\"contract_id\", \"deposit_address\", \"details\"]\n}\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#create-viviswap-address-detail","title":"Create viviswap address detail","text":"Method Arguments Returns Dependencies Level Repeat Create address detail for viviswap user <code>pin</code> - The PIN for the wallet Returns <code>ViviswapAddressDetail</code> object if successful. Wallet initialization, Get KYC Details for viviswap Usage Application RustJavaTypescriptSwift <p>create_detail_for_viviswap</p> <p>createViviswapDetail</p> <p>createDetailForViviswap</p> <p>Not available yet!</p> <pre><code>public func createViviswapDetail(pin: String) throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#create-withdrawal-with-viviswap","title":"Create withdrawal with viviswap","text":"Method Arguments Returns Dependencies Level Repeat Create address detail for viviswap user <code>amount</code> - The amount of the withdrawal, <code>pin</code> - The optional PIN for verification, <code>tag</code> - Optional tag which can be assigned to the transaction, <code>data</code> - Optional data which can be assigned to the tag, <code>message</code> - Optional transaction message Returns <code>ViviswapWithdrawal</code> object if successful. Wallet initialization, Get KYC Details for viviswap, Update IBAN Usage Application RustJavaTypescriptSwift <p>create_withdrawal_with_viviswap</p> <p>withdrawWithViviswap</p> <p>createWithdrawalWithViviswap</p> <p>Not available yet!</p> <pre><code>public func withdrawWithViviswap(amount: Float, pin: String, tag: [UInt8], data: [UInt8], message: String) throws -&gt; ViviswapWithdrawal \n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#viviswapwithdrawal","title":"ViviswapWithdrawal","text":"RustJSON <pre><code>pub struct ViviswapWithdrawal {\n    /// The unique UUID to track the withdrawal contract\n    pub contract_id: String,\n    /// The deposit address, in this case the IBAN of the user, where fiat will be deposited.\n    pub deposit_address: String,\n    /// The details of the withdrawal\n    pub details: ViviswapWithdrawalDetails,\n}\npub struct ViviswapWithdrawalDetails {\n    /// The reference used by viviswap for the SEPA transfer\n    pub reference: String,\n    /// The id of the unique wallet internal to viviswap\n    pub wallet_id: String,\n    /// The crypto address of viviswap where the crypto swap is to be sent\n    pub crypto_address: String,\n}\n</code></pre> <pre><code>{\n    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"contract_id\": {\n            \"type\": \"string\",\n            \"description\": \"The unique UUID of the contract\"\n        },\n        \"withdrawal_address\": {\n            \"type\": \"string\",\n            \"description\": \"The withdrawal address (crypto) where the swap will put the funds from fiat\"\n        },\n        \"details\": {\n            \"type\": \"object\",\n            \"description\": \"The details of the withdrawal (for the user)\",\n            \"properties\": {\n                \"reference\": {\n                    \"type\": \"string\",\n                    \"description\": \"The reference used by viviswap for the SEPA transfer\"\n                },\n                \"wallet_id\": {\n                    \"type\": \"string\",\n                    \"description\": \"The id of the unique wallet internal to viviswap\"\n                },\n                \"crypto_address\": {\n                    \"type\": \"string\",\n                    \"description\": \"The crypto address of viviswap where the crypto swap is to be sent\"\n                }\n            },\n            \"required\": [\"reference\", \"wallet_id\", \"crypto_address\"]\n        }\n    },\n    \"required\": [\"contract_id\", \"withdrawal_address\", \"details\"]\n}\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#get-swap-details","title":"Get swap details","text":"Method Arguments Returns Dependencies Level Repeat Get swap details <code>order_id</code> - The ID of the swap order. Returns <code>Order</code> object containing the swap order details. Wallet initialization, Get KYC Details for viviswap Usage Application RustJavaTypescriptSwift <p>get_swap_details</p> <p>getSwapDetails</p> <p>getSwapDetails</p> <p>Not available yet!</p> <pre><code>public func getSwapDetails(order_id: String) throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#order","title":"Order","text":"RustJSON <pre><code>pub struct Order {\n    pub id: String,\n    pub is_payed_out: bool,\n    pub is_approved: bool,\n    pub is_canceled: bool,\n    pub fees_amount_eur: f32,\n    pub crypto_fees: f32,\n    pub contract_id: String,\n    pub incoming_payment_method_id: String,\n    pub incoming_payment_method_currency: String,\n    pub incoming_amount: f32,\n    pub incoming_course: f32,\n    pub outgoing_payment_method_id: String,\n    pub outgoing_payment_method_currency: String,\n    pub outgoing_amount: f32,\n    pub outgoing_course: f32,\n    pub refund_amount: Option&lt;f32&gt;,\n    pub refund_course: Option&lt;f32&gt;,\n    pub refund_payment_method_id: Option&lt;String&gt;,\n    pub status: i32,\n    pub creation_date: String,\n    pub incoming_payment_detail: Option&lt;PaymentDetail&gt;,\n    pub outgoing_payment_detail: Option&lt;PaymentDetail&gt;,\n    pub refund_payment_detail: Option&lt;PaymentDetail&gt;,\n}\n\npub struct PaymentDetail {\n    pub id: String,\n    pub address: String,\n    pub is_verified: Option&lt;bool&gt;,\n}\n</code></pre> <pre><code>{\n    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"id\": {\n            \"type\": \"string\",\n            \"description\": \"The unique id of the order\"\n        },\n        \"is_payed_out\": {\n            \"type\": \"boolean\",\n            \"description\": \"Whether the order is payed out\"\n        },\n        \"is_approved\": {\n            \"type\": \"boolean\",\n            \"description\": \"Whether the order is approved\"\n        },\n        \"is_canceled\": {\n            \"type\": \"boolean\",\n            \"description\": \"Whether the order is canceled\"\n        },\n        \"fees_amount_eur\": {\n            \"type\": \"number\",\n            \"description\": \"The amount of fees in EUR\"\n        },\n        \"crypto_fees\": {\n            \"type\": \"number\",\n            \"description\": \"The amount of crypto fees\"\n        },\n        \"contract_id\": {\n            \"type\": \"string\",\n            \"description\": \"The id of the contract\"\n        },\n        \"incoming_payment_method_id\": {\n            \"type\": \"string\",\n            \"description\": \"The id of the incoming payment method\"\n        },\n        \"incoming_payment_method_currency\": {\n            \"type\": \"string\",\n            \"description\": \"The currency of the incoming payment method\"\n        },\n        \"incoming_amount\": {\n            \"type\": \"number\",\n            \"description\": \"The amount of the incoming payment\"\n        },\n        \"incoming_course\": {\n            \"type\": \"number\",\n            \"description\": \"The course of the incoming payment\"\n        },\n        \"outgoing_payment_method_id\": {\n            \"type\": \"string\",\n            \"description\": \"The id of the outgoing payment method\"\n        },\n        \"outgoing_payment_method_currency\": {\n            \"type\": \"string\",\n            \"description\": \"The currency of the outgoing payment method\"\n        },\n        \"outgoing_amount\": {\n            \"type\": \"number\",\n            \"description\": \"The amount of the outgoing payment\"\n        },\n        \"outgoing_course\": {\n            \"type\": \"number\",\n            \"description\": \"The course of the outgoing payment\"\n        },\n        \"refund_amount\": {\n            \"type\": [\"number\", \"null\"],\n            \"description\": \"The amount of the refund\"\n        },\n        \"refund_course\": {\n            \"type\": [\"number\", \"null\"],\n            \"description\": \"The course of the refund\"\n        },\n        \"refund_payment_method_id\": {\n            \"type\": [\"string\", \"null\"],\n            \"description\": \"The id of the refund payment method\"\n        },\n        \"status\": {\n            \"type\": \"integer\",\n            \"description\": \"The status of the order\"\n        },\n        \"creation_date\": {\n            \"type\": \"string\",\n            \"description\": \"The creation date of the order\"\n        },\n        \"incoming_payment_detail\": {\n            \"type\": [\"object\", \"null\"],\n            \"description\": \"The details of the incoming payment\",\n            \"properties\": {\n                \"id\": {\n                    \"type\": \"string\",\n                    \"description\": \"The unique id of the payment detail\"\n                },\n                \"address\": {\n                    \"type\": \"string\",\n                    \"description\": \"The address of the payment detail\"\n                }\n            },\n            \"required\": [\"id\", \"address\"]\n        },\n        \"outgoing_payment_detail\": {\n            \"type\": [\"object\", \"null\"],\n            \"description\": \"The details of the outgoing payment\",\n            \"properties\": {\n                \"id\": {\n                    \"type\": \"string\",\n                    \"description\": \"The unique id of the payment detail\"\n                },\n                \"address\": {\n                    \"type\": \"string\",\n                    \"description\": \"The address of the payment detail\"\n                }\n            },\n            \"required\": [\"id\", \"address\"]\n        },\n        \"refund_payment_detail\": {\n            \"type\": [\"object\", \"null\"],\n            \"description\": \"The details of the refund payment\",\n            \"properties\": {\n                \"id\": {\n                    \"type\": \"string\",\n                    \"description\": \"The unique id of the payment detail\"\n                },\n                \"address\": {\n                    \"type\": \"string\",\n                    \"description\": \"The address of the payment detail\"\n                }\n            },\n            \"required\": [\"id\", \"address\"]\n        }\n    },\n    \"required\": [\"id\", \"is_payed_out\", \"is_approved\", \"is_canceled\", \"fees_amount_eur\", \"crypto_fees\", \"contract_id\", \"incoming_payment_method_id\", \"incoming_payment_method_currency\", \"incoming_amount\", \"incoming_course\", \"outgoing_payment_method_id\", \"outgoing_payment_method_currency\", \"outgoing_amount\", \"outgoing_course\", \"status\", \"creation_date\"]\n}\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#get-swap-lists","title":"Get swap lists","text":"Method Arguments Returns Dependencies Level Repeat Get swap list <code>start</code> - The start page parameter, <code>limit</code> - The pagination limit parameter Returns an array of <code>Order</code> object containing the swap order details for each swap. Wallet initialization, Get KYC Details for viviswap Usage Application RustJavaTypescriptSwift <p>get_swap_list</p> <p>getSwapList</p> <p>getSwapList</p> <p>Not available yet!</p> <pre><code>public func getSwapList(page: UInt64, limit: UInt64) throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#get-exchange-rate","title":"Get exchange rate","text":"Method Arguments Returns Dependencies Level Repeat Get the exchange rate for the selected currency Returns the latest exchange rate Usage Application RustJavaTypescriptSwift <p>get_exchange_rate</p> <p>getExchangeRate</p> <p>getExchangeRate</p> <p>Not available yet!</p> <pre><code>public func getExchangeRate() throws -&gt; Float\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#transaction-functions","title":"Transaction functions","text":""},{"location":"SDK%20Reference/SDK%20API%20Reference/#create-purchase-request","title":"Create purchase request","text":"Method Arguments Returns Dependencies Level Repeat Create purchase request <code>receiver</code> - The receiver's username, <code>amount</code> - The amount of the purchase, <code>product_hash</code> - The hash of the product, <code>app_data</code> - The application data, <code>purchase_type</code> - The type of the purchase Returns the purchase ID. This is an internal index used to reference the transaction in cryptpay Wallet initialization Usage Application RustJavaTypescriptSwift <p>create_purchase_request</p> <p>purchaseRequestCreate</p> <p>createPurchaseRequest</p> <p>Not available yet!</p> <pre><code>public func createPurchaseRequest(\n    receiver: String, amount: Double, product_hash: String, app_data: String, purchase_type: String\n) throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#get-purchase-details","title":"Get purchase details","text":"Method Arguments Returns Dependencies Level Repeat Get purchase details <code>purchase_id</code> - The ID of the purchase. Returns the purchase details as <code>PurchaseDetails</code> object Wallet initialization Usage Application RustJavaTypescriptSwift <p>get_purchase_details</p> <p>purchaseDetails</p> <p>getPurchaseDetails</p> <p>Not available yet!</p> <pre><code>public func getPurchaseDetails(purchase_id: String) throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#purchasedetails","title":"PurchaseDetails","text":"RustJSON <pre><code>    pub struct PurchaseDetails {\n        /// The sender address where the fees goes to.\n        pub system_address: String,\n        /// The amount to be paid.\n        pub amount: Decimal,\n        /// The status of transaction\n        pub status: ApiTxStatus,\n    }\n</code></pre> <pre><code>{\n    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"system_address\": {\n            \"type\": \"string\",\n            \"description\": \"The sender address where the fees goes to.\"\n        },\n        \"amount\": {\n            \"type\": \"number\",\n            \"description\": \"The amount to be paid\"\n        },\n        \"status\": {\n            \"type\": \"object\",\n            \"description\": \"Status of the transfer\",\n            \"enum\": [\"Pending\", \"WaitingForVerification\", \"Valid\", \"Invalid\", \"ProcessingIncoming\", \"ProcessingOutgoing\", \"Completed\", \"Failed\"]\n        },\n    },\n    \"required\": [\"system_address\", \"amount\", \"status\"]\n}\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#confirm-purchase-request","title":"Confirm purchase request","text":"Method Arguments Returns Dependencies Level Repeat Confirm purchase request <code>pin</code> - The PIN of the user, <code>purchase_id</code> - The ID of the purchase. Wallet initialization Usage Application RustJavaTypescriptSwift <p>confirm_purchase_request</p> <p>purchaseRequestConfirm</p> <p>confirmPurchaseRequest</p> <p>Not available yet!</p> <pre><code>public func confirmPurchaseRequest(pin: String, purchase_id: String) throws\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#send-amount","title":"Send amount","text":"Method Arguments Returns Dependencies Level Repeat Send amount to the receiver address. <code>pin</code> - The PIN of the user, <code>address</code> - The receiver's address, <code>amount</code> - The amount to send, <code>tag</code> - Optional tag which can be assigned to the transaction, <code>data</code> - Optional data which can be assigned to the tag, <code>message</code> - Optional transaction message Wallet initialization Usage Application RustJavaTypescriptSwift <p>send_amount</p> <p>sendAmount</p> <p>sendAmount</p> <p>Not available yet!</p> <pre><code>public func sendAmount(pin: String, address: String, amount: Double, tag: [UInt8], data: [UInt8], message: String) throws\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#get-purchase-list","title":"Get Purchase list","text":"Method Arguments Returns Dependencies Level Repeat Get purchase list <code>start</code> - The starting page number, <code>limit</code> - The maximum number of transactions per page Returns a list of purchases as <code>TxInfo</code> object, if successful. User initialization Usage Application RustJavaTypescriptSwift <p>get_tx_list</p> <p>txList</p> <p>getTransactionList</p> <p>Not available yet!</p> <pre><code>public func getTxList(start: UInt64, limit: UInt64) throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#txinfo","title":"TxInfo","text":"RustJSON <pre><code>pub struct TxInfo {\n    /// Tx creation date, if available\n    pub date: Option&lt;String&gt;,\n    /// receiver of the transaction\n    pub receiver: String,\n    /// cryptpay reference id for the transaction\n    pub reference_id: String,\n    /// Application specific metadata attached to the tx\n    pub application_metadata: Option&lt;ApplicationMetadata&gt;,\n    /// Amount of transfer\n    pub amount: f64,\n    /// Currency of transfer\n    pub currency: String,\n    /// Status of the transfer\n    pub status: TxStatus,\n    /// The transaction hash on the network\n    pub transaction_hash: Option&lt;String&gt;,\n    /// Exchange rate\n    pub course: f64,\n}\n\npub struct ApplicationMetadata {\n    pub product_hash: String,\n    pub reason: String,\n    pub purchase_model: String,\n    pub app_data: String,\n}\n</code></pre> <pre><code>{\n    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"date\": {\n            \"type\": [\"string\", \"null\"],\n            \"description\": \"Tx creation date, if available\"\n        },\n        \"receiver\": {\n            \"type\": \"string\",\n            \"description\": \"receiver of the transaction\"\n        },\n        \"reference_id\": {\n            \"type\": \"string\",\n            \"description\": \"cryptpay reference id for the transaction\"\n        },\n        \"application_metadata\": {\n            \"type\": [\"object\", \"null\"],\n            \"description\": \"Application specific metadata attached to the tx\",\n            \"properties\": {\n                \"product_hash\": {\n                    \"type\": \"string\",\n                    \"description\": \"The product hash\"\n                },\n                \"reason\": {\n                    \"type\": \"string\",\n                    \"description\": \"The reason for the transaction\"\n                },\n                \"purchase_model\": {\n                    \"type\": \"string\",\n                    \"description\": \"The purchase model\"\n                },\n                \"app_data\": {\n                    \"type\": \"string\",\n                    \"description\": \"The application data\"\n                }\n            },\n            \"required\": [\"product_hash\", \"reason\", \"purchase_model\", \"app_data\"]\n        },\n        \"amount\": {\n            \"type\": \"number\",\n            \"description\": \"Amount of transfer\"\n        },\n        \"currency\": {\n            \"type\": \"string\",\n            \"description\": \"Currency of transfer\"\n        },\n        \"status\": {\n            \"type\": \"string\",\n            \"description\": \"Status of the transfer\",\n            \"enum\": [\"Pending\", \"Valid\", \"Invalid\", \"ProcessingMain\", \"ProcessingAux\", \"Completed\", \"Failed\"]\n        },\n        \"transaction_hash\": {\n            \"type\": [\"string\", \"null\"],\n            \"description\": \"The transaction hash on the network\"\n        },\n        \"course\": {\n            \"type\": \"number\",\n            \"description\": \"Exchange rate\"\n        }\n    },\n    \"required\": [\"receiver\", \"reference_id\", \"amount\", \"currency\", \"status\", \"course\"]\n}\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#postident-functions","title":"Postident functions","text":""},{"location":"SDK%20Reference/SDK%20API%20Reference/#start-kyc-verification-for-postident","title":"Start kyc verification for postident","text":"Method Arguments Returns Dependencies Level Repeat Start kyc verification for postident Returns an object <code>NewCaseIdResponse</code> if successful. User initialization Usage Application RustJavaTypescriptSwift <p>start_kyc_verification_for_postident</p> <p>startKycVerificationForPostident</p> <p>startKycVerificationForPostident</p> <p>Not available yet!</p> <pre><code>public func startKycVerificationForPostident() throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#newcaseidresponse","title":"NewCaseIdResponse","text":"RustJSON <pre><code>pub struct NewCaseIdResponse {\n    /// New Postident case id\n    pub case_id: String,\n    /// Case url\n    pub case_url: String,\n}\n</code></pre> <pre><code>{\n    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"case_id\": {\n            \"type\": \"string\",\n            \"description\": \"New Postident case id\"\n        },\n        \"case_url\": {\n            \"type\": \"string\",\n            \"description\": \"Case url\"\n        }\n    },\n    \"required\": [\"case_id\", \"case_url\"]\n}\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#get-case-details-for-postident","title":"Get case details for postident","text":"Method Arguments Returns Dependencies Level Repeat Get case details for postident Returns an object <code>CaseDetailsResponse</code> if successful. User initialization Usage Application RustJavaTypescriptSwift <p>get_kyc_details_for_postident</p> <p>getKycDetailsForPostident</p> <p>getKycDetailsForPostident</p> <p>Not available yet!</p> <pre><code>public func getKycDetailsForPostident() throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#casedetailsresponse","title":"CaseDetailsResponse","text":"RustJSON <pre><code>pub struct CaseDetailsResponse {\n    pub case_id: String,\n    pub archived: bool,\n    pub status: String,\n}\n</code></pre> <pre><code>    {\n        \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n        \"type\": \"object\",\n        \"properties\": {\n            \"case_id\": {\n                \"type\": \"string\",\n                \"description\": \"The Postident case id\"\n            },\n            \"archived\": {\n                \"type\": \"boolean\",\n                \"description\": \"Whether the case is archived\"\n            },\n            \"status\": {\n                \"type\": \"string\",\n                \"description\": \"The status of the case\"\n            }\n        },\n        \"required\": [\"case_id\", \"archived\", \"status\"]\n    }\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#update-case-status-for-postident","title":"Update case status for postident","text":"Method Arguments Returns Dependencies Level Repeat Update case status for postident <code>case_id</code>: The ID of the case to update. User initialization Usage Application RustJavaTypescriptSwift <p>update_kyc_status_for_postident</p> <p>updateKycStatusForPostident</p> <p>updateKycStatusForPostident</p> <p>Not available yet!</p> <pre><code>public func updateKycStatusForPostident(case_id: String) throws\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#billing-account-functions","title":"Billing account functions","text":""},{"location":"SDK%20Reference/SDK%20API%20Reference/#create-a-new-billing-customer-account","title":"Create a new billing customer account","text":"Method Arguments Returns Dependencies Level Repeat Create a new account <code>country_code</code> - The country code for the customer. User initialization Usage User RustJavaTypescriptSwift <p>create_customer</p> <p>customerCreate</p> <p>createCustomer</p> <p>Not available yet!</p> <pre><code>public func createCustomer(country_code: String) throws\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#get-account-status","title":"Get account status","text":"Method Arguments Returns Dependencies Level Repeat Fetches the customer account and updates it internally User initialization Usage Application RustJavaTypescriptSwift <p>get_customer</p> <p>customerGet</p> <p>getCustomer</p> <p>Not available yet!</p> <pre><code>public func getCustomer() throws\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#get-user-preferred-network","title":"Get user preferred network","text":"Method Arguments Returns Dependencies Level Repeat Fetches the users preferred network Returns the network if successful or an empty value if no preferred network has been set. User initialization Usage Application RustJavaTypescriptSwift <p>get_preferred_network</p> <p>getPreferredNetwork</p> <p>getPreferredNetwork</p> <p>Not available yet!</p> <pre><code>public func getPreferredNetwork() throws -&gt; PreferredNetwork\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#set-user-preferred-network","title":"Set user preferred network","text":"Method Arguments Returns Dependencies Level Repeat Sets the users preferred network, or resets it if an empty value is provided. <code>network_id</code> - The preferred user network. Optional value. User initialization Usage Application RustJavaTypescriptSwift <p>set_preferred_network</p> <p>setPreferredNetwork</p> <p>setPreferredNetwork</p> <p>Not available yet!</p> <pre><code>public func setPreferredNetwork(network_id: String) throws\n</code></pre>"},{"location":"SDK%20Release%20Notes/Release%20Notes/","title":"Release Notes","text":""},{"location":"SDK%20Release%20Notes/Release%20Notes/#0121-2024-06-27","title":"[0.12.1] - 2024-06-27","text":""},{"location":"SDK%20Release%20Notes/Release%20Notes/#bug-fixes","title":"\ud83d\udc1b Bug Fixes","text":"<ul> <li>Api currency backwards compatibility</li> </ul>"},{"location":"SDK%20Release%20Notes/Release%20Notes/#0120-2024-06-19","title":"[0.12.0] - 2024-06-19","text":""},{"location":"SDK%20Release%20Notes/Release%20Notes/#features","title":"\ud83d\ude80 Features","text":"<ul> <li>Publish swift bindings package</li> <li>Add function to initialize a wallet from a mnemonic without stronghold</li> </ul>"},{"location":"SDK%20Release%20Notes/Release%20Notes/#bug-fixes_1","title":"\ud83d\udc1b Bug Fixes","text":"<ul> <li>Handle case id not found</li> <li>Update txs details query page param</li> </ul>"},{"location":"SDK%20Release%20Notes/Release%20Notes/#refactor","title":"\ud83d\ude9c Refactor","text":"<ul> <li>Seprate create_new_wallet from init_wallet</li> <li>(sdk) Split viviswap with feature flags</li> <li>Adding xml for generating pom and setting xml files</li> </ul>"},{"location":"SDK%20Release%20Notes/Release%20Notes/#documentation","title":"\ud83d\udcda Documentation","text":"<ul> <li>Update transactions validator docs</li> <li>Update kyc service docs</li> <li>Update user data service docs</li> <li>Update postident service docs</li> <li>Update webhook service docs</li> <li>Update main readme</li> </ul>"},{"location":"SDK%20Release%20Notes/Release%20Notes/#testing","title":"\ud83e\uddea Testing","text":"<ul> <li>Add tests for the webhook-aggregator</li> </ul>"},{"location":"SDK%20Release%20Notes/Release%20Notes/#miscellaneous-tasks","title":"\u2699\ufe0f Miscellaneous Tasks","text":"<ul> <li>Add commit sha for android sdk version</li> <li>(docs) Generate changelog from conventional commits</li> <li>Add testing crate</li> <li>Added deploy for wasm web target</li> <li>Bump <code>neon</code> to 1.0.0 for nodejs</li> <li>Bump version to 1.3.2 for dev container added kubectl and k9s</li> <li>Update pipeline to cache only on cargo-check push</li> <li>Updating toml files storing dependency in alphabetically sorted order</li> <li>Use rules of upstream pipeline</li> <li>(release) Bump version to 0.12</li> <li>(test) Fix conflicting tx using different account for test</li> </ul>"},{"location":"SDK%20Release%20Notes/Release%20Notes/#0110-2024-08-06","title":"[0.11.0] - 2024-08-06","text":""},{"location":"SDK%20Release%20Notes/Release%20Notes/#features_1","title":"\ud83d\ude80 Features","text":"<ul> <li>Allow multiple DLT nodes in SDK config</li> <li>Publish android SDK to Jfrog MVN</li> <li>Use array and Option in JNI bindings</li> </ul>"},{"location":"SDK%20Release%20Notes/Release%20Notes/#bug-fixes_2","title":"\ud83d\udc1b Bug Fixes","text":"<ul> <li>Admin service - add proper JSON format handling for send_event command</li> <li>Satoshi not kyc verified issue</li> <li>Don't return error when block does not have transaction payload</li> <li>Added resiliency against dapr when starting services</li> </ul>"},{"location":"SDK%20Release%20Notes/Release%20Notes/#refactor_1","title":"\ud83d\ude9c Refactor","text":"<ul> <li>Move errors from common crate into services</li> <li>Remove duplicate client implementations from common</li> <li>Replace TxCreated event with grpc call</li> </ul>"},{"location":"SDK%20Release%20Notes/Release%20Notes/#miscellaneous-tasks_1","title":"\u2699\ufe0f Miscellaneous Tasks","text":"<ul> <li>Update opentelemetry</li> </ul>"},{"location":"SDK%20Release%20Notes/Release%20Notes/#v0104","title":"[v0.10.4]","text":"<ul> <li>Added <code>get_wallet_transaction_list</code> - Returns the list of transactions of wallet by taking page and page size as a parameter.</li> <li>Added <code>get_wallet_transaction</code> - Returns the detailed report of particular transaction by taking transaction id as a parameter.</li> </ul>"},{"location":"SDK%20Release%20Notes/Release%20Notes/#v0100","title":"[v0.10.0]","text":"<ul> <li>The objects returned by <code>getTxList</code> now also include the exchange rate used for each transaction in the new field \"course\"</li> <li>Pagination of <code>getTxList</code> now works correctly.</li> <li>The functions <code>setCurrency</code> (introduced in v0.9.0), <code>getSwapList</code> and <code>getSwapDetails</code> (introduced in v0.8.2) had issues with the binding due to naming and could not be called from android, that has now been fixed and the functions are callable as intended.</li> <li>Added a check so that a transaction cannot be committed until it is marked as \u201cValid\u201d by the backend. This partially fixes the issue with being able to give more compliments than the daily limit.</li> </ul>"},{"location":"SDK%20Release%20Notes/Release%20Notes/#v090","title":"[v0.9.0]","text":"<ul> <li>Added new function <code>setCurrency</code>. From this version, this method will handle(setNodeUrl, setCoinType, setBech32Hrp) operations. For this reason those methods have been removed.</li> <li>Added new function `deleteUser. This method will allow a user to request to delete all of his data.</li> </ul>"},{"location":"SDK%20Release%20Notes/Release%20Notes/#v080","title":"[v0.8.0]","text":"<ul> <li>Added <code>getSwapList</code>. Retrieves the list of all the swaps(viviswap orders) performed by a user</li> <li>Added <code>getSwapDetails</code>. Retrieves details for a specific swap(order in viviswap)</li> </ul>"},{"location":"SDK%20Release%20Notes/Release%20Notes/#v073","title":"[v0.7.3]","text":"<ul> <li>Updated <code>get_iban</code> function. It now gives is_verified flag to show if the IBAN is verified by viviswap or not.</li> <li>The <code>createPurchaseRequest</code> function now requires the string literal \"CLIK\" as the string value in parameter <code>purchase_type</code> for compliments instead of \"COMPLIMENT\".</li> <li>Improved balance function internally to find hidden balances.</li> </ul>"},{"location":"SDK%20Release%20Notes/Release%20Notes/#v071","title":"[v0.7.1]","text":"<ul> <li>Viviswap onboarding stabilized</li> <li>Production environment auth provider string was fixed (cawaenaprod \u2192 cawaena)</li> <li><code>UpdateIBAN</code> method now deletes old IBAN and inserts the new one, so that the old IBAN can be re-used on other accounts</li> </ul>"},{"location":"SDK%20Release%20Notes/Release%20Notes/#v070","title":"[v0.7.0]","text":"<ul> <li>Added new function <code>updateCustomer</code> which updates or creates a new customer account for billing. It requires the two-character  country code of the user, which can be the same as the one used while doing a new user registration. Calling this function is mandatory before initializing wallet. The list of valid/legally allowed country codes will be given to the team before go-live.</li> <li>Modified the function createPurchaseRequest. It now requires three more parameters: <code>product_hash</code>, <code>app_data</code> (may be empty but can be used to store additional data of the image like thumbnail URL etc\u2026), <code>purchase_type</code> (Required currently and should be set to the constant value \u201cCOMPLIMENT\u201d)</li> <li><code>getBalance</code> is now modified internally. It performs claiming of dust outputs, so that micro-transactions and locked outputs do not get lost. if not claimed. This feature is only internal to the crypto-currency and has no impact on the UX/UI.</li> <li>QA and staging environment now use SMR mainnet. Getting tokens now happens via either purchase from viviswap or transfer of existing SMR from own wallet-</li> <li>Webhook notifications can now be encrypted.</li> </ul>"},{"location":"SDK%20Release%20Notes/Release%20Notes/#v064","title":"[v0.6.4]","text":"<ul> <li>Added new function <code>getTxList</code> which gives list of purchases and supports pagination. It gives the transaction list of all the transaction sent and received. If the value of the \u201creceiver\u201d is same as the username, the transaction was received, if different, then the transaction was sent.</li> </ul>"},{"location":"SDK%20Release%20Notes/Release%20Notes/#v063","title":"[v0.6.3]","text":"<ul> <li>Added new optional function <code>setSdkEnv</code> which sets up the environment correctly according to predefined values, instead of setting up config individually. Individual config settings are still possible.</li> <li>Fixed issues related to compliments not working</li> <li>Fixed reported issues in capacitor plugin wrapper methods</li> <li>Staging environment now uses SMR mainnet. Getting tokens now happens via either purchase from viviswap or transfer of existing SMR from own wallet.</li> <li>The IOTA cryptocurrency is no longer MIOTA. Renamed to IOTA overall</li> </ul>"},{"location":"SDK%20Release%20Notes/Release%20Notes/#v062","title":"[v0.6.2]","text":"<ul> <li>Modified <code>createDepositWithViviswap</code> function to accept no arguments any more.</li> <li>Modified <code>createWithdrawWithViviswap</code> requirements</li> </ul>"},{"location":"SDK%20Release%20Notes/Release%20Notes/#v061","title":"[v0.6.1]","text":"<ul> <li>Modified <code>initLogger</code> function. Now no parameters are required. It however requires at least <code>setPathPrefix</code> and <code>setLogLevel</code>. Now returns error if logger cannot be initialized.</li> <li>Added <code>createViviswapDetail</code> function needed to perform withdrawals. It does not take any parameters.</li> <li>Modified <code>createWithdrawalWithViviswap</code> to now accept pin. If a pin is given, it tries to automatically perform withdrawal and also provides details for withdrawal. If no pin is given, it will just create a detail (address and an id) for manual withdrawal.</li> <li>Fixed issues with deposit and withdrawal at viviswap</li> </ul>"},{"location":"SDK%20Release%20Notes/Release%20Notes/#v060","title":"[v0.6.0]","text":"<ul> <li>Added two new configuration settings <code>setCoinType</code> and <code>setBech32Hrp</code> which are now mandatory.</li> <li>Added helper function <code>validateConfig</code> for checking if configuration is correct. Currently it performs only syntactical validation and not semantical.</li> <li>Modified viviswap deposit and withdraw functions to now use the <code>coin type</code> set in the config to correctly create payment details.</li> <li>Added <code>getExchangeRate</code> function to fetch the latest exchange rate. The exchange rate considers the <code>coin type</code> set in the config with EUR for the course.</li> <li>Sdk will support MIOTA along with SMR after stardust upgrade on Mainnet (04.10.2023)</li> </ul>"},{"location":"SDK%20Release%20Notes/Release%20Notes/#v052","title":"[v0.5.2]","text":"<ul> <li>Fixed issue in swift code and iOS bindings to make error responses exact to android bindings</li> <li>Migrated to iota-sdk from now deprecated wallet.rs</li> </ul>"},{"location":"SDK%20Release%20Notes/Release%20Notes/#v050","title":"[v0.5.0]","text":"<ul> <li>Switched to SMR wallet. No changes in the SDK interface/functions</li> <li>Using JammDB instead of RocksDB to resolve issues with iOS SDK</li> </ul>"},{"location":"SDK%20Release%20Notes/Release%20Notes/#v040","title":"[v0.4.0]","text":"<ul> <li>The functions <code>setAuthProvider</code>, <code>setPathPrefix</code>, <code>setBackendUrl</code> are not optional anymore.</li> <li>Switched to IOTA wallet. No change in the SDK interface/functions.</li> <li>Added new function setNodeUrl to set the IOTA Node URL (can be used with Mainnet as well)</li> <li>iOS SDK Class now 1-to-1 with Java SDK Class definition.</li> </ul>"},{"location":"SDK%20Release%20Notes/Release%20Notes/#v030","title":"[v0.3.0]","text":"<ul> <li>Added viviswap functions for updating IBAN, creating deposit and withdrawal details</li> <li>Fixed a bug where user IOTA address was not getting updated in backend. This lead to failure in purchaseRequest flow. This is now fixed and it requires that all KYC verified users at least call <code>generateNewIotaReceiverAddress</code> before receiving and sending compliments.</li> <li>iOS now gives similar error descriptions to android</li> <li>Wallet backup and delete functions now end gracefully by dropping all open handles.</li> <li>Swift Plugin is now functionally same to Java.</li> </ul>"},{"location":"javadoc/legal/jquery/","title":"Jquery","text":""},{"location":"javadoc/legal/jquery/#jquery-v371","title":"jQuery v3.7.1","text":""},{"location":"javadoc/legal/jquery/#jquery-license","title":"jQuery License","text":"<pre><code>jQuery v 3.7.1\nCopyright OpenJS Foundation and other contributors, https://openjsf.org/\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n</code></pre>"},{"location":"javadoc/legal/jqueryUI/","title":"jqueryUI","text":""},{"location":"javadoc/legal/jqueryUI/#jquery-ui-v1132","title":"jQuery UI v1.13.2","text":""},{"location":"javadoc/legal/jqueryUI/#jquery-ui-license","title":"jQuery UI License","text":"<pre><code>Copyright jQuery Foundation and other contributors, https://jquery.org/\n\nThis software consists of voluntary contributions made by many\nindividuals. For exact contribution history, see the revision history\navailable at https://github.com/jquery/jquery-ui\n\nThe following license applies to all parts of this software except as\ndocumented below:\n\n====\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n====\n\nCopyright and related rights for sample code are waived via CC0. Sample\ncode is defined as all source code contained within the demos directory.\n\nCC0: http://creativecommons.org/publicdomain/zero/1.0/\n\n====\n\nAll files located in the node_modules and external directories are\nexternally maintained libraries used by this software which have their\nown licenses; we recommend you read them, as their terms may differ from\nthe terms above.\n</code></pre>"},{"location":"rust-docs/doc/static.files/SourceSerif4-LICENSE-3bb119e13b1258b7/","title":"SourceSerif4 LICENSE 3bb119e13b1258b7","text":"<p>Copyright 2014-2021 Adobe (http://www.adobe.com/), with Reserved Font Name 'Source'. All Rights Reserved. Source is a trademark of Adobe in the United States and/or other countries. Copyright 2014 - 2023 Adobe (http://www.adobe.com/), with Reserved Font Name \u2018Source\u2019. All Rights Reserved. Source is a trademark of Adobe in the United States and/or other countries.</p> <p>This Font Software is licensed under the SIL Open Font License, Version 1.1.</p> <p>This license is copied below, and is also available with a FAQ at: http://scripts.sil.org/OFL</p>"},{"location":"rust-docs/doc/static.files/SourceSerif4-LICENSE-3bb119e13b1258b7/#sil-open-font-license-version-11-26-february-2007","title":"SIL OPEN FONT LICENSE Version 1.1 - 26 February 2007","text":"<p>PREAMBLE The goals of the Open Font License (OFL) are to stimulate worldwide development of collaborative font projects, to support the font creation efforts of academic and linguistic communities, and to provide a free and open framework in which fonts may be shared and improved in partnership with others.</p> <p>The OFL allows the licensed fonts to be used, studied, modified and redistributed freely as long as they are not sold by themselves. The fonts, including any derivative works, can be bundled, embedded, redistributed and/or sold with any software provided that any reserved names are not used by derivative works. The fonts and derivatives, however, cannot be released under any other type of license. The requirement for fonts to remain under this license does not apply to any document created using the fonts or their derivatives.</p> <p>DEFINITIONS \"Font Software\" refers to the set of files released by the Copyright Holder(s) under this license and clearly marked as such. This may include source files, build scripts and documentation.</p> <p>\"Reserved Font Name\" refers to any names specified as such after the copyright statement(s).</p> <p>\"Original Version\" refers to the collection of Font Software components as distributed by the Copyright Holder(s).</p> <p>\"Modified Version\" refers to any derivative made by adding to, deleting, or substituting -- in part or in whole -- any of the components of the Original Version, by changing formats or by porting the Font Software to a new environment.</p> <p>\"Author\" refers to any designer, engineer, programmer, technical writer or other person who contributed to the Font Software.</p> <p>PERMISSION &amp; CONDITIONS Permission is hereby granted, free of charge, to any person obtaining a copy of the Font Software, to use, study, copy, merge, embed, modify, redistribute, and sell modified and unmodified copies of the Font Software, subject to the following conditions:</p> <p>1) Neither the Font Software nor any of its individual components, in Original or Modified Versions, may be sold by itself.</p> <p>2) Original or Modified Versions of the Font Software may be bundled, redistributed and/or sold with any software, provided that each copy contains the above copyright notice and this license. These can be included either as stand-alone text files, human-readable headers or in the appropriate machine-readable metadata fields within text or binary files as long as those fields can be easily viewed by the user.</p> <p>3) No Modified Version of the Font Software may use the Reserved Font Name(s) unless explicit written permission is granted by the corresponding Copyright Holder. This restriction only applies to the primary font name as presented to the users.</p> <p>4) The name(s) of the Copyright Holder(s) or the Author(s) of the Font Software shall not be used to promote, endorse or advertise any Modified Version, except to acknowledge the contribution(s) of the Copyright Holder(s) and the Author(s) or with their explicit written permission.</p> <p>5) The Font Software, modified or unmodified, in part or in whole, must be distributed entirely under this license, and must not be distributed under any other license. The requirement for fonts to remain under this license does not apply to any document created using the Font Software.</p> <p>TERMINATION This license becomes null and void if any of the above conditions are not met.</p> <p>DISCLAIMER THE FONT SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM OTHER DEALINGS IN THE FONT SOFTWARE.</p>"}]}