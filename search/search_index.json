{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Welcome to the Cawaena SDK documentation. This comprehensive guide is designed to provide you with all the information you need to install and use the Cawaena SDK effectively.</p> <p>The Cawaena SDK provides the logic for interacting with the Cawaena backend correctly. The SDK plans to help developers with a quicker, safer and easier on-boarding in the web3 world, while using the Cawaena infrastructure to support various use-cases around data monetization.</p> <p>The SDK is divided in various modules which come together to ensure an easy and safe way to incorporate the SDK in the application.</p> <p>For ease of integration, the SDK also generates bindings in various languages for various platforms, especially for mobile platforms, to provide easy integration with native and hybrid mobile app development frameworks.</p> <p>This documentation is primarily intended for developers who are integrating the Cawaena SDK into their applications. It provides a comprehensive guide to installing and using the SDK, with a focus on practical examples and clear, concise explanations.</p> <p>The documentation is divided into following sections. Simply choose one and get started!</p> <ul> <li> <p> Features</p> <p>Know the features before using Cawaena in your applications for a better product-market fit.</p> <p> Architecture</p> </li> <li> <p> Set up the SDK</p> <p>This section provides step-by-step instructions on how to install the Cawaena SDK in your development environment.</p> <p> Install</p> </li> <li> <p> Configuring the SDK</p> <p>Here, you'll find information on how to use the SDK's basic features and configure it correctly, complete with code snippets and examples to help you get started.</p> <p> Configure</p> </li> <li> <p> SDK Modules</p> <p>Once you're comfortable with the basics and configuration, this section delves into the core SDK module functions around user and wallet management, kyc onboarding processes, integration with exchanges, helping you leverage the full power of the Cawaena SDK.</p> <p> Modules</p> </li> <li> <p> API Reference</p> <p>This section provides a detailed overview of the SDK's API, including descriptions of the different functions, their return values, and the error types you might encounter.</p> <p> Reference</p> </li> <li> <p> Release Notes</p> <p>Stay up-to-date with the latest changes to the Cawaena SDK. This section provides information about the changes in each release.</p> <p> Releases</p> </li> <li> <p> SDK Examples</p> <p>This section provides a basic overview of the SDK internal structure and explains the different modules and their functions intrinsically.</p> <p> Examples</p> </li> <li> <p> SDK Internals</p> <p>This section provides a basic overview of the SDK internal structure and explains the different modules and their functions intrinsically.</p> <p> Internals</p> </li> </ul> <p>We hope this documentation serves as a valuable resource to explore the capabilities of the Cawaena SDK.</p> <p>Made with  by Team Lobster </p>"},{"location":"Choosing%20Cawaena/Architecture/","title":"Architecture","text":""},{"location":"Choosing%20Cawaena/Architecture/#overview","title":"Overview","text":"<p>The architecture shows the involved participants and explains how the integration of a client application works with .</p>"},{"location":"Choosing%20Cawaena/Architecture/#services","title":"Services","text":"<p>The Cawaena services are a bundle of services, which work together, using various infrastructure components like databases, message queues, caches, etc... to provide the different features as listed here</p> <p>These services are maintained, tested and updated by the development team behind this project. The source code for the same is maintained in a closed source repository with the development team.</p>"},{"location":"Choosing%20Cawaena/Architecture/#web-portal","title":"Web portal","text":"<p>The developers trying to integrate the Cawaena SaaS product would typically access the web portal to register themselves. After the registration, the developer can requisition a fresh new instance for the application from Cawaena through this portal.</p> <p>Additionally, the web portal allows the developers to configure their instance according to their application needs. It can be also used to undertake some application specific settings and modify them as well. For example, setting the identity provider urls and access points, which is owned by the application but may be used by Cawaena to authenticate users or setting a webhook receiver endpoint, where a notification server is already listening to Cawaena internal events, to push notifications to the end-user devices, etc...</p> <p>Currently, on the first request, a staging environment of a fresh Cawaena services instance is deployed. This allows the developers to test their application flow and integration with Cawaena before moving to production. Requesting a production instance is an extra step which needs to be done additionally. This helps the developers to fix a version for their production, while they continue testing new features and releases from Cawaena team on the staging environment, before requesting to update to production.</p> <p>The infrastructure deploys in a private cloud hosted in the european data center. Deployments in client infrastructure and public clouds are currently not possible, however will be considered in the future, for example with client-owned kubernetes cluster or Azure/AWS depolyments. The Cawaena services are coded in software to be fully platform agnostic. Hence, the deployment architecture does not affect the features and working of the services.</p>"},{"location":"Choosing%20Cawaena/Architecture/#integration","title":"Integration","text":"<p>The integration can occur for the client in three different ways:</p> <ol> <li> <p>REST API: A platform-agnostic, robust API to interact with the  features and a modern and sleek documentation.</p> <p>Within this integration, the Cawaena services are exposed via a REST API. The client developers can directly connect to these services using the Open API specification for the services. A drawback for this approach could be that the requirement on the various flows as expected by the Cawaena services needs to be well understood from the documentation. This approach also works only with custodial wallets, which might increase costs for end-users, as compared to a self-custody wallet.</p> </li> <li> <p>SDK: A variety of multi-stack SDKs working together to allow seamless in-app integration with code examples and instructions on best-practices.</p> <p>Here, the client developers can download our SDKs and even modify their behaviour according to their own needs. These SDKs are described in detail and the source code is kept open to allow maximum benefit during integration. Using the SDK gives the advantage to the developers in a way that, the SDK does all the heavy lifting in terms of executing the flows together with the Cawaena service whilst ensuring secure self-custody wallets and user management on end-user devices. This takes away a significant amount of integration effort and allows for a quick time-to-market without needing to understand all particular nuances of Cawaena services.</p> </li> <li> <p>White Label App: A multi-platform white label application with intuitive interfaces for low time to market with fully compliant flows to ensure highest user satisfaction.</p> <p>As the white label application builds on top of the SDK, it provides the client developers with complete UI/UX for maximum integration with minimal effort. The only thing the client developers would need is to adjust the corporate identiy, build the application and ship it to their end-users. The white label app ensures that all the flows are correctly executed, with the most lucid user experience from on-boarding to using the features of Cawaena. Being open source again, the white label application can also be customized for own needs and making an entirely new application would be like simply adding a few new layouts.</p> </li> </ol>"},{"location":"Choosing%20Cawaena/Features/","title":"Features","text":"<p>allows end-users to perform in-app payments to other end-users for services and products offered through the application.</p> <p>solves the problem of P2P payments between end-users, by not becoming a gate-keeper, but a path-finder between consumers for digital data, services and real-world commodities</p> <ul> <li> <p>Complete Wallet Management with MFA (Multi-factor approvals)</p> <p>For end-users with custodial and non-custodial cryptocurrency wallets without the need of additional approval from regulatory authorities</p> </li> <li> <p>KYC onboarding</p> <p>A completed on-boarding with a full-KYC without ever needing to leave the application and jumping in different browsers.</p> </li> <li> <p>Fiat/Cryptocurrency integration</p> <p>Allows loading cryptocurrency wallets from FIAT bank accounts and vice versa all within the application. Hassle-free and no copy pasting strange character addresses in even stranger browser apps.</p> </li> <li> <p>Multi-user app</p> <p>One end-user or multiple end-users on a single device? We have you covered. Every user on the same end-device can work with the highest assurance that their data cannot be seen by anyone else except themselves.</p> </li> <li> <p>Seamless identity integration</p> <p>We integrate directly with our existing identity providers, to avoid the confusion of re-registration and doing the onboarding for the users again.</p> </li> <li> <p>Integrated invoice and receipt</p> <p>The users need not worry for being conform with the tax authorities. We generate the legally exact receipts and invoices for every user automatically.</p> </li> <li> <p>Multi-platform compatible</p> <p>The solution is provided as an SDK (Software Development Kit) for major application platforms like Android, iOS and Web for developer-easy integration.</p> </li> <li> <p>European Data Center</p> <p>All your data stays in EU and never leaves, replicated or sold to anyone. A fully (really!) GDPR compliant solution with no non-EU entities lurking in the shadows of privacy policy.</p> </li> <li> <p>Cyber-secure</p> <p>A periodic vulnerability assessment and penetration testing ensures that the system is robust against attacks and leaks.</p> </li> </ul>"},{"location":"Choosing%20Cawaena/Features/#use-cases","title":"Use-cases","text":"<p>With Cawaena, you can do a lot more than the listed use-cases below. The use-cases just simply show the tip of the iceberg, how you can benefit from integrating Cawaena in your applications:</p> <ol> <li>Data-Marketplace for buying and selling sensor data, digital content or even NFTs.</li> <li>A simple cart checkout with multiple payment and currency options</li> <li>Artist remuneration directly in app for major events</li> <li>A DeFi dApp with a fully embedded wallet, without needing users to download and install shady plugins.</li> <li>Gaming exchanges for in-game artifacts and digital content with exclusive content mangement rights negotiated in real-time between end-users.</li> <li>Scam detection and regulated payments to health-care related products for the elderly</li> </ol>"},{"location":"Choosing%20Cawaena/Licensing/","title":"Licensing","text":""},{"location":"Choosing%20Cawaena/Licensing/#software-licensing-and-open-source","title":"Software licensing and open source","text":"<p>We are planning to make the SDK open source and start accepting contribution from the community.</p> <p>However, till we decide on the best way to move forward with various open source licensing options available, that might suit our needs as well as benefit the developer community, we are currently delivering the SDK under a strict license as shown on the footer of this website.</p>"},{"location":"Choosing%20Cawaena/Licensing/#license","title":"License","text":"<p> 2024 ETO GRUPPE TECHNOLOGIES GmbH, All rights reserved.</p>"},{"location":"Choosing%20Cawaena/Philosophy/","title":"Philosophy","text":"<p>The Cawaena project was started with a few basic principles and they are also the guiding values which will continue to motivate the team and all its contributors to work for this project.</p>"},{"location":"Choosing%20Cawaena/Philosophy/#core-principles","title":"Core principles","text":"<p>The following core principles summarize how the team looks at things differently:</p>"},{"location":"Choosing%20Cawaena/Philosophy/#self-realization","title":"Self-realization","text":"<p>Identify the problem: It is always important for us to identify the core problem on the technical front and approach it as an engineer with fixed boundary conditions. It is crucial to understand and realize the crux of a certain system to also get to the core of the underlying problem, rather than waiting for anyone else to explain to us their view of the system and problem.</p>"},{"location":"Choosing%20Cawaena/Philosophy/#awareness","title":"Awareness","text":"<p>Look for solutions: Look around at other people, who might have faced the same problem and look at the solutions they are using. Look at other solutions in totally different systems but with the same problems and see if they are a fit for your problem. Most of the times, the buck stops here and the problem is solved with a possible solution being discovered. But, we do care for one more core principle which influences entirely as to why certain solutions are not the best fits.</p>"},{"location":"Choosing%20Cawaena/Philosophy/#fairness","title":"Fairness","text":"<p>Is it allowed? Not just in terms of legal, but in terms of morality as well. It is very important to consider the sentiments of each and every human and especially their rights, when they interact with our systems. Legally speaking, there might be some grey areas, but morally there are plainly some things which we cannot just allow on principle. And mostly this is how we judge the solutions and the philosophies behind them, as how they would affect us and in turn our customers.</p>"},{"location":"Choosing%20Cawaena/Philosophy/#dexterity","title":"Dexterity","text":"<p>DIY: If there is no solution which is legally and morally correct, or no solution technically at all, then it becomes the time for us to get our hands dirty and dive in completely to solve the problem from its roots and come up with a solution that provides us a way out of the problem once and for all. Resources become no concern as the best available methods, processes and people get attracted to us when we approach a well-aware core problem with fairness also in focus.</p>"},{"location":"Choosing%20Cawaena/Philosophy/#community","title":"Community","text":"<p>One-for-all and all-for one: We strongly believe that we should be rewarded for what we do. And this is also sometimes a driver and motivation behind searching for solutions. In addition, we also equally strongly believe that we do not want to become gate-keepers but path-finders and light-bringers for others like us, searching for solutions in the dark. Putting back our efforts to the community, in a way which allows a beautiful, sustainable ecosystem to flourish makes complete sense, when we start contemplating that, the solutions would themselves never exist, if not for the base provided by the same thriving community.</p> <p>With these core principles guiding us, we just rinse and repeat at every opportunity that comes in-front of us either as a special request, challenge or self-discovered problems. We are affirmed more than once that this belief in the core principles has potential to rescue the world trapped under various gate-keepers to a truly decentralized and fair ecosystem.</p> <p>Hence, it does not come to us as a surprise that, all which we are building fits perfectly in the Web3 context, which also strives to unite over marginalizing or dividing people.</p>"},{"location":"Choosing%20Cawaena/Philosophy/#the-cawaena-story","title":"The Cawaena story","text":"<p>began exactly with the simplest of problems: How is it possible for a person to pay another person for goods and services offered on a platform in a way where the platform is not a gate-keeper?</p> <p>With this started our search for solutions and we concluded that there is no platform as such which respects their end-users and their rights like data protection, but rather tries to exploit as much as they can from their users.</p> <p>We started developing Cawaena and we realized that we actually are just using various solutions, which are already available in the community, but just presenting and connecting them in a way that makes it fair, legal and transparent.</p> <p>Taking guidance from our core principles, we have decided to go open source with our solution and give it to the community, not just to help develop it further with us but also use it everywhere, where they encountered gate-keepers. To employ it in a way which guarantees fairness and transparency to their end users, baked right in the solution.</p>"},{"location":"Choosing%20Cryptpay/Architecture/","title":"Architecture","text":""},{"location":"Choosing%20Cryptpay/Architecture/#overview","title":"Overview","text":"<p>The architecture shows the involved participants and explains how the integration of a client application works with Cawaena.</p>"},{"location":"Choosing%20Cryptpay/Architecture/#cawaena-services","title":"Cawaena Services","text":"<p>The Cawaena services are a bundle of services, which work together, using various infrastructure components like databases, message queues, caches, etc... to provide the different features as listed here</p> <p>These services are maintained, tested and updated by the development team behind this project. The source code for the same is maintained in a closed source repository with the development team.</p>"},{"location":"Choosing%20Cryptpay/Architecture/#web-portal","title":"Web portal","text":"<p>The developers trying to integrate the Cawaena SaaS product would typically access the web portal to register themselves. After the registration, the developer can requisition a fresh new instance for the application from Cawaena through this portal.</p> <p>Additionally, the web portal allows the developers to configure their instance according to their application needs. It can be also used to undertake some application specific settings and modify them as well. For example, setting the identity provider urls and access points, which is owned by the application but may be used by Cawaena to authenticate users or setting a webhook receiver endpoint, where a notification server is already listening to Cawaena internal events, to push notifications to the end-user devices, etc...</p> <p>Currently, on the first request, a staging environment of a fresh Cawaena services instance is deployed. This allows the developers to test their application flow and integration with Cawaena before moving to production. Requesting a production instance is an extra step which needs to be done additionally. This helps the developers to fix a version for their production, while they continue testing new features and releases from Cawaena team on the staging environment, before requesting to update to production.</p> <p>The infrastructure deploys in a private cloud hosted in the european data center. Deployments in client infrastructure and public clouds are currently not possible, however will be considered in the future, for example with client-owned kubernetes cluster or Azure/AWS depolyments. The Cawaena services are coded in software to be fully platform agnostic. Hence, the deployment architecture does not affect the features and working of the services.</p>"},{"location":"Choosing%20Cryptpay/Architecture/#integration","title":"Integration","text":"<p>The integration can occur for the client in three different ways:</p> <ol> <li> <p>REST API: A platform-agnostic, robust API to interact with the Cawaena features and a modern and sleek documentation.</p> <p>Within this integration, the Cawaena services are exposed via a REST API. The client developers can directly connect to these services using the Open API specification for the services. A drawback for this approach could be that the requirement on the various flows as expected by the Cawaena services needs to be well understood from the documentation. This approach also works only with custodial wallets, which might increase costs for end-users, as compared to a self-custody wallet.</p> </li> <li> <p>SDK: A variety of multi-stack SDKs working together to allow seamless in-app integration with code examples and instructions on best-practices.</p> <p>Here, the client developers can download our SDKs and even modify their behaviour according to their own needs. These SDKs are described in detail and the source code is kept open to allow maximum benefit during integration. Using the SDK gives the advantage to the developers in a way that, the SDK does all the heavy lifting in terms of executing the flows together with the Cawaena service whilst ensuring secure self-custody wallets and user management on end-user devices. This takes away a significant amount of integration effort and allows for a quick time-to-market without needing to understand all particular nuances of Cawaena services.</p> </li> <li> <p>White Label App: A multi-platform white label application with intuitive interfaces for low time to market with fully compliant flows to ensure highest user satisfaction.</p> <p>As the white label application builds on top of the SDK, it provides the client developers with complete UI/UX for maximum integration with minimal effort. The only thing the client developers would need is to adjust the corporate identiy, build the application and ship it to their end-users. The white label app ensures that all the flows are correctly executed, with the most lucid user experience from on-boarding to using the features of Cawaena. Being open source again, the white label application can also be customized for own needs and making an entirely new application would be like simply adding a few new layouts.</p> </li> </ol>"},{"location":"Choosing%20Cryptpay/Architecture/#sdk-internals","title":"SDK Internals","text":"<p>The Cawaena SDK is built in <code>Rust</code>. It is primarily an implementation of the various functionalities for managing users, wallets, on-boarding of users through KYC (Know Your Customer) processes, payment methods and listing usage information.</p> <p>The SDK was designed to support the <code>Cellpic</code> application. It is a social media application, which allows monetization of user-generated content. However, in the same principle, any digital data, given that it is authentic and its origin can be verified, can be monetized using the Cawaena ecosystem, which includes the Cawaena infrastructure and the sdk.</p> <p>The big picture behind Cawaena is a data marketplace. Data processing, silo management and search engine features have been excluded by design from Cawaena to make it a minimal ecosystem for monetization.</p>"},{"location":"Choosing%20Cryptpay/Architecture/#overview-of-the-sdk-functional-components","title":"Overview of the SDK functional components","text":"<p>The figure below shows the functional component diagram of the SDK. The core of the SDK is a web3 hot-wallet. This wallet is used to store assets on the local machine running the application built with the SDK. The supporting components like the backend API, user state management and access control logic work for improving ease of use for the end user as well as ensuring correct process flow and state transitions between the Cawaena infrastructure and application.</p> <p>The binding layer is just a simple 1-to-1 wrapper around the SDK functionalities. This just exports the existing business logic implemented in the SDK in rust to other programming stacks to avoid re-implementation as well as guarantee memory safety natively in code.</p> <p>The access control section at the bottom shows the input parameters needed from the user/application to authenticate itself against the SDK. For the one-time on-boarding in addition to the <code>pin</code> and <code>access_token</code> the <code>username</code> and <code>password</code> is also needed. For regular usage, the <code>pin</code>, whenever required and <code>access_token</code> is required to ensure smooth handling of operations, including internal function calls to the Cawaena infrastructure and the wallet.</p> <pre><code>+-------------------------------------------------------------------------------+\n|                                                                               |\n|   +-----------------------------------------------------------------------+   |\n|   |                                                                       |   |\n|   |                                                                       |   |\n|   |   +---------------------------------------------+    +--------------+ |   |\n|   |   |                                             |    |              | |   |\n|   |   |   +-------------------------------------+   |    |   Backend    | |   |\n|   |   |   |                                     |   |    |   API        | |   |\n|   |   |   |     +------------------------+      |   |    |              | |   |\n|   |   |   |     |                        |      |   |    +--------------+ |   |\n|   |   |   |     |                        |      |   |                     |   |\n|   |   |   |     |                        |      |   |                     |   |\n|   |   |   |     |       IOTA SDK         |      |   |    +--------------+ |   |\n|   |   |   |     |                        |      |   |    |              | |   |\n|   |   |   |     |       Stronghold       |      |   |    | User         | |   |\n|   |   |   |     |         wallet         |      |   |    | State        | |   |\n|   |   |   |     |         manager        |      |   |    | Management   | |   |\n|   |   |   |     |                        |      |   |    +--------------+ |   |\n|   |   |   |     +------------------------+      |   |                     |   |\n|   |   |   |                                     |   |                     |   |\n|   |   |   |           Wallet Manager            |   |    +--------------+ |   |\n|   |   |   +-------------------------------------+   |    |              | |   |\n|   |   |                                             |    |   Access     | |   |\n|   |   |                Wallet User                  |    |   Control    | |   |\n|   |   |                                             |    |   Logic      | |   |\n|   |   +---------------------------------------------+    +--------------+ |   |\n|   |                         SDK                                           |   |\n|   +-----------------------------------------------------------------------+   |\n|                           Bindings                                            |\n|                                                                               |\n|                                                                               |\n+--+--------------------------------------+------+----------------------------+-+\n   |      Onboarding authentication       |      |   Usage authentication     |\n   |                                      |      |                            |\n   +--^---------^-------^---------^-------+      +-----^-----------^----------+\n      |         |       |         |                    |           |\n      |         |       |         |                    |           |\n      |         |       |         |                    |           |\n   Username  Password  Pin    Access token            Pin      Access token\n</code></pre>"},{"location":"Choosing%20Cryptpay/Features/","title":"Features","text":"<p>Cawaena allows end-users to perform in-app payments to other end-users for services and products offered through the application.</p> <p>Cawaena solves the problem of P2P payments between end-users, by not becoming a gate-keeper, but a path-finder between consumers for digital data, services and real-world commodities</p> <ul> <li> <p>Complete Wallet Management with MFA (Multi-factor approvals)</p> <p>For end-users with custodial and non-custodial cryptocurrency wallets without the need of additional approval from regulatory authorities</p> </li> <li> <p>KYC onboarding</p> <p>A completed on-boarding with a full-KYC without ever needing to leave the application and jumping in different browsers.</p> </li> <li> <p>Fiat/Cryptocurrency integration</p> <p>Allows loading cryptocurrency wallets from FIAT bank accounts and vice versa all within the application. Hassle-free and no copy pasting strange character addresses in even stranger browser apps.</p> </li> <li> <p>Multi-user app</p> <p>One end-user or multiple end-users on a single device? We have you covered. Every user on the same end-device can work with the highest assurance that their data cannot be seen by anyone else except themselves.</p> </li> <li> <p>Seamless identity integration</p> <p>We integrate directly with our existing identity providers, to avoid the confusion of re-registration and doing the onboarding for the users again.</p> </li> <li> <p>Integrated invoice and receipt</p> <p>The users need not worry for being conform with the tax authorities. We generate the legally exact receipts and invoices for every user automatically.</p> </li> <li> <p>Multi-platform compatible</p> <p>The solution is provided as an SDK (Software Development Kit) for major application platforms like Android, iOS and Web for developer-easy integration.</p> </li> <li> <p>European Data Center</p> <p>All your data stays in EU and never leaves, replicated or sold to anyone. A fully (really!) GDPR compliant solution with no non-EU entities lurking in the shadows of privacy policy.</p> </li> <li> <p>Cyber-secure</p> <p>A periodic vulnerability assessment and penetration testing ensures that the system is robust against attacks and leaks.</p> </li> </ul>"},{"location":"Choosing%20Cryptpay/Features/#use-cases","title":"Use-cases","text":"<p>With Cawaena, you can do a lot more than the listed use-cases below. The use-cases just simply show the tip of the iceberg, how you can benefit from integrating Cawaena in your applications:</p> <ol> <li>Data-Marketplace for buying and selling sensor data, digital content or even NFTs.</li> <li>A simple cart checkout with multiple payment and currency options</li> <li>Artist remuneration directly in app for major events</li> <li>A DeFi dApp with a fully embedded wallet, without needing users to download and install shady plugins.</li> <li>Gaming exchanges for in-game artifacts and digital content with exclusive content mangement rights negotiated in real-time between end-users.</li> <li>Scam detection and regulated payments to health-care related products for the elderly</li> </ol>"},{"location":"Choosing%20Cryptpay/Licensing/","title":"Licensing","text":""},{"location":"Choosing%20Cryptpay/Licensing/#software-licensing-and-open-source","title":"Software licensing and open source","text":"<p>We are planning to make the SDK open source and start accepting contribution from the community.</p> <p>However, till we decide on the best way to move forward with various open source licensing options available, that might suit our needs as well as benefit the developer community, we are currently delivering the SDK under a strict license as shown on the footer of this website.</p>"},{"location":"Choosing%20Cryptpay/Licensing/#license","title":"License","text":"<p> 2024 ETO GRUPPE TECHNOLOGIES GmbH, All rights reserved.</p>"},{"location":"Choosing%20Cryptpay/Philosophy/","title":"Philosophy","text":"<p>The Cawaena project was started with a few basic principles and they are also the guiding values which will continue to motivate the team and all its contributors to work for this project.</p>"},{"location":"Choosing%20Cryptpay/Philosophy/#core-principles","title":"Core principles","text":"<p>The following core principles summarize how the team looks at things differently:</p>"},{"location":"Choosing%20Cryptpay/Philosophy/#self-realization","title":"Self-realization","text":"<p>Identify the problem: It is always important for us to identify the core problem on the technical front and approach it as an engineer with fixed boundary conditions. It is crucial to understand and realize the crux of a certain system to also get to the core of the underlying problem, rather than waiting for anyone else to explain to us their view of the system and problem.</p>"},{"location":"Choosing%20Cryptpay/Philosophy/#awareness","title":"Awareness","text":"<p>Look for solutions: Look around at other people, who might have faced the same problem and look at the solutions they are using. Look at other solutions in totally different systems but with the same problems and see if they are a fit for your problem. Most of the times, the buck stops here and the problem is solved with a possible solution being discovered. But, we do care for one more core principle which influences entirely as to why certain solutions are not the best fits.</p>"},{"location":"Choosing%20Cryptpay/Philosophy/#fairness","title":"Fairness","text":"<p>Is it allowed? Not just in terms of legal, but in terms of morality as well. It is very important to consider the sentiments of each and every human and especially their rights, when they interact with our systems. Legally speaking, there might be some grey areas, but morally there are plainly some things which we cannot just allow on principle. And mostly this is how we judge the solutions and the philosophies behind them, as how they would affect us and in turn our customers.</p>"},{"location":"Choosing%20Cryptpay/Philosophy/#dexterity","title":"Dexterity","text":"<p>DIY: If there is no solution which is legally and morally correct, or no solution technically at all, then it becomes the time for us to get our hands dirty and dive in completely to solve the problem from its roots and come up with a solution that provides us a way out of the problem once and for all. Resources become no concern as the best available methods, processes and people get attracted to us when we approach a well-aware core problem with fairness also in focus.</p>"},{"location":"Choosing%20Cryptpay/Philosophy/#community","title":"Community","text":"<p>One-for-all and all-for one: We strongly believe that we should be rewarded for what we do. And this is also sometimes a driver and motivation behind searching for solutions. In addition, we also equally strongly believe that we do not want to become gate-keepers but path-finders and light-bringers for others like us, searching for solutions in the dark. Putting back our efforts to the community, in a way which allows a beautiful, sustainable ecosystem to flourish makes complete sense, when we start contemplating that, the solutions would themselves never exist, if not for the base provided by the same thriving community.</p> <p>With these core principles guiding us, we just rinse and repeat at every opportunity that comes in-front of us either as a special request, challenge or self-discovered problems. We are affirmed more than once that this belief in the core principles has potential to rescue the world trapped under various gate-keepers to a truly decentralized and fair ecosystem.</p> <p>Hence, it does not come to us as a surprise that, all which we are building fits perfectly in the Web3 context, which also strives to unite over marginalizing or dividing people.</p>"},{"location":"Choosing%20Cryptpay/Philosophy/#the-cawaena-story","title":"The Cawaena story","text":"<p>Cawaena began exactly with the simplest of problems: How is it possible for a person to pay another person for goods and services offered on a platform in a way where the platform is not a gate-keeper?</p> <p>With this started our search for solutions and we concluded that there is no platform as such which respects their end-users and their rights like data protection, but rather tries to exploit as much as they can from their users.</p> <p>We started developing Cawaena and we realized that we actually are just using various solutions, which are already available in the community, but just presenting and connecting them in a way that makes it fair, legal and transparent.</p> <p>Taking guidance from our core principles, we have decided to go open source with our solution and give it to the community, not just to help develop it further with us but also use it everywhere, where they encountered gate-keepers. To employ it in a way which guarantees fairness and transparency to their end users, baked right in the solution.</p>"},{"location":"Installing%20the%20SDK/Installation/","title":"Installation","text":"<p>For installing the SDK, follow the steps detailed for each ecosystem. Currently the SDK only supports the following languages/stacks:</p> <ul> <li>Java</li> <li>Swift (for iOS)</li> <li>JavaScript / TypeScript</li> </ul> <p>Further support for other languages &amp; ecosystems can be requested to the SDK team by contacting the maintainers of this document or reaching out directly to us @ ETO GRUPPE TECHNOLOGIES GmbH.</p> <p>The following languages are currently planned for support and would be part of upcoming release in the same order of sequence shown below:</p> <ul> <li>Rust</li> </ul>"},{"location":"Installing%20the%20SDK/JS_TS/","title":"Javascript/Typescript Installation","text":"<p>The JS/TS SDK is delivered as a <code>.tgz</code> compressed NPM package file, ready for inclusion into any project using a NPM compatible package manager. Currently, the package is designed for being compatible with popular bundlers such as <code>webpack</code> and <code>vite</code><sup>1</sup> , and comes with TypesScript type definitions as well as ergonomic JavaScript wrappers. These instructions assume that you already have a project setup using one of the supported bundlers.</p>"},{"location":"Installing%20the%20SDK/JS_TS/#installing-the-jsts-sdk","title":"Installing the JS/TS SDK","text":"<p>To install the WASM SDK, simply place the compressed file next to your project and use <code>npm</code>/<code>pnpm</code> to install it from your project directory (the one containing your <code>project.json</code> file):</p> <pre><code>npm install &lt;path-to-the-tgz-file&gt;\n</code></pre> <p>The package can then be used within your application like so (example using <code>webpack</code>):</p> <pre><code>import { CryptpaySdk, Environment, Level } from \"@eto/Cawaena-sdk-wasm\";\n\nconst sdk = await new CryptpaySdk();\nsdk.initLogger(Level.Info);\nawait sdk.setEnvironment(Environment.Development);\nawait sdk.validateConfig();\n</code></pre> <p>or using a named import:</p> <pre><code>import * as Cawaena from \"@eto/Cawaena-sdk-wasm\";\n\nconst sdk = new Cawaena.CryptpaySdk();\nsdk.initLogger(Cawaena.Level.Info);\nawait sdk.setEnvironment(Cawaena.Environment.Development);\nawait sdk.validateConfig();\n</code></pre> <p>See the API reference for more information about the available functions.</p>"},{"location":"Installing%20the%20SDK/JS_TS/#updating-the-jsts-sdk","title":"Updating the JS/TS SDK","text":"<p>Updating the SDK is simply replacing the file and performing the steps above again.</p>"},{"location":"Installing%20the%20SDK/JS_TS/#future-releases-of-the-jsts-sdk","title":"Future releases of the JS/TS SDK","text":"<p>Future releases of the SDK for JS/TS will be published to the NPM registry, for even easier installation.</p>"},{"location":"Installing%20the%20SDK/JS_TS/#minimum-supported-version","title":"Minimum supported version","text":"<p>The bindings have been tested to work with <code>webpack</code> v4.47.0.</p> <ol> <li> <p>If the current package does not work for you, and you for example need a package for inclusion directly on a web page as a <code>&lt;script&gt;</code> tag, please reach out to the development team.\u00a0\u21a9</p> </li> </ol>"},{"location":"Installing%20the%20SDK/Java/","title":"Java Installation","text":"<p>The Java SDK is now available through a private Maven repository hosted on JFrog. You can add it as a dependency in your Maven project's <code>pom.xml</code> file.</p>"},{"location":"Installing%20the%20SDK/Java/#installing-via-maven-repository","title":"Installing via Maven Repository","text":"<ol> <li> <p>Update <code>settings.xml</code></p> <p>To access the private Maven repository, you need to update your Maven <code>settings.xml</code> file, usually located in the <code>~/.m2</code> directory. Add the following server configuration:</p> <pre><code>&lt;servers&gt;\n&lt;server&gt;\n    &lt;id&gt;jfrog-private-repo&lt;/id&gt;\n    &lt;username&gt;your-username&lt;/username&gt;\n    &lt;password&gt;your-password&lt;/password&gt;\n    &lt;/server&gt;\n&lt;/servers&gt;\n</code></pre> <p>Note: Replace <code>your-username</code> and <code>your-password</code> with your actual JFrog repository credentials.</p> </li> <li> <p>Update your projects <code>pom.xml</code> file to include the <code>dependency</code> and the <code>repository</code>:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.etogruppe&lt;/groupId&gt;\n    &lt;artifactId&gt;CryptpaySdk&lt;/artifactId&gt;\n    &lt;version&gt;0.11.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <pre><code>&lt;repositories&gt;\n&lt;repository&gt;\n    &lt;id&gt;snapshots-repo&lt;/id&gt;\n    &lt;url&gt;https://repo.farmunited.com:443/artifactory/egdbz-mvn/&lt;/url&gt;\n    &lt;releases&gt;\n    &lt;enabled&gt;false&lt;/enabled&gt;\n    &lt;/releases&gt;\n    &lt;snapshots&gt;\n    &lt;enabled&gt;true&lt;/enabled&gt;\n    &lt;/snapshots&gt;\n&lt;/repository&gt;\n&lt;/repositories&gt;\n</code></pre> </li> </ol> <p>See JFrog Artifactory Documentation &gt; Package Management &gt; Maven Repository for guiding docs.</p>"},{"location":"Installing%20the%20SDK/Java/#installing-jnilibs","title":"Installing jniLibs","text":"<p>The jar files also contain the jniLibs folder. The jniLibs folder in turn contains the pre-built shared object libraries of the SDK. The structure of the folder is as shown below:</p> <pre><code>jniLibs\n\u251c\u2500\u2500 arm64-v8a\n\u2502   \u251c\u2500\u2500 libwalletsdk.so\n\u2502   \u2514\u2500\u2500 libc++_shared.so\n\u251c\u2500\u2500 armeabi-v7a\n\u2502   \u251c\u2500\u2500 libwalletsdk.so\n\u2502   \u2514\u2500\u2500 libc++_shared.so\n\u251c\u2500\u2500 x86\n\u2502   \u251c\u2500\u2500 libwalletsdk.so\n\u2502   \u2514\u2500\u2500 libc++_shared.so\n\u2514\u2500\u2500 x86_64\n    \u251c\u2500\u2500 libwalletsdk.so\n    \u2514\u2500\u2500 libc++_shared.so\n</code></pre> <p>The <code>jniLibs</code> folder should be placed as-is under the <code>src/main</code> folder of the corresponding Java project from the jar file.</p> <p>Warning</p> <p>Currently the moving of the jniLibs from the jar to the src/main folder is manual and not automated. Later it will be automated with a gradle plugin once the project is moved to open source. Not copying this generally will throw the error while initializing the constructor of the CryptpaySdk class <code>java.lang.UnsatisfiedLinkError: dlopen failed: library \"libwalletsdk.so\" not found</code>.</p>"},{"location":"Installing%20the%20SDK/Java/#future-releases-of-sdk","title":"Future releases of SDK","text":"<p>Future releases of the SDK will continue to be published to the private Maven repository. You will only need to update the dependency version in your pom.xml file to use the latest release and replace the jniLibs correspondingly.</p>"},{"location":"Installing%20the%20SDK/Java/#minimum-version-support","title":"Minimum version support","text":"<p>The following versions of the toolchain are used to build and compile the Java SDK and should be used as minimum versions for integrating the SDK. Versions lower than the mentioned might work, however are not guaranteed by the team. In case of issues, please contact the team with specific build or compile errors.</p> <ul> <li>Java Compiler: <code>17.0.10</code></li> <li>gradle: <code>Gradle 8.6</code></li> <li>Android SDK Command-line Tools:  <code>12.0</code></li> <li>Android SDK Platform: <code>Android SDK Platform 13</code></li> <li>Android API Level: <code>33</code></li> <li>Android NDK: <code>26.2.11394342</code></li> <li>Android Build Tools: <code>34.0.0</code></li> </ul>"},{"location":"Installing%20the%20SDK/Swift/","title":"Swift Installation","text":"<p>The swift SDK is now available through a private gitlab repository with binaries hosted on JFrog. You can add the repository as a <code>dependency</code> in your <code>Package.swift</code>. Before starting, make sure you have access to the Gitlab repository as it will be needed for the instructions below.</p> <p>We provide binaries for the following platforms:</p> <ul> <li><code>aarch64-apple-ios</code>: targets 64-bit ARM processors for iOS devices like iPhones and iPads.</li> <li><code>aarch64-apple-darwin</code>: for 64-bit ARM processors on macOS systems (eg. M1).</li> <li><code>x86_64-apple-darwin</code>: for 64-bit Intel processors on macOS systems.</li> </ul>"},{"location":"Installing%20the%20SDK/Swift/#using-cawaena-with-swift-package-manager","title":"Using Cawaena with Swift Package Manager","text":"<p>The Cawaena SDK can also be used as a Swift package. Follow these steps to integrate it into your project:</p> <p>Add the repository as a <code>dependency</code> in your <code>Package.swift</code> file:</p> <pre><code>import PackageDescription\n\nlet package = Package(\n    name: \"program\",\n    dependencies: [\n        .package(url: \"https://gitlab.inovel.de/zd0006/Cawaena-swift\", from: \"0.0.1\")\n    ],\n    targets: [\n        .executableTarget(\n            name: \"main\",\n            dependencies: [\n                .product(name: \"CryptpaySdk\", package: \"Cawaena-swift\")\n            ]),\n    ]\n)\n</code></pre> <p>The <code>CryptpaySdk</code> module will then be available for import in your project.</p>"},{"location":"Installing%20the%20SDK/Swift/#using-cawaena-with-xcode","title":"Using Cawaena with XCode","text":"<p>In XCode, go to File -&gt; Add Package Dependencies. In the top right search box, enter the url of the GitLab repository (<code>https://gitlab.inovel.de/zd0006/Cawaena-swift</code>) and select the Cawaena Sdk when it appears in the list. Select Add Package and follow the on-screen instructions.</p>"},{"location":"Installing%20the%20SDK/Swift/#access-to-the-binaries-on-jfrog","title":"Access to the binaries on JFrog","text":"<p>To allow the Swift Package Manager and XCode to download the binaries stored in JFrog, you need to set up an access token in your <code>~/.netrc</code> file.</p> <ol> <li>Visit <code>JFrog</code> and log in. In the top right corner, click your name and then \"Edit Profile.\" Under \"Identity Tokens,\" click \"Generate an Identity Token\" and optionally give the token a name.</li> <li>If not already existing, create the file <code>.netrc</code> in your home folder and add the following lines (e.g., using <code>nano ~/.netrc</code>)</li> </ol> <pre><code>machine repo.farmunited.com\n    login &lt;your JFrog username&gt;\n    password &lt;your access token&gt;\n</code></pre> <ol> <li>You should now be able to access and use the package in your Swift projects!</li> </ol> <p>Note: you might need to restart XCode for the changes to take effect.</p>"},{"location":"Installing%20the%20SDK/Swift/#future-releases-of-sdk","title":"Future releases of SDK","text":"<p>Future releases of SDK will continue to be published on the private gitlab repository. You will only need to update the dependency version to use the latest release.</p>"},{"location":"Installing%20the%20SDK/Swift/#minimum-supported-version","title":"Minimum supported version","text":"<ul> <li>swift-tools - <code>5.8</code></li> <li>swiftlang- <code>swiftlang-5.8.0.124.2</code></li> <li>clang - <code>clang-1403.0.22.11.100</code></li> <li>iOS - <code>13</code></li> </ul>"},{"location":"SDK%20Configuration/Configuration/","title":"Configuring the SDK","text":"<p>The Cawaena SDK needs to be configured correctly for secure and functional usage. Misconfiguration might lead to potential information leaks as well as bad end-user experience.</p>"},{"location":"SDK%20Configuration/Configuration/#configuring-authentication-provider","title":"Configuring authentication provider","text":"<p>The authentication provider is a setting which is configured in the beginning in conjunction with the Cawaena development team. The Cawaena SDK and backend support Oauth2.0/OpenID Connect<sup>1</sup> provider and can work with external authentication providers. The following information is needed by the Cawaena team to configure the backend to accept requests from the SDK:</p> <ol> <li>ISSUER - The issuer, which is part of the JWT claim in the <code>access_token</code>, created by the OAuth2.0 server. The issuer is generally the URL to the realm, but could also be different based on different settings.</li> <li>AUTHORITY - The authority is where the public keys/certificates are hosted, which are used by the OAuth2.0 server to sign the JWT <code>access_tokens</code>. This is mostly a URL of the following type: <code>{base_url}/auth/realms/{realm_name}/protocol/openid-connect/certs</code></li> <li>AZP - The authorized party, which is part of the JWT claim in the <code>access_token</code>, created by the OAuth2.0 server. The authorized party is typically the name of the 3rd-party client, which has requested the JWT Token for the user using various flows listed in the standard.</li> <li>NAME - A unique name to assign and identify this particular authentication provider settings in the backend as well as in the SDK.</li> </ol> Info <p>The control of the client credentials, the flows used to fetch the JWT as well as the entire user management including user registration, email verification and user settings is out of scope for Cawaena backend and SDK. This should be managed by applications using the SDK themselves.</p> <p>Once this information is provided and configured correctly in the backend by the Cawaena team, the SDK function <code>set_auth_provider</code> can be used as shown below to configure the correct authentication provider.</p> RustJavaSwift <pre><code>async fn main() {\n    dotenvy::dotenv().ok();\n\n    // ensure a clean start\n    tokio::fs::create_dir_all(path).await.unwrap();\n\n    let username = std::env::var(\"SATOSHI_USERNAME\").unwrap();\n\n    let mut sdk = Sdk::default(); // (1)! \n\n    // Set the auth provider\n    let auth_provider = std::env::var(\"AUTH_PROVIDER\").unwrap();\n    sdk.set_auth_provider(&amp;auth_provider);\n    sdk.validate_config().unwrap();\n\n    // other SDK functions\n\n}\n</code></pre> <ol> <li>This internally sets the path prefix or the storage path to the current working directory.</li> </ol> <pre><code> package org.example.app;\n\nimport com.etogruppe.CryptpaySdk;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.io.IOException;\nimport java.util.Map;\n\npublic class app {\n    private CryptpaySdk sdk;\n    public static void main(){\n        sdk = new CryptpaySdk();\n        String path = \"/tmp/Cawaena\";\n\n        // ensure a clean start\n        try {\n            Files.createDirectories(Paths.get(path));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        Map&lt;String, String&gt; env = System.getenv();\n        String username = env.get(\"SATOSHI_USERNAME\");\n\n        String authProvider = env.get(\"AUTH_PROVIDER\");\n\n        try {\n            sdk.setStoragePath(path);\n            sdk.authProvider(authProvider);\n            sdk.logLevel(\"info\");\n            sdk.initLogger();\n\n            sdk.checkConfig();\n            // other SDK functions\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre> <pre><code>import Foundation\n\nlet path = \"/tmp/Cawaena\"\n\n// ensure a clean start\ndo {\n    try FileManager.default.createDirectory(atPath: path, withIntermediateDirectories: true, attributes: nil)\n} catch {\n    print(error.localizedDescription)\n}\n\nlet username = ProcessInfo.processInfo.environment[\"SATOSHI_USERNAME\"] ?? \"\"\n\nlet auth_provider = ProcessInfo.processInfo.environment[\"AUTH_PROVIDER\"] ?? \"\"\n\nlet sdk = Sdk()\nsdk.setPathPrefix(path_prefix: path)\nsdk.setLogLevel(log_level: \"info\")\nsdk.setAuthProvider(auth_provider: auth_provider)\ndo {\n    try sdk.initLogger()\n    try sdk.checkConfig() \n    // other SDK functions\n} catch {\n    print(error.localizedDescription)\n}\n</code></pre> <p>Every time, the OAuth client refreshes or fetches a new access token for the user, the access token can be updated in the SDK using the <code>refresh_access_token</code>function.</p> RustJavaSwift <pre><code>async fn main() {\n    dotenvy::dotenv().ok();\n\n    // ensure a clean start\n    tokio::fs::create_dir_all(path).await.unwrap();\n\n    let username = std::env::var(\"SATOSHI_USERNAME\").unwrap();\n\n    let mut sdk = Sdk::default();\n    let auth_provider = std::env::var(\"AUTH_PROVIDER\").unwrap();\n    sdk.set_auth_provider(&amp;auth_provider);\n    sdk.validate_config().unwrap();\n\n    // other SDK functions\n\n    // Refreshing access token from environment\n    // But it can also be directly given from the OAuth client\n    let new_token = std::env::var(\"NEW_TOKEN\").unwrap();\n    sdk.refresh_access_token(&amp;new_token);\n}\n</code></pre> <pre><code>package org.example.app;\n\nimport com.etogruppe.CryptpaySdk;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.io.IOException;\nimport java.util.Map;\n\npublic class app {\n    private CryptpaySdk sdk;\n    public static void main(){\n        sdk = new CryptpaySdk();\n        String path = \"/tmp/Cawaena\";\n\n        // ensure a clean start\n        try {\n            Files.createDirectories(Paths.get(path));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        Map&lt;String, String&gt; env = System.getenv();\n        String username = env.get(\"SATOSHI_USERNAME\");\n\n        String authProvider = env.get(\"AUTH_PROVIDER\");\n\n        try {\n            sdk.setStoragePath(path);\n            sdk.authProvider(authProvider);\n            sdk.logLevel(\"info\");\n            sdk.initLogger();\n\n            sdk.checkConfig();\n            // other SDK functions\n\n            // Refreshing access token from environment\n            // But it can also be directly given from the OAuth client\n            let newToken = env.get(\"NEW_TOKEN\").unwrap();\n            sdk.refreshAccessToken(newToken);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre> <pre><code>import Foundation\n\nlet path = \"/tmp/Cawaena\"\n\n// ensure a clean start\ndo {\n    try FileManager.default.createDirectory(atPath: path, withIntermediateDirectories: true, attributes: nil)\n} catch {\n    print(error.localizedDescription)\n}\n\nlet username = ProcessInfo.processInfo.environment[\"SATOSHI_USERNAME\"] ?? \"\"\n\nlet auth_provider = ProcessInfo.processInfo.environment[\"AUTH_PROVIDER\"] ?? \"\"\n\nlet sdk = Sdk()\nsdk.setPathPrefix(path_prefix: path)\nsdk.setLogLevel(log_level: \"info\")\nsdk.setAuthProvider(auth_provider: auth_provider)\ndo {\n    try sdk.initLogger()\n    try sdk.checkConfig() \n    // other SDK functions\n    // Refreshing access token from environment\n    // But it can also be directly given from the OAuth client\n    let access_token = ProcessInfo.processInfo.environment[\"NEW_TOKEN\"] ?? \"\"\n    try sdk.refreshAccessToken(access_token: accessToken)\n} catch {\n    print(error.localizedDescription)\n}\n</code></pre> <p>Warning</p> <p>The SDK is not responsible for refreshing the access token. Neither does it have the credentials, nor a way to obtain credentials for refreshing an access token for the user. This is the responsibility of the client application integrating the SDK. The refresh_access_token function should not be confused with refresh_token and should not be passed the value of refresh_token. The function needs the value of a valid access_token as a string.</p>"},{"location":"SDK%20Configuration/Configuration/#configuring-backend","title":"Configuring backend","text":"<p>The Cawaena team provides the URL for the backend, which can directly set using the <code>set_backend_url</code> function. This information is part of the initial setup and is important before starting the SDK usage.</p> RustJavaSwift <pre><code>async fn main() {\n    dotenvy::dotenv().ok();\n\n    // ensure a clean start\n    tokio::fs::create_dir_all(path).await.unwrap();\n\n    let username = std::env::var(\"SATOSHI_USERNAME\").unwrap();\n\n    let mut sdk = Sdk::default();\n\n    // Set the backend URL\n    let url = std::env::var(\"URL\").unwrap();\n    sdk.set_backend_url(&amp;url);\n    sdk.validate_config().unwrap();\n\n    // other SDK functions\n\n}\n</code></pre> <pre><code>package org.example.app;\n\nimport com.etogruppe.CryptpaySdk;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.io.IOException;\nimport java.util.Map;\n\npublic class app {\n    private CryptpaySdk sdk;\n    public static void main(){\n        sdk = new CryptpaySdk();\n        String path = \"/tmp/Cawaena\";\n\n        // ensure a clean start\n        try {\n            Files.createDirectories(Paths.get(path));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        Map&lt;String, String&gt; env = System.getenv();\n        String username = env.get(\"SATOSHI_USERNAME\");\n\n        String url = env.get(\"URL\");\n\n        try {\n            sdk.setStoragePath(path);\n            sdk.logLevel(\"info\");\n            sdk.backendUrl(url);\n            sdk.initLogger();\n            sdk.checkConfig();\n            // other SDK functions\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre> <pre><code>import Foundation\n\nlet path = \"/tmp/Cawaena\"\n\n// ensure a clean start\ndo {\n    try FileManager.default.createDirectory(atPath: path, withIntermediateDirectories: true, attributes: nil)\n} catch {\n    print(error.localizedDescription)\n}\n\nlet username = ProcessInfo.processInfo.environment[\"SATOSHI_USERNAME\"] ?? \"\"\n\nlet url = ProcessInfo.processInfo.environment[\"URL\"] ?? \"\"\n\nlet sdk = Sdk()\nsdk.setPathPrefix(path_prefix: path)\nsdk.setLogLevel(log_level: \"info\")\nsdk.setBackendUrl(backend_url: url)\ndo {\n    try sdk.initLogger()\n    try sdk.checkConfig() \n    // other SDK functions\n} catch {\n    print(error.localizedDescription)\n}\n</code></pre>"},{"location":"SDK%20Configuration/Configuration/#configuring-the-storage-path-prefix","title":"Configuring the storage path prefix","text":"<p>Depending on how the application is built, it is mandatory that the application has access to a certain file system, where it is allowed read and write files and directories and sub-directories. The storage path prefix can then be configured using the <code>set_path_prefix</code> function, which requires the top-level directory path to where the application can store data specific to the SDK. Both relative and absolute paths work, however, absolute paths are preferred.</p> <p>This function is mandatory to be called, at least once, to enable creation of user and wallet, since it requires the SDK to create some files and fill them with relevant data for later usage. The default path prefix, if not set, is always the current working directory, from where the application is launched.</p> Tip <p>It is recommended to use a path where only the application has file system rights. Allowing access to other applications is a potential security risk and may incur loss of funds for end-users.</p> RustJavaSwift <pre><code>async fn main() {\n    dotenvy::dotenv().ok();\n    let path = \"/tmp/Cawaena\";\n\n    // ensure a clean start\n    tokio::fs::create_dir_all(path).await.unwrap();\n\n    let username = std::env::var(\"SATOSHI_USERNAME\").unwrap();\n\n    let mut sdk = Sdk::default();\n    sdk.set_env(Environment::Development);\n    sdk.set_path_prefix(path);\n    sdk.validate_config().unwrap();\n}\n</code></pre> <pre><code>package org.example.app;\n\nimport com.etogruppe.CryptpaySdk;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.io.IOException;\nimport java.util.Map;\n\npublic class app {\n    private CryptpaySdk sdk;\n    public static void main(){\n        sdk = new CryptpaySdk();\n        String path = \"/tmp/Cawaena\"; // (1)!\n\n        // ensure a clean start\n        try {\n            Files.createDirectories(Paths.get(path));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        Map&lt;String, String&gt; env = System.getenv();\n        String username = env.get(\"SATOSHI_USERNAME\");\n\n        try {\n            sdk.setStoragePath(path);\n            sdk.logLevel(\"info\");\n            sdk.initLogger();\n            sdk.checkConfig();\n            // other SDK functions\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre> <ol> <li>For use in Android applications, it is important to extract the path where the app has permissions to create files and directories and use it as the storage path. This is generally something like <code>\\data\\data\\org.example.app\\</code> if the application package is org.example.app</li> </ol> <pre><code>import Foundation\n\nlet path = \"/tmp/Cawaena\" // (1)!\n\n// ensure a clean start\ndo {\n    try FileManager.default.createDirectory(atPath: path, withIntermediateDirectories: true, attributes: nil)\n} catch {\n    print(error.localizedDescription)\n}\n\nlet username = ProcessInfo.processInfo.environment[\"SATOSHI_USERNAME\"] ?? \"\"\n\nlet sdk = Sdk()\nsdk.setPathPrefix(path_prefix: path)\nsdk.setLogLevel(log_level: \"info\")\ndo {\n    try sdk.initLogger()\n    try sdk.checkConfig() \n    // other SDK functions\n} catch {\n    print(error.localizedDescription)\n}\n</code></pre> <ol> <li>For use in iOS applications, it is important to extract the path where the app has permissions to create files and directories and use it as the storage path.</li> </ol>"},{"location":"SDK%20Configuration/Configuration/#configuring-currency","title":"Configuring currency","text":"<p>The SDK requires a correct currency to be configured. The currently supported currencies are <code>smr</code> for Shimmer network and <code>iota</code> for the IOTA network. Configuration of the currency is required to correctly set-up the wallet.</p> <p>Currently, the configuration of the coin type in BIP-0032 derivation path and connecting to a custom node using a different URL is not supported in the SDK. However, these features will be added in the future to customize the SDK for any test tokens or customer specific blockchain nodes.</p> <p>The currency configuration is linked with the environment configuration. By selecting the environment and the currency, the SDK internally connects automatically to the correct network. By default, on any environment except development, the SDK connects to the main network of the given currency.</p> <p>The development environment is used only internally by the Cawaena development team for testing and should be avoided by application integrating the SDK. Pre-configured environments can be requested to the Cawaena development team, however, the function for setting the environment will be deprecated in the future releases.</p> RustJavaSwift <pre><code>async fn main() {\n    dotenvy::dotenv().ok();\n    let path = \"/tmp/Cawaena\";\n\n    // ensure a clean start\n    tokio::fs::create_dir_all(path).await.unwrap();\n\n    let username = std::env::var(\"SATOSHI_USERNAME\").unwrap();\n\n    sdk.set_path_prefix(path);\n    sdk.set_env(Environment::Development);\n    sdk.set_currency(Currency::Smr);\n    sdk.validate_config().unwrap();\n\n    // other SDK functions\n\n}\n</code></pre> <pre><code>package org.example.app;\n\nimport com.etogruppe.CryptpaySdk;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.io.IOException;\nimport java.util.Map;\n\npublic class app {\n    private CryptpaySdk sdk;\n    public static void main(){\n        sdk = new CryptpaySdk();\n        String path = \"/tmp/Cawaena\"; \n\n        // ensure a clean start\n        try {\n            Files.createDirectories(Paths.get(path));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        Map&lt;String, String&gt; env = System.getenv();\n        String username = env.get(\"SATOSHI_USERNAME\");\n\n        try {\n            sdk.setStoragePath(path);\n            sdk.logLevel(\"info\");\n            sdk.initLogger();\n            sdk.sdkEnv(env.get(\"ENVIRONMENT\"));\n            sdk.setCurrency(\"SMR\");\n            sdk.checkConfig();\n            // other SDK functions\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre> <pre><code>import Foundation\n\nlet path = \"/tmp/Cawaena\"\n\n// ensure a clean start\ndo {\n    try FileManager.default.createDirectory(atPath: path, withIntermediateDirectories: true, attributes: nil)\n} catch {\n    print(error.localizedDescription)\n}\n\nlet username = ProcessInfo.processInfo.environment[\"SATOSHI_USERNAME\"] ?? \"\"\nlet environment = ProcessInfo.processInfo.environment[\"ENVIRONMENT\"] ?? \"\"\n\nlet sdk = Sdk()\nsdk.setPathPrefix(path_prefix: path)\nsdk.setLogLevel(log_level: \"info\")\ndo {\n    try sdk.initLogger()\n    try sdk.setSdkEnv(sdk_env: environment)\n    sdk.setCurrency(\"SMR\");\n    try sdk.checkConfig() \n    // other SDK functions\n} catch {\n    print(error.localizedDescription)\n}\n</code></pre>"},{"location":"SDK%20Configuration/Configuration/#logging-in-the-sdk-and-validating-configuration","title":"Logging in the SDK and validating configuration","text":"<p>It is important and recommended to initialize the logger provided by the SDK. The SDK creates a log file internally which can be exported and analyzed during testing and integration. The path prefix should be set and the log level should be defined before the logger can be successfully initialized.</p> <p>The log file with the name <code>cryptpay_sdk.log</code> is created by the SDK at the root location specified by the set path prefix. The logger will append the logs to the same file, if the file exists and will create a new file if it does not exist.</p> <p>The different log levels that can be set for the logger are: <code>debug</code>, <code>info</code>, <code>warn</code>, <code>error</code>.</p> <p>The SDK also provides a shorthand utility to validate the configuration, any time a configuration is set or modified. This utility does not guarantee that the configuration will always work, but rather provides certain kind of semantic validation and checks if certain preset conditions are met before the SDK module functions can be used.</p> Tip <p>Use the SDK configuration validation function every time a new configuration is done in the SDK before calling any other SDK functions. This helps catch errors due to configuration during the validation and not while executing the module functions.</p> RustJavaSwift <pre><code>async fn main() {\n    dotenvy::dotenv().ok();\n    let path = \"/tmp/Cawaena\";\n\n    // ensure a clean start\n    tokio::fs::create_dir_all(path).await.unwrap();\n\n\n    let mut sdk = Sdk::default();\n    sdk.set_path_prefix(path);\n    sdk.set_log_level(\"info\");\n    sdk.init_logger().unwrap();\n    sdk.validate_config().unwrap();\n}\n</code></pre> <pre><code>package org.example.app;\n\nimport com.etogruppe.CryptpaySdk;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.io.IOException;\nimport java.util.Map;\n\npublic class app {\n    private CryptpaySdk sdk;\n    public static void main(){\n        sdk = new CryptpaySdk();\n        String path = \"/tmp/Cawaena;\n\n        // ensure a clean start\n        try {\n            Files.createDirectories(Paths.get(path));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        Map&lt;String, String&gt; env = System.getenv();\n\n        try {\n            sdk.setStoragePath(path);\n            sdk.logLevel(\"info\");\n            sdk.initLogger();\n            sdk.checkConfig();\n            // other SDK functions\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre> <pre><code>import Foundation\n\nlet path = \"/tmp/Cawaena\" \n\n// ensure a clean start\ndo {\n    try FileManager.default.createDirectory(atPath: path, withIntermediateDirectories: true, attributes: nil)\n} catch {\n    print(error.localizedDescription)\n}\n\nlet sdk = Sdk()\nsdk.setPathPrefix(path_prefix: path)\nsdk.setLogLevel(log_level: \"info\")\ndo {\n    try sdk.initLogger()\n    try sdk.checkConfig() \n    // other SDK functions\n} catch {\n    print(error.localizedDescription)\n}\n</code></pre>"},{"location":"SDK%20Configuration/Configuration/#complete-example","title":"Complete example","text":"<p>The following code snippet shows a complete example for correctly configuring the SDK before using any of its module functions. Exceptions from the SDK with misconfiguration can be caught early to avoid unncessary delays while integrating other module functions.</p> RustJavaSwift <pre><code>async fn main() {\n    dotenvy::dotenv().ok();\n    let path = \"/tmp/Cawaena\";\n\n    // ensure a clean start\n    tokio::fs::create_dir_all(path).await.unwrap();\n\n    let mut sdk = Sdk::default();\n\n    // Set the auth provider\n    let auth_provider = std::env::var(\"AUTH_PROVIDER\").unwrap();\n    sdk.set_auth_provider(&amp;auth_provider);\n\n    // Set the backend URL\n    let url = std::env::var(\"URL\").unwrap();\n    sdk.set_backend_url(&amp;url);\n\n    // Set path prefix\n    sdk.set_path_prefix(path);\n\n    // Set environment and currency\n    sdk.set_env(Environment::Development);\n    sdk.set_currency(Currency::Smr);\n\n    // Set log level and initialize logger\n    sdk.set_log_level(\"info\");\n    sdk.init_logger().unwrap();\n\n    // Validate configuration\n    sdk.validate_config().unwrap();\n\n}\n</code></pre> <pre><code>package org.example.app;\n\nimport com.etogruppe.CryptpaySdk;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.io.IOException;\nimport java.util.Map;\n\npublic class app {\n    private CryptpaySdk sdk;\n    public static void main(){\n        sdk = new CryptpaySdk();\n        String path = \"/tmp/Cawaena\";\n\n        // ensure a clean start\n        try {\n            Files.createDirectories(Paths.get(path));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        Map&lt;String, String&gt; env = System.getenv();\n\n        try {\n            // Set auth provider\n            sdk.authProvider(env.get(\"AUTH_PROVIDER\"););\n\n            // Set backend URL\n            sdk.backendUrl(env.get(\"URL\"));\n\n            // Set storage path (path prefix)\n            sdk.setStoragePath(path);\n\n            // Set environment and currency\n            sdk.sdkEnv(env.get(\"ENVIRONMENT\"));\n            sdk.setCurrency(\"SMR\");\n\n            // Set log level and initialize logger\n            sdk.logLevel(\"info\");\n            sdk.initLogger();\n\n            // Validate configuration\n            sdk.checkConfig();\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre> <pre><code>import Foundation\n\nlet path = \"/tmp/Cawaena\"\n\n// ensure a clean start\ndo {\n    try FileManager.default.createDirectory(atPath: path, withIntermediateDirectories: true, attributes: nil)\n} catch {\n    print(error.localizedDescription)\n}\n\nlet auth_provider = ProcessInfo.processInfo.environment[\"AUTH_PROVIDER\"] ?? \"\"\nlet url = ProcessInfo.processInfo.environment[\"URL\"] ?? \"\"\nlet environment = ProcessInfo.processInfo.environment[\"ENVIRONMENT\"] ?? \"\"\n\nlet sdk = Sdk()\n\n// Set auth provider\nsdk.setAuthProvider(auth_provider: auth_provider)\n\n// Set backend url\nsdk.setBackendUrl(backend_url: url)\n\n// Set path prefix\nsdk.setPathPrefix(path_prefix: path)\n\ndo {\n    // Set environment and currency\n    try sdk.setSdkEnv(sdk_env: environment)\n    try sdk.setCurrency(currency: \"SMR\") \n\n    // Set log level and initialize logger\n    sdk.setLogLevel(log_level: \"info\")\n    try sdk.initLogger()\n\n    // validate configuration\n    try sdk.checkConfig() \n} catch {\n    print(error.localizedDescription)\n}\n</code></pre> <ol> <li> <p>The following information links could be used as reference for OAuth2.0 and OpenID Connect</p> <p>OAuth 2.0 Official Website</p> <p>OAuth 2.0 RFC</p> <p>OAuth 2.0 Simplified</p> <p>OAuth 2.0 Playground</p> <p>OpenID Connect Official Website</p> <p>OpenID Connect RFC</p> <p>OpenID Connect Playground</p> <p>OpenID Connect Introduction \u21a9</p> </li> </ol>"},{"location":"SDK%20Examples/Examples/","title":"Examples","text":"<p>The Cawaena SDK is built in <code>rust</code>. It is primarily an implementation of the various interfaces for managing users, wallets, on-boarding of users through KYC (Know Your Customer) processes, payment methods and listing usage information. The flows discussed in this document show examples using the rust language. For examples related to the specific language, refer to the corresponding pages.</p> <p>The Cawaena SDK can be used only if the following pre-requisites have been fulfilled and the information resulting from these conditions is available:</p> <ul> <li>Oauth2.0 Identity and Access Management Provider is configured correctly,</li> <li>The backend base URL of the Cawaena system is known,</li> <li>The path to a certain file storage is available, where the application has read/write rights to create, modify and delete files related to the SDK like log files, local key-value DBs, and wallet files.</li> </ul> <p>Once this information is available, the SDK can be instantiated and the basic functions can be used.</p> <p>The examples shows the usage of the SDK in rust for creating a user. The user credentials are taken from the environment but could also be easily a user input.</p> <p>The environment configuration to <code>Development</code> attaches the SDK to the development backend of Cawaena automatically. It also configures the authentication provider correctly with the one used by the development team internally. This configuration is used by Cawaena developers and is only restricted to the users controlled by the identity provider configured for Cawaena internal testing.</p>"},{"location":"SDK%20Examples/Examples/#0-shared-setup-code","title":"0. Shared Setup Code","text":"RustJavaSwiftJS/TS <pre><code>#![allow(clippy::unwrap_used, clippy::expect_used, dead_code)]\n\nuse sdk::{\n    core::{Config, Sdk},\n    types::{\n        currencies::Currency,\n        newtypes::{AccessToken, EncryptionPin, PlainPassword},\n    },\n};\nuse std::{collections::HashMap, path::Path};\nuse testing::{CleanUp, USER_SATOSHI};\n\npub async fn init_sdk() -&gt; (Sdk, CleanUp) {\n    dotenvy::dotenv().ok();\n\n    // for the examples we want logs to go to the console for easier troubleshooting\n    env_logger::builder().filter_level(log::LevelFilter::Info).init();\n\n    let user = &amp;USER_SATOSHI;\n\n    let cleanup = CleanUp::default();\n\n    let backend_url = std::env::var(\"EXAMPLES_BACKEND_URL\")\n        .expect(\"EXAMPLES_BACKEND_URL environment variable need to be set to run the examples\");\n\n    // construct the config to use for the SDK\n    let config = Config {\n        backend_url: backend_url.parse().expect(\"EXAMPLES_BACKEND_URL must be a valid URL\"),\n        path_prefix: Path::new(&amp;cleanup.path_prefix).into(),\n        auth_provider: \"standalone\".to_string(),\n        log_level: log::LevelFilter::Debug,\n        node_urls: HashMap::from([\n            (Currency::Smr, vec![\"https://api.testnet.shimmer.network\".to_string()]),\n            (Currency::Iota, vec![\"https://api.testnet.iotaledger.net\".to_string()]),\n            (\n                Currency::Eth,\n                vec![\"https://ethereum-sepolia-rpc.publicnode.com\".to_string()],\n            ),\n        ]),\n    };\n    let mut sdk = Sdk::new(config).expect(\"should not fail to initialize sdk\"); // set the backend url if the environment variable is set\n\n    // generate access token\n    let access_token = testing::get_access_token(&amp;user.username, &amp;user.password)\n        .await\n        .access_token;\n    let access_token = AccessToken::try_from(access_token).unwrap();\n    sdk.refresh_access_token(Some(access_token)).await.unwrap();\n\n    sdk.set_currency(Currency::Smr);\n\n    (sdk, cleanup)\n}\n\n/// A copy of the [`testing::TestUser`] that uses the newtype wrappers for sensitive values for\n/// easier use in the examples.\n#[derive(Debug)]\npub struct TestUser {\n    pub username: String,\n    pub password: PlainPassword,\n    pub pin: EncryptionPin,\n    pub mnemonic: String,\n    pub first_name: String,\n    pub last_name: String,\n    pub email: String,\n    pub date_of_birth: String,\n    pub iban: String,\n}\n\nimpl From&lt;testing::TestUser&gt; for TestUser {\n    fn from(value: testing::TestUser) -&gt; Self {\n        Self {\n            username: value.username,\n            password: PlainPassword::try_from_string(value.password).unwrap(),\n            pin: EncryptionPin::try_from_string(value.pin).unwrap(),\n            mnemonic: value.mnemonic,\n            first_name: value.first_name,\n            last_name: value.last_name,\n            email: value.email,\n            date_of_birth: value.date_of_birth,\n            iban: value.iban,\n        }\n    }\n}\n\n// This module needs a `main` function so we add an empty one here.\n#[tokio::main]\nasync fn main() {}\n</code></pre> <pre><code>package com.etogruppe.examples;\n\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport io.github.cdimascio.dotenv.Dotenv;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport java.nio.file.Path;\nimport java.nio.file.FileSystems;\nimport java.nio.file.Files;\n\nimport com.etogruppe.CryptpaySdk;\n\npublic class utils {\n    public static String USERNAME_SATOSHI = \"satoshi\";\n    public static String PIN = \"1234\";\n    public static String NEW_PIN = \"4321\";\n    public static String USERNAME_ARCHIVEME = \"archiveme\";\n    public static String USERNAME_HANS48 = \"hans48\";\n\n    public static CryptpaySdk initSdk(String username) {\n        CryptpaySdk sdk = new CryptpaySdk();\n\n        // config sdk\n        try {\n            // on CI we want to store the logs as artifacts, so we force the location\n            Path directory;\n            if (getEnvVariable(\"CI\") != null) {\n                Path path = FileSystems.getDefault().getPath(\"logs\");\n                Files.createDirectories(path);\n                directory = Files.createTempDirectory(path, \"cryptpay_examples\");\n            } else {\n                directory = Files.createTempDirectory(\"cryptpay_examples\");\n            }\n\n            System.out.println(\"Setting storage path to temporary directory: \" + directory.toString());\n\n            String url = getEnvVariable(\"EXAMPLES_BACKEND_URL\");\n\n            sdk.setConfig(\"\"\"\n                    {\n                        \"backend_url\": \"%s\",\n                        \"storage_path\": \"%s\",\n                        \"log_level\": \"info\",\n                        \"auth_provider\": \"standalone\"\n                    }\n                    \"\"\".formatted(url, directory.toString()));\n\n            System.out.println(\"SDK environment set to development and validated.\");\n\n            // get the access token\n            String access_token = generateAccessToken(username);\n            sdk.refreshAccessToken(access_token);\n            System.out.println(\"retrieved access token\");\n\n            sdk.setCurrency(\"Smr\");\n        } catch (Exception e) {\n            throw new RuntimeException(\"Failed to initialize SDK\", e);\n        }\n\n        return sdk;\n    }\n\n    // Enum with possible error cases which might happen during the generation of\n    // the access token call.\n    enum TokenError {\n        MISSING_ENVIRONMENT_VARIABLE,\n        INVALID_URL,\n        PARSING_ERROR,\n        ACCESS_TOKEN_NOT_FOUND\n    }\n\n    // Generate an access token by making a call to the KC API\n    public static String generateAccessToken(String username) throws IOException {\n\n        // get from env vars\n        String kcURL = getEnvVariable(\"KC_URL\");\n        String kcRealm = getEnvVariable(\"KC_REALM\");\n        String clientId = getEnvVariable(\"KC_CLIENT_ID\");\n        String clientSecret = getEnvVariable(\"KC_CLIENT_SECRET\");\n        String password = getEnvVariable(\"PASSWORD\");\n\n        if (kcURL == null || kcRealm == null || clientId == null || clientSecret == null || password == null) {\n            throw new RuntimeException(TokenError.MISSING_ENVIRONMENT_VARIABLE.name());\n        }\n\n        String urlString = kcURL + \"/realms/\" + kcRealm + \"/protocol/openid-connect/token\";\n        URL url = new URL(urlString);\n        HttpURLConnection con = (HttpURLConnection) url.openConnection();\n        con.setRequestMethod(\"POST\");\n        con.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n\n        // Construct body parameters\n        Map&lt;String, String&gt; bodyParameters = new HashMap&lt;&gt;();\n        bodyParameters.put(\"grant_type\", \"password\");\n        bodyParameters.put(\"scope\", \"profile email openid\");\n        bodyParameters.put(\"client_id\", clientId);\n        bodyParameters.put(\"client_secret\", clientSecret);\n        bodyParameters.put(\"username\", username);\n        bodyParameters.put(\"password\", password);\n\n        StringBuilder postData = new StringBuilder();\n        for (Map.Entry&lt;String, String&gt; param : bodyParameters.entrySet()) {\n            if (postData.length() != 0)\n                postData.append('&amp;');\n            postData.append(param.getKey());\n            postData.append('=');\n            postData.append(param.getValue());\n        }\n        byte[] postDataBytes = postData.toString().getBytes(\"UTF-8\");\n\n        con.setDoOutput(true);\n        con.getOutputStream().write(postDataBytes);\n\n        // Read response\n        int responseCode = con.getResponseCode();\n        if (responseCode == HttpURLConnection.HTTP_OK) {\n            // Parse JSON response using Jackson ObjectMapper\n            InputStream inputStream = con.getInputStream();\n            ObjectMapper mapper = new ObjectMapper();\n            JsonNode jsonResponse = mapper.readTree(inputStream);\n\n            // Check if access_token exists in JSON response\n            if (jsonResponse.has(\"access_token\")) {\n                // System.out.println(jsonResponse.get(\"access_token\").asText());\n                return jsonResponse.get(\"access_token\").asText();\n            } else {\n                throw new RuntimeException(TokenError.ACCESS_TOKEN_NOT_FOUND.name());\n            }\n        } else {\n            throw new RuntimeException(\"Failed to get access token: \" + responseCode);\n        }\n    }\n\n    public static String getEnvVariable(String varName) {\n        // Check if running in CI environment\n        if (System.getenv(\"CI\") != null) {\n            // Use CI environment variables directly\n            return System.getenv(varName);\n        } else {\n            // Load environment variables from .env file for local development\n            Dotenv dotenv = Dotenv.configure().load();\n            return dotenv.get(varName);\n        }\n    }\n}\n</code></pre> <pre><code>\n</code></pre> <pre><code>import * as wasm from \"../pkg\";\nimport * as dotenv from 'dotenv';\nimport axios from 'axios';\nimport { LocalStorage } from \"node-localstorage\";\n\nexport async function initSdk(username: string) {\n    dotenv.config();\n\n    // setup localStorage to use a file-based mock version\n    globalThis.window = { localStorage: new LocalStorage('./local-storage') } as any;\n\n    // make sure the localStorage is clear to run each example in isolation\n    try {\n        window.localStorage.clear();\n    } catch (e) {\n        console.log(\"Could not clear local storage: \", e);\n    }\n\n    console.log(\"Starting SDK initialization...\");\n\n    const sdk = new wasm.CryptpaySdk();\n\n    // set the backend url if the environment variable is set\n    let url: string = (process.env.EXAMPLES_BACKEND_URL as string);\n    if (url == undefined) {\n        throw new Error(\"EXAMPLES_BACKEND_URL environment variable must be present\")\n    }\n\n    await sdk.setConfig(`\n    {\n        \"backend_url\": \"${url}\",\n        \"log_level\": \"info\",\n        \"auth_provider\": \"standalone\"\n    }\n    `);\n\n    await sdk.setCurrency(wasm.Currency.Smr);\n\n    // Generate access token\n    let access_token = await generateAccessToken(username);\n    await sdk.refreshAccessToken(access_token);\n    return sdk;\n}\n\n// Custom error class for handling token errors\nclass TokenError extends Error {\n    constructor(message: string) {\n        super(message);\n        this.name = \"TokenError\";\n    }\n\n    static missingEnvironmentVariable(message: string) {\n        return new TokenError(`Missing environment variable: ${message}`);\n    }\n\n    static invalidURL() {\n        return new TokenError('Invalid URL');\n    }\n\n    static parsingError(message: string) {\n        return new TokenError(`Parsing error: ${message}`);\n    }\n\n    static accessTokenNotFound() {\n        return new TokenError('Access token not found');\n    }\n}\n\n// Generate an access token by making a call to the KC API. This is mirroring the `hello.http` endpoint\nasync function generateAccessToken(username: string): Promise&lt;string&gt; {\n    // Access environment variables\n    const kcURL = process.env.KC_URL;\n    const kcRealm = process.env.KC_REALM;\n    const clientId = process.env.KC_CLIENT_ID;\n    const clientSecret = process.env.KC_CLIENT_SECRET;\n    const password = process.env.PASSWORD\n\n    if (!kcURL || !kcRealm || !clientId || !clientSecret || !password) {\n        throw TokenError.missingEnvironmentVariable('One or more environment variables are missing');\n    }\n\n\n    const urlString = `${kcURL}/realms/${kcRealm}/protocol/openid-connect/token`;\n\n    let env_data = {\n        grant_type: 'password',\n        scope: 'profile email openid',\n        client_id: clientId,\n        client_secret: clientSecret,\n        username: username,\n        password: password\n    };\n\n    try {\n        const response = await axios.post(urlString, env_data, {\n            headers: { 'content-type': 'application/x-www-form-urlencoded' },\n\n        });\n\n        const data = response.data;\n        if (data &amp;&amp; data.access_token) {\n            return data.access_token;\n        } else {\n            throw TokenError.accessTokenNotFound();\n        }\n    } catch (error: any) {\n        if (error.response) {\n            // Server responded with a status other than 2xx\n            throw TokenError.parsingError(`Server responded with status ${error.response.status}: ${error.response.statusText}`);\n        } else if (error.request) {\n            // No response was received\n            throw TokenError.invalidURL();\n        } else {\n            // Something happened in setting up the request\n            throw TokenError.parsingError(error.message);\n        }\n    }\n}\n</code></pre>"},{"location":"SDK%20Examples/Examples/#1-create-new-user","title":"1. Create New User","text":"RustJavaSwiftJS/TS <pre><code>mod utils;\nuse testing::USER_SATOSHI;\nuse utils::init_sdk;\n\n#[allow(clippy::unwrap_used, clippy::expect_used)]\n#[tokio::main]\nasync fn main() {\n    // Initialize SDK\n    let (mut sdk, _cleanup) = init_sdk().await;\n    let user: utils::TestUser = (*USER_SATOSHI).clone().into();\n\n    // Create new user\n    sdk.create_new_user(&amp;user.username).await.unwrap();\n    sdk.init_user(&amp;user.username).await.unwrap();\n}\n</code></pre> <pre><code>package com.etogruppe.examples;\n\nimport com.etogruppe.CryptpaySdk;\n\npublic class CreateNewUser01 {\n\n    public static void main(String[] args) {\n\n        // Initialize SDK\n        CryptpaySdk sdk = utils.initSdk(utils.USERNAME_SATOSHI);\n\n        try {\n            sdk.createNewUser(utils.USERNAME_SATOSHI);\n            sdk.initializeUser(utils.USERNAME_SATOSHI);\n            System.out.println(\"Created and initialized new user.\");\n        } catch (Exception e) {\n            throw new RuntimeException(\"Create new user example failed\", e);\n        }\n    }\n}\n</code></pre> <pre><code>\n</code></pre> <pre><code>import * as wasm from \"../pkg/cryptpay_sdk_wasm\";// Import the WASM module\nimport { initSdk } from './utils';\n\nasync function main() {\n    let username = \"satoshi\";\n    const sdk = await initSdk(username);\n    await sdk.createNewUser(username);\n\n    console.log(\"user created successfully\");\n\n}\n\nmain();\n</code></pre>"},{"location":"SDK%20Examples/Examples/#2-onboard-user-postident","title":"2. Onboard User Postident","text":"RustJavaSwiftJS/TS <pre><code>mod utils;\nuse testing::USER_SATOSHI;\nuse utils::init_sdk;\n\n// ---------------------------------------------\n// Note: This examples does not work unless you do manual postident verification at https://postident-itu.deutschepost.de/testapp\n// ---------------------------------------------\n\n#[allow(clippy::unwrap_used, clippy::expect_used)]\n#[tokio::main]\nasync fn main() {\n    // Initialize SDK and create a new user\n    let (mut sdk, _cleanup) = init_sdk().await;\n    let user: utils::TestUser = (*USER_SATOSHI).clone().into();\n\n    sdk.create_new_user(&amp;user.username).await.unwrap();\n    sdk.init_user(&amp;user.username).await.unwrap();\n\n    // Exit if user is already verified\n    let is_verified = sdk.is_kyc_status_verified(&amp;user.username).await.unwrap();\n    if is_verified {\n        println!(\"User is already verified, please run the delete_user example first.\");\n        return;\n    }\n\n    // Create sap customer if not exists\n    if sdk.get_customer().await.is_err() {\n        sdk.create_customer(\"DE\").await.unwrap();\n    };\n\n    // Start KYC verification for postident\n    let new_case_id = sdk.start_kyc_verification_for_postident().await.unwrap();\n    println!(\"New postident user with case: {:#?}\", new_case_id);\n\n    // Do manual postident verification at\n    // https://postident-itu.deutschepost.de/testapp\n    let mut enter = String::new();\n    println!(\"Do postident KYC and hit enter to continue...\");\n    std::io::stdin()\n        .read_line(&amp;mut enter)\n        .expect(\"error: unable to read user input\");\n\n    // Finish KYC verification for postident\n    sdk.update_kyc_status_for_postident(&amp;new_case_id.case_id).await.unwrap();\n\n    // Check that the user is verified\n    let is_verified = sdk.is_kyc_status_verified(&amp;user.username).await.unwrap();\n    println!(\"IsVerified: {:#?}\", is_verified);\n}\n</code></pre> <pre><code>/**\n    * Do manual postident verification at https://postident-itu.deutschepost.de/testapp\n*/\n\npackage com.etogruppe.examples;\n\nimport com.etogruppe.CryptpaySdk;\n\npublic class OnboardUserPostident02 {\n\n    public static void main(String[] args) {\n\n        // Initialize SDK\n        CryptpaySdk sdk = utils.initSdk(utils.USERNAME_SATOSHI);\n\n        try {\n            // create and init new user\n            sdk.createNewUser(utils.USERNAME_SATOSHI);\n            sdk.initializeUser(utils.USERNAME_SATOSHI);\n            System.out.println(\"Created and initialized new user.\");\n\n            // check if user is kyc verified\n            boolean is_verified = sdk.isKycVerified(utils.USERNAME_SATOSHI);\n            if (is_verified == true) {\n                System.out.println(\"User is already verified, please run the delete_user example first.\");\n                return;\n            }\n\n            // Create sap customer if not exists\n            try {\n                sdk.customerGet();\n                System.out.println(\"customer already exists\");\n            } catch (Exception e) {\n                sdk.customerCreate(\"DE\");\n                System.out.println(\"created SAP customer\");\n            }\n\n            // Start KYC verification for postident\n            String new_case = sdk.startKycVerificationForPostident();\n            System.out.println(\"New postident user with case: \" + new_case);\n\n            // Do manual postident verification at\n            // https://postident-itu.deutschepost.de/testapp\n\n            // Finish KYC verification for postident\n            sdk.updateKycStatusForPostident(\"new case id\");\n\n            // Check that the user is verified\n            boolean is_verified_after = sdk.isKycVerified(utils.USERNAME_SATOSHI);\n            System.out.println(\"IsVerified: \" + is_verified_after);\n\n        } catch (\n\n        Exception e) {\n            throw new RuntimeException(\"Onboard user postident example failed\", e);\n        }\n    }\n}\n</code></pre> <pre><code>\n</code></pre> <pre><code>//  Need to do manual verification on postident: https://postident-itu.deutschepost.de/testapp\nimport * as wasm from \"../pkg/cryptpay_sdk_wasm\";\nimport { initSdk } from './utils';\n\nasync function main() {\n    let username = \"satoshi\";\n    const sdk = await initSdk(username);\n    await sdk.createNewUser(username);\n    await sdk.initializeUser(username);\n\n    // Start KYC verification for Postident\n    let response = await sdk.startKycVerificationForPostident();\n    console.log(\"Postident case id:\", response.case_id);\n    console.log(\"Postident case url:\", response.case_url);\n\n    // --&gt; Do Postident KYC process with URL\n\n    // Get KYC details for Postident\n    let caseDetails = await sdk.getKycDetailsForPostident();\n    console.log(\"Case details:\", caseDetails);\n\n    // Update KYC status for Postident\n    await sdk.updateKycStatusForPostident(response.case_id);\n    console.log(\"Case status updated.\");\n\n    // Check if KYC is verified\n    let isVerified = await sdk.isKycVerified(username);\n    console.log(\"IsVerified:\", isVerified);\n\n}\n\nmain();\n</code></pre>"},{"location":"SDK%20Examples/Examples/#4-migrate-wallet-from-mnemonic","title":"4. Migrate Wallet From Mnemonic","text":"RustJavaSwiftJS/TS <pre><code>mod utils;\nuse testing::USER_SATOSHI;\nuse utils::init_sdk;\n\n#[allow(clippy::unwrap_used, clippy::expect_used)]\n#[tokio::main]\nasync fn main() {\n    // Initialize SDK\n    let (mut sdk, _cleanup) = init_sdk().await;\n    let user: utils::TestUser = (*USER_SATOSHI).clone().into();\n\n    // Create new user\n    sdk.create_new_user(&amp;user.username).await.unwrap();\n    sdk.init_user(&amp;user.username).await.unwrap();\n    sdk.set_password(&amp;user.pin, &amp;user.password).await.unwrap();\n\n    // Create new wallet\n    sdk.create_wallet_from_existing_mnemonic(&amp;user.pin, &amp;user.mnemonic)\n        .await\n        .unwrap();\n\n    // use wallet\n    let _address = sdk.generate_new_address(&amp;user.pin).await.unwrap();\n}\n</code></pre> <pre><code>package com.etogruppe.examples;\n\nimport com.etogruppe.CryptpaySdk;\n\npublic class MigrateWalletFromMnemonic04 {\n\n    public static void main(String[] args) {\n\n        // initialize the sdk\n        CryptpaySdk sdk = utils.initSdk(utils.USERNAME_SATOSHI);\n\n        String password = utils.getEnvVariable(\"PASSWORD\");\n        String mnemonic = utils.getEnvVariable(\"MNEMONIC\");\n\n        try {\n            // create and init user\n            sdk.createNewUser(utils.USERNAME_SATOSHI);\n            sdk.initializeUser(utils.USERNAME_SATOSHI);\n            System.out.println(\"Created and initialized new user.\");\n\n            // create new wallet\n            sdk.setPassword(utils.PIN, password);\n            sdk.createWalletFromMnemonic(utils.PIN, mnemonic);\n            System.out.println(\"Created new wallet from mnemonic.\");\n\n        } catch (Exception e) {\n            throw new RuntimeException(\"Migrate wallet from mnemonic example failed\", e);\n        }\n    }\n}\n</code></pre> <pre><code>\n</code></pre> <p>N/A</p>"},{"location":"SDK%20Examples/Examples/#5-migrate-wallet-from-backup","title":"5. Migrate Wallet From Backup","text":"RustJavaSwiftJS/TS <pre><code>use sdk::types::newtypes::PlainPassword;\nmod utils;\nuse testing::USER_SATOSHI;\nuse utils::init_sdk;\n\n#[allow(clippy::unwrap_used, clippy::expect_used)]\n#[tokio::main]\nasync fn main() {\n    // Initialize SDK\n    let (mut sdk, _cleanup) = init_sdk().await;\n    let user: utils::TestUser = (*USER_SATOSHI).clone().into();\n\n    // Create new user\n    sdk.create_new_user(&amp;user.username).await.unwrap();\n    sdk.init_user(&amp;user.username).await.unwrap();\n\n    // Create new wallet\n    sdk.set_password(&amp;user.pin, &amp;user.password).await.unwrap();\n    sdk.create_wallet_from_new_mnemonic(&amp;user.pin).await.unwrap();\n\n    // Create wallet backup and delete it\n    let backup_password = PlainPassword::try_from_string(\"backup_password\").unwrap();\n    let backup = sdk.create_wallet_backup(&amp;user.pin, &amp;backup_password).await.unwrap();\n    sdk.delete_wallet(&amp;user.pin).await.unwrap();\n\n    // Migrate wallet from backup\n    sdk.create_wallet_from_backup(&amp;user.pin, &amp;backup, &amp;backup_password)\n        .await\n        .unwrap();\n\n    // use wallet\n    let _address = sdk.generate_new_address(&amp;user.pin).await.unwrap();\n}\n</code></pre> <pre><code>package com.etogruppe.examples;\n\nimport com.etogruppe.CryptpaySdk;\n\npublic class MigrateWalletFromBackup05 {\n\n    public static void main(String[] args) {\n\n        // initialize the sdk\n        CryptpaySdk sdk = utils.initSdk(utils.USERNAME_SATOSHI);\n\n        String password = utils.getEnvVariable(\"PASSWORD\");\n\n        try {\n            // create and init user\n            sdk.createNewUser(utils.USERNAME_SATOSHI);\n            sdk.initializeUser(utils.USERNAME_SATOSHI);\n            System.out.println(\"Created and initialized new user.\");\n\n            // create new wallet\n            sdk.setPassword(utils.PIN, password);\n            sdk.createNewWallet(utils.PIN);\n            System.out.println(\"Created and initialized new wallet.\");\n\n            // create backup\n            byte[] backup_bytes = sdk.createWalletBackup(utils.PIN, \"backup_password\");\n\n            // delete existing wallet\n            sdk.deleteWallet(utils.PIN);\n            System.out.println(\"deleted existing wallet\");\n\n            // migrate wallet from backup\n            sdk.createWalletFromBackup(utils.PIN, backup_bytes, \"backup_password\");\n            System.out.println(\"wallet restored from backup\");\n\n        } catch (Exception e) {\n            throw new RuntimeException(\"Migrate wallet from backup example failed\", e);\n        }\n    }\n}\n</code></pre> <pre><code>\n</code></pre> <p>N/A</p>"},{"location":"SDK%20Examples/Examples/#6-generate-iota-receiver-address","title":"6. Generate Iota Receiver Address","text":"RustJavaSwiftJS/TS"},{"location":"SDK%20Examples/Examples/#7-get-balance","title":"7. Get Balance","text":"RustJavaSwiftJS/TS <pre><code>use testing::USER_SATOSHI;\nmod utils;\nuse utils::init_sdk;\n\n#[allow(clippy::unwrap_used)]\n#[tokio::main]\nasync fn main() {\n    // Initialize SDK\n    let (mut sdk, _cleanup) = init_sdk().await;\n    let user: utils::TestUser = (*USER_SATOSHI).clone().into();\n\n    // Create new user\n    sdk.create_new_user(&amp;user.username).await.unwrap();\n    sdk.init_user(&amp;user.username).await.unwrap();\n\n    // Create / init new wallet from mnemonic\n    sdk.set_password(&amp;user.pin, &amp;user.password).await.unwrap();\n    sdk.create_wallet_from_existing_mnemonic(&amp;user.pin, &amp;user.mnemonic)\n        .await\n        .unwrap();\n\n    // Generate address\n    let address = sdk.generate_new_address(&amp;user.pin).await.unwrap();\n    println!(\"Address: {}\", address);\n\n    // Get balance\n    let balance = sdk.get_balance(&amp;user.pin).await.unwrap();\n    println!(\"Balance: {:?}\", balance);\n}\n</code></pre> <pre><code>package com.etogruppe.examples;\n\nimport com.etogruppe.CryptpaySdk;\n\npublic class GetBalance07 {\n\n    public static void main(String[] args) {\n\n        // initialize the sdk\n        CryptpaySdk sdk = utils.initSdk(utils.USERNAME_SATOSHI);\n\n        String password = utils.getEnvVariable(\"PASSWORD\");\n        String mnemonic = utils.getEnvVariable(\"MNEMONIC\");\n\n        try {\n            // create and init user\n            sdk.createNewUser(utils.USERNAME_SATOSHI);\n            sdk.initializeUser(utils.USERNAME_SATOSHI);\n            System.out.println(\"Created and initialized new user.\");\n\n            // create new wallet\n            sdk.setPassword(utils.PIN, password);\n            sdk.createWalletFromMnemonic(utils.PIN, mnemonic);\n            System.out.println(\"Created and initialized new wallet from mnemonic.\");\n\n            // generate receiver address\n            String address = sdk.generateNewAddress(utils.PIN);\n            System.out.println(\"address: \" + address);\n\n            // get balance\n            double balance = sdk.getWalletBalance(utils.PIN);\n            System.out.println(\"balance: \" + balance);\n\n        } catch (Exception e) {\n            throw new RuntimeException(\"Get balance example failed\", e);\n        }\n    }\n}\n</code></pre> <pre><code>\n</code></pre> <pre><code>import * as wasm from \"../pkg/cryptpay_sdk_wasm\";\nimport { initSdk } from './utils';\n\nasync function main() {\n    console.log(\"start\");\n    let username = \"satoshi\";\n    let pin = \"1234\";\n    const sdk = await initSdk(username);\n    let password: string = (process.env.PASSWORD as string);\n    let mnemonic: string = (process.env.MNEMONIC as string);\n    await sdk.createNewUser(username);\n    await sdk.initializeUser(username);\n    await sdk.setPassword(pin, password);\n\n    await sdk.createWalletFromMnemonic(pin, mnemonic);\n\n    let address = await sdk.generateNewAddress(pin);\n    console.log(\"Address:\", address);\n\n    let balance = await sdk.getWalletBalance(pin);\n    console.log(\"Balance:\", balance);\n\n}\n\nmain();\n</code></pre>"},{"location":"SDK%20Examples/Examples/#8-create-purchase-request","title":"8. Create Purchase Request","text":"RustJavaSwiftJS/TS <pre><code>use rust_decimal_macros::dec;\nuse sdk::types::currencies::CryptoAmount;\nuse testing::USER_SATOSHI;\nmod utils;\nuse utils::init_sdk;\n\n#[allow(clippy::unwrap_used)]\n#[tokio::main]\nasync fn main() {\n    // Initialize SDK\n    let (mut sdk, _cleanup) = init_sdk().await;\n    let user: utils::TestUser = (*USER_SATOSHI).clone().into();\n\n    // Create new user\n    sdk.create_new_user(&amp;user.username).await.unwrap();\n    sdk.init_user(&amp;user.username).await.unwrap();\n\n    // Create / init new wallet from mnemonic\n    sdk.set_password(&amp;user.pin, &amp;user.password).await.unwrap();\n    sdk.create_wallet_from_existing_mnemonic(&amp;user.pin, &amp;user.mnemonic)\n        .await\n        .unwrap();\n\n    // Generate address\n    let address = sdk.generate_new_address(&amp;user.pin).await.unwrap();\n    println!(\"Address: {}\", address);\n\n    // Get balance\n    let balance = sdk.get_balance(&amp;user.pin).await.unwrap();\n    println!(\"Balance: {:?}\", balance);\n\n    // Create purchase request\n    let product_hash = \"2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824\";\n    let app_data = \"{\\\"imageUrl\\\":\\\"https://httpbin.org/\\\",\\\"imageId\\\":\\\"a846ad10-fc69-4b22-b442-5dd740ace361\\\"}\";\n    let purchase_type = \"CLIK\";\n\n    let amount = CryptoAmount::try_from(dec!(2.0)).unwrap();\n    let purchase_id = sdk\n        .create_purchase_request(\"alice\", amount, product_hash, app_data, purchase_type)\n        .await\n        .unwrap();\n    println!(\"Purchase_id {} \", purchase_id); // print the purchase id to facilitate debugging\n}\n</code></pre> <pre><code>package com.etogruppe.examples;\n\nimport com.etogruppe.CryptpaySdk;\n\npublic class CreatePurchaseRequest08 {\n\n    public static void main(String[] args) {\n\n        // initialize the sdk\n        CryptpaySdk sdk = utils.initSdk(utils.USERNAME_SATOSHI);\n\n        String password = utils.getEnvVariable(\"PASSWORD\");\n        String mnemonic = utils.getEnvVariable(\"MNEMONIC\");\n\n        try {\n            // create and init user\n            sdk.createNewUser(utils.USERNAME_SATOSHI);\n            sdk.initializeUser(utils.USERNAME_SATOSHI);\n            System.out.println(\"Created and initialized new user.\");\n\n            // create new wallet\n            sdk.setPassword(utils.PIN, password);\n            sdk.createWalletFromMnemonic(utils.PIN, mnemonic);\n            System.out.println(\"Created and initialized new wallet from mnemonic.\");\n\n            // generate receiver address\n            String address = sdk.generateNewAddress(utils.PIN);\n            System.out.println(\"address: \" + address);\n\n            // get balance\n            double balance = sdk.getWalletBalance(utils.PIN);\n            System.out.println(\"balance: \" + balance);\n\n            // create purchase request\n            // Create purchase request\n            String product_hash = \"2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824\";\n            String app_data = \"{\\\"imageUrl\\\":\\\"https://httpbin.org/\\\",\\\"imageId\\\":\\\"a846ad10-fc69-4b22-b442-5dd740ace361\\\"}\";\n            String purchase_type = \"CLIK\";\n\n            String purchase_id = sdk.purchaseRequestCreate(\"alice\", 2, product_hash, app_data, purchase_type);\n            System.out.println(\"purchase request id: \" + purchase_id);\n\n        } catch (Exception e) {\n            throw new RuntimeException(\"Create purchase request example failed\", e);\n        }\n    }\n}\n</code></pre> <pre><code>\n</code></pre> <pre><code>import { debug } from \"util\";\nimport * as wasm from \"../pkg/cryptpay_sdk_wasm\";\nimport { initSdk } from './utils';\n\nasync function main() {\n    let username = \"satoshi\";\n    let pin = \"1234\";\n    let receiver = \"alice\";\n    const sdk = await initSdk(username);\n    let mnemonic: string = (process.env.MNEMONIC as string);\n    let password: string = (process.env.PASSWORD as string);\n\n    await sdk.createNewUser(username);\n    await sdk.initializeUser(username);\n    await sdk.setPassword(pin, password);\n    await sdk.createWalletFromMnemonic(pin, mnemonic);\n    let address = await sdk.generateNewAddress(pin);\n    debug(`Generated new IOTA receiver address: ${address}`);\n    let balance = await sdk.getWalletBalance(pin);\n\n    console.log(\"balance : \", balance);\n\n    let product_hash = \"2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824\";\n    let app_data = JSON.stringify({\n        \"imageUrl\": \"https://httpbin.org/\",\n        \"imageId\": \"a846ad10-fc69-4b22-b442-5dd740ace361\"\n    });\n\n    let purchase_type = \"CLIK\";\n\n    let purchase_id = await sdk.createPurchaseRequest(receiver, 2.0, product_hash, app_data, purchase_type);\n    console.log(\"Purchase ID:\", purchase_id);\n\n}\n\nmain();\n</code></pre>"},{"location":"SDK%20Examples/Examples/#9-onboard-a-user-on-viviswap","title":"9. Onboard a User on Viviswap","text":"RustJavaSwiftJS/TS <pre><code>use fake::{\n    faker::name::{en::LastName, raw::FirstName},\n    locales::EN,\n    Fake,\n};\nuse sdk::types::viviswap::{ViviswapVerificationStatus, ViviswapVerificationStep};\nuse std::io::Write;\nuse testing::USER_SATOSHI;\nmod utils;\nuse utils::init_sdk;\n\n// ---------------------------------------------\n// Note: This example will not run until the end because the user already exists in Viviswap db and it will not create a new one.\n// ---------------------------------------------\n\n#[allow(clippy::unwrap_used, clippy::expect_used)]\n#[tokio::main]\nasync fn main() {\n    // Initialize SDK and create a new user\n    let (mut sdk, _cleanup) = init_sdk().await;\n    let user: utils::TestUser = (*USER_SATOSHI).clone().into();\n\n    sdk.create_new_user(&amp;user.username).await.unwrap();\n    sdk.init_user(&amp;user.username).await.unwrap();\n\n    // Exit if user is already verified\n    let is_verified = sdk.is_kyc_status_verified(&amp;user.username).await.unwrap();\n    if is_verified {\n        println!(\"User is already verified, please run the delete_user example first.\");\n        return;\n    }\n\n    // Create sap customer if not exists\n    if sdk.get_customer().await.is_err() {\n        sdk.create_customer(\"DE\").await.unwrap();\n    };\n\n    // Start KYC verification for viviswap\n    // The user already exists in viviswap db. Therefore, the test will fail here.\n    let new_user = sdk\n        .start_kyc_verification_for_viviswap(&amp;format!(\"{}@gmail.com\", user.username), true)\n        .await\n        .unwrap();\n    println!(\"New Viviswap user: {:#?}\", new_user);\n\n    // Get KYC status for viviswap\n    let status = sdk.get_kyc_details_for_viviswap().await.unwrap();\n    println!(\"Status: {:#?}\", status);\n\n    // Update KYC status for viviswap\n    let is_individual = Some(true);\n    let is_pep = Some(false);\n    let is_us_citizen = Some(false);\n    let is_regulatory_disclosure = Some(true);\n    let country_of_residence = Some(\"DE\".into());\n    let nationality = Some(\"DE\".to_string());\n    let full_name = Some(format!(\n        \"{} {}\",\n        FirstName(EN).fake::&lt;String&gt;(),\n        LastName().fake::&lt;String&gt;()\n    ));\n    let date_of_birth = Some(\"2001-11-05\".to_string());\n\n    let details = sdk\n        .update_kyc_partially_status_for_viviswap(\n            is_individual,\n            is_pep,\n            is_us_citizen,\n            is_regulatory_disclosure,\n            country_of_residence,\n            nationality,\n            full_name,\n            date_of_birth,\n        )\n        .await\n        .unwrap();\n    println!(\"Details: {:#?}\", details);\n\n    sdk.submit_kyc_partially_status_for_viviswap().await.unwrap();\n\n    // Create a waiting loop that prints a dot every 5 seconds for 30 secounds\n    println!(\"Waiting for KYC verification to complete\");\n    for _ in 0..12 {\n        tokio::time::sleep(tokio::time::Duration::from_secs(6)).await;\n        print!(\".\");\n        std::io::stdout().flush().unwrap();\n        let kyc_details = sdk.get_kyc_details_for_viviswap().await.unwrap();\n        if kyc_details.verified_step == ViviswapVerificationStep::Personal {\n            break;\n        }\n    }\n    println!();\n\n    // Check that the user is verified\n    let is_verified = sdk.is_kyc_status_verified(&amp;user.username).await.unwrap();\n    println!(\"IsVerified: {:#?}\", is_verified);\n\n    let kyc_details = sdk.get_kyc_details_for_viviswap().await.unwrap();\n    println!(\"KycDetails: {:#?}\", kyc_details);\n    assert!(kyc_details.verification_status == ViviswapVerificationStatus::Unverified);\n    assert!(kyc_details.verified_step == ViviswapVerificationStep::Personal);\n    assert!(kyc_details.submission_step == ViviswapVerificationStep::Identity);\n}\n</code></pre> <pre><code>/**\n    * This example will not run until the end because the user already exists in Viviswap db and it will not create a new one.\n*/\n\npackage com.etogruppe.examples;\n\nimport com.etogruppe.CryptpaySdk;\n\npublic class OnboardUserViviswap09 {\n\n    public static void main(String[] args) {\n\n        // Initialize SDK\n        CryptpaySdk sdk = utils.initSdk(utils.USERNAME_SATOSHI);\n\n        try {\n            // create and init new user\n            sdk.createNewUser(utils.USERNAME_SATOSHI);\n            sdk.initializeUser(utils.USERNAME_SATOSHI);\n            System.out.println(\"Created and initialized new user.\");\n\n            // check if user is kyc verified\n            boolean is_verified = sdk.isKycVerified(utils.USERNAME_SATOSHI);\n            if (is_verified == true) {\n                System.out.println(\"User is already verified, please run the delete_user example first.\");\n                return;\n            }\n\n            // Create sap customer if not exists\n            try {\n                sdk.customerGet();\n                System.out.println(\"customer already exists\");\n            } catch (Exception e) {\n                sdk.customerCreate(\"DE\");\n                System.out.println(\"created SAP customer\");\n            }\n\n            // Start KYC verification for viviswap\n            // The user already exists in viviswap db. Therefore, the test will fail here.\n            String new_user = sdk\n                    .startViviswapKyc(\"javaexamples@gmail.com\", true);\n            System.out.println(\"New Viviswap user: \" + new_user);\n\n            // Get KYC status for viviswap\n            String details = sdk.getViviswapKyc();\n            System.out.println(\"Viviswap KYC details: \" + details);\n\n        } catch (\n\n        Exception e) {\n            throw new RuntimeException(\"Onboard user viviswap example failed\", e);\n        }\n    }\n}\n</code></pre> <pre><code>\n</code></pre> <pre><code>import * as wasm from \"../pkg/cryptpay_sdk_wasm\";\nimport { initSdk } from './utils';\n\nasync function main() {\n    let username = \"satoshi\";\n    const sdk = await initSdk(username);\n    await sdk.createNewUser(username);\n    await sdk.initializeUser(username);\n\n    let is_verified = await sdk.isKycVerified(username)\n\n    if (is_verified) {\n        console.log(\"user is verified\");\n        return;\n    }\n\n    try {\n\n        await sdk.getCustomer();\n        console.log(\"sap customer exists. Continue\");\n\n    } catch (error) {\n\n        await sdk.createCustomer(\"DE\");\n        console.log(\"created new sap customer\");\n\n    }\n\n    // Start KYC verification for viviswap\n    // The user already exists in viviswap db. Therefore, the test will fail here.\n\n    let newUser = await sdk.startKycVerificationForViviswap(\"wasmtest@gmail.com\", true);\n    console.log(`New viviswap user: ${newUser}`);\n}\n\n\nmain();\n</code></pre>"},{"location":"SDK%20Examples/Examples/#10-verify-pin","title":"10. Verify Pin","text":"RustJavaSwiftJS/TS <pre><code>mod utils;\nuse testing::USER_SATOSHI;\nuse utils::init_sdk;\n\n#[allow(clippy::unwrap_used, clippy::expect_used)]\n#[tokio::main]\nasync fn main() {\n    // Initialize SDK\n    let (mut sdk, _cleanup) = init_sdk().await;\n    let user: utils::TestUser = (*USER_SATOSHI).clone().into();\n\n    // Create new user\n    sdk.create_new_user(&amp;user.username).await.unwrap();\n    sdk.init_user(&amp;user.username).await.unwrap();\n\n    // Create new wallet\n    sdk.set_password(&amp;user.pin, &amp;user.password).await.unwrap();\n    sdk.create_wallet_from_new_mnemonic(&amp;user.pin).await.unwrap();\n\n    // Verify pin\n    sdk.verify_pin(&amp;user.pin).await.unwrap();\n}\n</code></pre> <pre><code>package com.etogruppe.examples;\n\nimport com.etogruppe.CryptpaySdk;\n\npublic class VerifyPin10 {\n\n    public static void main(String[] args) {\n\n        // initialize the sdk\n        CryptpaySdk sdk = utils.initSdk(utils.USERNAME_SATOSHI);\n\n        String password = utils.getEnvVariable(\"PASSWORD\");\n\n        try {\n            // create and init user\n            sdk.createNewUser(utils.USERNAME_SATOSHI);\n            sdk.initializeUser(utils.USERNAME_SATOSHI);\n            System.out.println(\"Created and initialized new user.\");\n\n            // create new wallet\n            sdk.setPassword(utils.PIN, password);\n            sdk.createNewWallet(utils.PIN);\n            System.out.println(\"Created and initialized new wallet.\");\n\n            // verify pin\n            sdk.pinVerify(utils.PIN);\n            System.out.println(\"Pin verified\");\n\n        } catch (Exception e) {\n            throw new RuntimeException(\"Verify pin example failed\", e);\n        }\n    }\n}\n</code></pre> <pre><code>\n</code></pre> <pre><code>import * as wasm from \"../pkg/cryptpay_sdk_wasm\";\nimport { initSdk } from './utils';\n\nasync function main() {\n    let username = \"satoshi\";\n    let pin = \"1234\";\n    const sdk = await initSdk(username);\n    let mnemonic: string = (process.env.MNEMONIC as string);\n    let password: string = (process.env.PASSWORD as string);\n\n    await sdk.createNewUser(username);\n    await sdk.initializeUser(username);\n\n    await sdk.setPassword(pin, password);\n    await sdk.createWalletFromMnemonic(pin, mnemonic);\n\n    await sdk.verifyPin(pin);\n    console.log(\"Pin verified successfully\");\n\n}\n\nmain();\n</code></pre>"},{"location":"SDK%20Examples/Examples/#11-reset-pin","title":"11. Reset Pin","text":"RustJavaSwiftJS/TS <pre><code>use sdk::types::newtypes::EncryptionPin;\nmod utils;\nuse testing::USER_SATOSHI;\nuse utils::init_sdk;\n\n// ---------------------------------------------\n// Note: This examples does not work. It gets stuck. Does not pass or fail.\n// ---------------------------------------------\n\n#[allow(clippy::unwrap_used, clippy::expect_used)]\n#[tokio::main]\nasync fn main() {\n    // Initialize SDK\n    let (mut sdk, _cleanup) = init_sdk().await;\n    let user: utils::TestUser = (*USER_SATOSHI).clone().into();\n\n    // Create new user\n    sdk.create_new_user(&amp;user.username).await.unwrap();\n    sdk.init_user(&amp;user.username).await.unwrap();\n\n    // Create new wallet\n    sdk.set_password(&amp;user.pin, &amp;user.password).await.unwrap();\n    sdk.create_wallet_from_new_mnemonic(&amp;user.pin).await.unwrap();\n\n    // Reset pin\n    let new_pin = EncryptionPin::try_from_string(\"123456\").unwrap();\n    sdk.change_pin(&amp;user.pin, &amp;new_pin).await.unwrap();\n\n    // Verify pin\n    sdk.verify_pin(&amp;new_pin).await.unwrap();\n}\n</code></pre> <pre><code>package com.etogruppe.examples;\n\nimport com.etogruppe.CryptpaySdk;\n\npublic class ResetPin11 {\n\n    public static void main(String[] args) {\n\n        // initialize the sdk\n        CryptpaySdk sdk = utils.initSdk(utils.USERNAME_SATOSHI);\n\n        String password = utils.getEnvVariable(\"PASSWORD\");\n\n        try {\n            // create and init user\n            sdk.createNewUser(utils.USERNAME_SATOSHI);\n            sdk.initializeUser(utils.USERNAME_SATOSHI);\n            System.out.println(\"Created and initialized new user.\");\n\n            // create and init new wallet\n            sdk.setPassword(utils.PIN, password);\n            sdk.createNewWallet(utils.PIN);\n            System.out.println(\"Created and init new wallet.\");\n\n            // reset pin\n            sdk.pinReset(utils.PIN, utils.NEW_PIN);\n\n            // verify new pin\n            sdk.pinVerify(utils.NEW_PIN);\n            System.out.println(\"New pin verified\");\n\n        } catch (Exception e) {\n            throw new RuntimeException(\"Reset pin example failed\", e);\n        }\n    }\n}\n</code></pre> <pre><code>\n</code></pre> <pre><code>import * as wasm from \"../pkg/cryptpay_sdk_wasm\";\nimport { initSdk } from './utils';\n\nasync function main() {\n    let username = \"satoshi\";\n    let pin = \"1234\";\n    let new_pin = \"54321\";\n    const sdk = await initSdk(username);\n    let mnemonic: string = (process.env.MNEMONIC as string);\n    let password: string = (process.env.PASSWORD as string);\n\n    await sdk.createNewUser(username);\n    await sdk.initializeUser(username);\n    await sdk.setPassword(pin, password);\n    await sdk.createWalletFromMnemonic(pin, mnemonic);\n\n    await sdk.resetPin(pin, new_pin);\n    console.log(\"Reset pin successful\");\n\n    await sdk.verifyPin(new_pin);\n    console.log(\"new pin verified\");\n}\n\nmain();\n</code></pre>"},{"location":"SDK%20Examples/Examples/#12-change-password","title":"12. Change Password","text":"RustJavaSwiftJS/TS <pre><code>use sdk::types::newtypes::PlainPassword;\nmod utils;\nuse testing::USER_SATOSHI;\nuse utils::init_sdk;\n\n#[allow(clippy::unwrap_used, clippy::expect_used)]\n#[tokio::main]\nasync fn main() {\n    // Initialize SDK\n    let (mut sdk, _cleanup) = init_sdk().await;\n    let user: utils::TestUser = (*USER_SATOSHI).clone().into();\n\n    // Create new user\n    sdk.create_new_user(&amp;user.username).await.unwrap();\n    sdk.init_user(&amp;user.username).await.unwrap();\n\n    // Create new wallet\n    sdk.set_password(&amp;user.pin, &amp;user.password).await.unwrap();\n    sdk.create_wallet_from_new_mnemonic(&amp;user.pin).await.unwrap();\n\n    // Change password\n    let new_password = PlainPassword::try_from_string(\"StrongP@ssw0rd\").unwrap();\n    sdk.set_password(&amp;user.pin, &amp;new_password).await.unwrap();\n\n    // use wallet\n    let _address = sdk.generate_new_address(&amp;user.pin).await.unwrap();\n}\n</code></pre> <pre><code>package com.etogruppe.examples;\n\nimport com.etogruppe.CryptpaySdk;\n\npublic class ChangePassword12 {\n\n    public static void main(String[] args) {\n\n        // initialize the sdk\n        CryptpaySdk sdk = utils.initSdk(utils.USERNAME_SATOSHI);\n\n        String password = utils.getEnvVariable(\"PASSWORD\");\n\n        try {\n            // create and init user\n            sdk.createNewUser(utils.USERNAME_SATOSHI);\n            sdk.initializeUser(utils.USERNAME_SATOSHI);\n            System.out.println(\"Created and initialized new user.\");\n\n            // create new wallet\n            sdk.setPassword(utils.PIN, password);\n            sdk.createNewWallet(utils.PIN);\n            System.out.println(\"Created and initialized new wallet.\");\n\n            // change password\n            sdk.setPassword(utils.PIN, \"StrongP@ssw0rd\");\n            System.out.println(\"Password changed\");\n\n        } catch (Exception e) {\n            throw new RuntimeException(\"Change password example failed\", e);\n        }\n    }\n}\n</code></pre> <pre><code>\n</code></pre> <p>N/A</p>"},{"location":"SDK%20Examples/Examples/#13-send-amount","title":"13. Send Amount","text":"RustJavaSwiftJS/TS <pre><code>mod utils;\nuse rust_decimal_macros::dec;\nuse testing::USER_SATOSHI;\nuse utils::init_sdk;\n\n#[allow(clippy::unwrap_used, clippy::expect_used)]\n#[tokio::main]\nasync fn main() {\n    // Initialize SDK\n    let user: utils::TestUser = (*USER_SATOSHI).clone().into();\n    let (mut sdk, _cleanup) = init_sdk().await;\n\n    // Create new user\n    sdk.create_new_user(&amp;user.username).await.unwrap();\n    sdk.init_user(&amp;user.username).await.unwrap();\n\n    // Create / init new wallet from mnemonic\n    sdk.set_password(&amp;user.pin, &amp;user.password).await.unwrap();\n    sdk.create_wallet_from_existing_mnemonic(&amp;user.pin, &amp;user.mnemonic)\n        .await\n        .unwrap();\n\n    // Generate new address\n    let recipient_address = sdk.generate_new_address(&amp;user.pin).await.unwrap();\n    println!(\"address: {recipient_address}\");\n\n    // Send amount\n    let amount = dec!(2.0).try_into().unwrap();\n    sdk.send_amount(&amp;user.pin, &amp;recipient_address, amount, None, None, None)\n        .await\n        .unwrap();\n}\n</code></pre> <pre><code>package com.etogruppe.examples;\n\nimport com.etogruppe.CryptpaySdk;\n\npublic class SendAmount13 {\n\n    public static void main(String[] args) {\n        // initialize the sdk\n        CryptpaySdk sdk = utils.initSdk(utils.USERNAME_SATOSHI);\n\n        String password = utils.getEnvVariable(\"PASSWORD\");\n        String mnemonic = utils.getEnvVariable(\"MNEMONIC\");\n\n        try {\n            // create and init user\n            sdk.createNewUser(utils.USERNAME_SATOSHI);\n            sdk.initializeUser(utils.USERNAME_SATOSHI);\n            System.out.println(\"Created and initialized new user.\");\n\n            // create new wallet\n            sdk.setPassword(utils.PIN, password);\n            sdk.createWalletFromMnemonic(utils.PIN, mnemonic);\n            System.out.println(\"Created and initialized new wallet from mnemonic.\");\n\n            // generate receiver address\n            String address = sdk.generateNewAddress(utils.PIN);\n            System.out.println(\"address: \" + address);\n\n            // get balance\n            double balance = sdk.getWalletBalance(utils.PIN);\n            System.out.println(\"balance: \" + balance);\n\n            // send amount\n            sdk.sendAmount(utils.PIN, address.toString(), 1, null, null, \"java bindings test\");\n            System.out.println(\"send amount of 1\");\n\n            // get new balance\n            double new_balance = sdk.getWalletBalance(utils.PIN);\n            System.out.println(\"new balance: \" + new_balance);\n\n        } catch (Exception e) {\n            throw new RuntimeException(\"Send amount example failed\", e);\n        }\n    }\n}\n</code></pre> <pre><code>\n</code></pre> <pre><code>import * as wasm from \"../pkg/cryptpay_sdk_wasm\";\nimport { initSdk } from './utils';\n\nasync function main() {\n    let username = \"satoshi\";\n    let pin = \"1234\";\n    const sdk = await initSdk(username);\n    let mnemonic: string = (process.env.MNEMONIC as string);\n    let password: string = (process.env.PASSWORD as string);\n\n    await sdk.createNewUser(username);\n    await sdk.initializeUser(username);\n    await sdk.setPassword(pin, password);\n\n    await sdk.createWalletFromMnemonic(pin, mnemonic);\n\n    let recipient_address = await sdk.generateNewAddress(pin);\n    console.log(\"address\", recipient_address);\n\n    let balance_before = await sdk.getWalletBalance(pin);\n    console.log(\"balance before sending amount\", balance_before);\n\n    await sdk.sendAmount(pin, recipient_address, 1.0);\n\n    let balance_after = await sdk.getWalletBalance(pin);\n    console.log(\"balance after sending amount\", balance_after);\n\n}\n\nmain();\n</code></pre>"},{"location":"SDK%20Examples/Examples/#14-get-exchange-rate","title":"14. Get Exchange Rate","text":"RustJavaSwiftJS/TS <pre><code>mod utils;\nuse testing::USER_SATOSHI;\nuse utils::init_sdk;\n\n#[allow(clippy::unwrap_used, clippy::expect_used)]\n#[tokio::main]\nasync fn main() {\n    // Initialize SDK\n    let (mut sdk, _cleanup) = init_sdk().await;\n    let user: utils::TestUser = (*USER_SATOSHI).clone().into();\n\n    // Create new user\n    sdk.create_new_user(&amp;user.username).await.unwrap();\n    sdk.init_user(&amp;user.username).await.unwrap();\n\n    // Get exchange rate\n    let exchange_rate = sdk.get_exchange_rate().await.unwrap();\n    println!(\"Exchange rate: {}\", exchange_rate);\n}\n</code></pre> <pre><code>package com.etogruppe.examples;\n\nimport com.etogruppe.CryptpaySdk;\n\npublic class GetExchangeRate14 {\n\n    public static void main(String[] args) {\n\n        // initialize the sdk\n        CryptpaySdk sdk = utils.initSdk(utils.USERNAME_SATOSHI);\n\n        try {\n\n            // create and init user\n            sdk.createNewUser(utils.USERNAME_SATOSHI);\n            sdk.initializeUser(utils.USERNAME_SATOSHI);\n            System.out.println(\"Created and initialized new user.\");\n\n            // get exchange rate\n            double exchange_rate = sdk.getExchangeRate();\n            System.out.println(\"Exchange rate: \" + exchange_rate);\n\n        } catch (Exception e) {\n            throw new RuntimeException(\"Get exchange rate example failed\", e);\n        }\n    }\n}\n</code></pre> <pre><code>\n</code></pre> <pre><code>import * as wasm from \"../pkg/cryptpay_sdk_wasm\";\nimport { initSdk } from './utils';\n\nasync function main() {\n\n    let username = \"satoshi\";\n    let pin = \"1234\";\n    const sdk = await initSdk(username);\n    await sdk.createNewUser(username);\n    await sdk.initializeUser(username);\n    let course = await sdk.getExchangeRate();\n    console.log(course);\n}\n\nmain();\n</code></pre>"},{"location":"SDK%20Examples/Examples/#15-claim-outputs","title":"15. Claim Outputs","text":"RustJavaSwiftJS/TS <pre><code>mod utils;\nuse testing::USER_SATOSHI;\nuse utils::init_sdk;\n\n#[allow(clippy::unwrap_used, clippy::expect_used)]\n#[tokio::main]\nasync fn main() {\n    // Initialize SDK\n    let (mut sdk, _cleanup) = init_sdk().await;\n    let user: utils::TestUser = (*USER_SATOSHI).clone().into();\n\n    // Create new user\n    sdk.create_new_user(&amp;user.username).await.unwrap();\n    sdk.init_user(&amp;user.username).await.unwrap();\n\n    // Create new wallet\n    sdk.set_password(&amp;user.pin, &amp;user.password).await.unwrap();\n    sdk.create_wallet_from_new_mnemonic(&amp;user.pin).await.unwrap();\n\n    // Claim output\n    sdk.claim_outputs(&amp;user.pin).await.unwrap();\n}\n</code></pre> <pre><code>package com.etogruppe.examples;\n\nimport com.etogruppe.CryptpaySdk;\n\npublic class ClaimOutput15 {\n\n    public static void main(String[] args) {\n\n        // initialize the sdk\n        CryptpaySdk sdk = utils.initSdk(utils.USERNAME_SATOSHI);\n\n        String password = utils.getEnvVariable(\"PASSWORD\");\n\n        try {\n            // create and init user\n            sdk.createNewUser(utils.USERNAME_SATOSHI);\n            sdk.initializeUser(utils.USERNAME_SATOSHI);\n            System.out.println(\"Created and initialized new user.\");\n\n            // create new wallet\n            sdk.setPassword(utils.PIN, password);\n            sdk.createNewWallet(utils.PIN);\n            System.out.println(\"Created and initialized new wallet.\");\n\n            // claim output\n            sdk.claimOutputs(utils.PIN);\n            System.out.println(\"claim outputs success\");\n\n        } catch (Exception e) {\n            throw new RuntimeException(\"Claim outputs example failed\", e);\n        }\n    }\n}\n</code></pre> <pre><code>\n</code></pre> <pre><code>import * as wasm from \"../pkg/cryptpay_sdk_wasm\";\nimport { initSdk } from './utils';\n\nasync function main() {\n    let username = \"satoshi\";\n    let pin = \"1234\";\n    const sdk = await initSdk(username);\n    let mnemonic: string = (process.env.MNEMONIC as string);\n    let password: string = (process.env.PASSWORD as string);\n\n    await sdk.createNewUser(username);\n    await sdk.initializeUser(username);\n    await sdk.setPassword(pin, password);\n    await sdk.createWalletFromMnemonic(pin, mnemonic);\n    console.log(\"Wallet initialized!\");\n\n    await sdk.claimOutputs(pin);\n    console.log(\"Outputs claimed!\");\n}\n\nmain();\n</code></pre>"},{"location":"SDK%20Examples/Examples/#16-get-purchase-list","title":"16. Get Purchase List","text":"RustJavaSwiftJS/TS <pre><code>mod utils;\nuse testing::USER_SATOSHI;\nuse utils::init_sdk;\n\n#[allow(clippy::unwrap_used, clippy::expect_used)]\n#[tokio::main]\nasync fn main() {\n    // Initialize SDK\n    let (mut sdk, _cleanup) = init_sdk().await;\n    let user: utils::TestUser = (*USER_SATOSHI).clone().into();\n\n    // Create new user\n    sdk.create_new_user(&amp;user.username).await.unwrap();\n    sdk.init_user(&amp;user.username).await.unwrap();\n\n    // Create new wallet\n    sdk.set_password(&amp;user.pin, &amp;user.password).await.unwrap();\n    sdk.create_wallet_from_new_mnemonic(&amp;user.pin).await.unwrap();\n\n    // Get tx list\n    let tx_list = sdk.get_tx_list(0, 10).await.unwrap();\n    tx_list\n        .txs\n        .iter()\n        .for_each(|tx| println!(\"tx reference id: {:?}\", tx.reference_id));\n}\n</code></pre> <pre><code>package com.etogruppe.examples;\n\nimport com.etogruppe.CryptpaySdk;\n\npublic class GetTxList16 {\n\n    public static void main(String[] args) {\n\n        // initialize the sdk\n        CryptpaySdk sdk = utils.initSdk(utils.USERNAME_SATOSHI);\n\n        String password = utils.getEnvVariable(\"PASSWORD\");\n\n        try {\n            // create and init user\n            sdk.createNewUser(utils.USERNAME_SATOSHI);\n            sdk.initializeUser(utils.USERNAME_SATOSHI);\n            System.out.println(\"Created and initialized new user.\");\n\n            // create new wallet\n            sdk.setPassword(utils.PIN, password);\n            sdk.createNewWallet(utils.PIN);\n            System.out.println(\"Created and initialized new wallet.\");\n\n            // get tx list\n            String tx_list = sdk.txList(0, 10);\n            System.out.println(\"tx list: \" + tx_list);\n\n        } catch (Exception e) {\n            throw new RuntimeException(\"Get tx list example failed\", e);\n        }\n    }\n}\n</code></pre> <pre><code>\n</code></pre> <pre><code>import * as wasm from \"../pkg/cryptpay_sdk_wasm\";\nimport { initSdk } from './utils';\n\n\nasync function main() {\n    let username = \"satoshi\";\n    let start = 0;\n    let limit = 10;\n    let pin = \"1234\"; // Define the PIN\n    const sdk = await initSdk(username); // Initialize the SDK\n    let mnemonic: string = (process.env.MNEMONIC as string);\n    let password: string = (process.env.PASSWORD as string);\n\n    await sdk.createNewUser(username); //Creating a new user \n    await sdk.initializeUser(username); // Initialize the user\n\n    await sdk.setPassword(pin, password);\n    await sdk.createWalletFromMnemonic(pin, mnemonic); // Initialize the wallet\n    console.log(\"Wallet initialized!\");\n\n    let transactions = await sdk.getTransactionList(0, 10);  // Get the transaction list\n    console.log(\"Transactions: \" + JSON.stringify(transactions));\n}\n\nmain();\n</code></pre>"},{"location":"SDK%20Examples/Examples/#17-create-customer","title":"17. Create Customer","text":"RustJavaSwiftJS/TS <pre><code>mod utils;\nuse testing::USER_SATOSHI;\nuse utils::init_sdk;\n\n#[allow(clippy::unwrap_used, clippy::expect_used)]\n#[tokio::main]\nasync fn main() {\n    // Initialize SDK and create a new user\n    let (mut sdk, _cleanup) = init_sdk().await;\n    let user: utils::TestUser = (*USER_SATOSHI).clone().into();\n\n    sdk.create_new_user(&amp;user.username).await.unwrap();\n    sdk.init_user(&amp;user.username).await.unwrap();\n\n    // Create sap customer if not exists\n    if sdk.get_customer().await.is_err() {\n        sdk.create_customer(\"DE\").await.unwrap();\n    } else {\n        println!(\"Customer already exists\")\n    }\n}\n</code></pre> <pre><code>package com.etogruppe.examples;\n\nimport com.etogruppe.CryptpaySdk;\n\npublic class CreateCustomer17 {\n\n    public static void main(String[] args) {\n\n        // initialize the sdk\n        CryptpaySdk sdk = utils.initSdk(utils.USERNAME_SATOSHI);\n\n        try {\n            // create and init user\n            sdk.createNewUser(utils.USERNAME_SATOSHI);\n            sdk.initializeUser(utils.USERNAME_SATOSHI);\n            System.out.println(\"Created and initialized new user.\");\n\n            // Create sap customer if not exists\n            try {\n                sdk.customerGet();\n                System.out.println(\"sap customer exists.\");\n            } catch (Exception e) {\n                sdk.customerCreate(\"DE\");\n                System.out.println(\"created new sap customer\");\n            }\n\n        } catch (Exception e) {\n            throw new RuntimeException(\"Create new customer example failed\", e);\n        }\n    }\n}\n</code></pre> <pre><code>\n</code></pre> <pre><code>import * as wasm from \"../pkg/cryptpay_sdk_wasm\";\nimport { initSdk } from './utils';\n\nasync function main() {\n    let username = \"satoshi\";\n    const country_code = \"DE\";\n    const sdk = await initSdk(username);\n    await sdk.createNewUser(username);\n    await sdk.initializeUser(username);\n\n    try {\n        await sdk.getCustomer(); // Get customer details\n        console.log(\"Customer already exists.\");\n    } catch (error) {\n        console.log(error);\n        await sdk.createCustomer(country_code);\n        console.log(\"user created successfully\");\n    }\n\n}\n\nmain();\n</code></pre>"},{"location":"SDK%20Examples/Examples/#18-delete-user","title":"18. Delete User","text":"RustJavaSwiftJS/TS <pre><code>use sdk::types::newtypes::AccessToken;\nmod utils;\nuse testing::USER_ARCHIVEME;\nuse utils::init_sdk;\n\n// ---------------------------------------------\n// Note: Do not run this example with user `satoshi` because it will then be unverified and it will affect other examples / tests.\n// ---------------------------------------------\n\n#[allow(clippy::unwrap_used, clippy::expect_used)]\n#[tokio::main]\nasync fn main() {\n    // Initialize SDK\n    let (mut sdk, _cleanup) = init_sdk().await;\n    let user: utils::TestUser = (*USER_ARCHIVEME).clone().into();\n\n    // the `init_sdk()` function generates an access token for `satoshi`.\n    // in this example we use `archiveme` user. Therefore, we generate a new access token for the `archiveme` user.\n    let access_token = testing::get_access_token(&amp;user.username, user.password.as_str())\n        .await\n        .access_token;\n    let access_token = AccessToken::try_from(access_token).unwrap();\n    sdk.refresh_access_token(Some(access_token)).await.unwrap();\n\n    // Create new user\n    sdk.create_new_user(&amp;user.username).await.unwrap();\n    sdk.init_user(&amp;user.username).await.unwrap();\n\n    // Create new wallet\n    sdk.set_password(&amp;user.pin, &amp;user.password).await.unwrap();\n    sdk.create_wallet_from_new_mnemonic(&amp;user.pin).await.unwrap();\n\n    // Delete user\n    sdk.delete_user(Some(&amp;user.pin)).await.unwrap();\n    tokio::time::sleep(tokio::time::Duration::from_secs(2)).await;\n}\n</code></pre> <pre><code>package com.etogruppe.examples;\n\nimport com.etogruppe.CryptpaySdk;\n\npublic class DeleteUser18 {\n\n    public static void main(String[] args) {\n\n        // initialize the sdk\n        CryptpaySdk sdk = utils.initSdk(utils.USERNAME_ARCHIVEME);\n\n        String password = utils.getEnvVariable(\"PASSWORD\");\n\n        try {\n            // create and init user\n            sdk.createNewUser(utils.USERNAME_ARCHIVEME);\n            sdk.initializeUser(utils.USERNAME_ARCHIVEME);\n            System.out.println(\"Created and initialized new user.\");\n\n            // create and init new wallet\n            sdk.setPassword(utils.PIN, password);\n            sdk.createNewWallet(utils.PIN);\n            System.out.println(\"Created and initialized new wallet.\");\n\n            // Delete user and wallet\n            sdk.deleteUser(utils.PIN);\n\n            // check verification after deletion. Should be false\n            boolean verified = sdk.isKycVerified(utils.USERNAME_ARCHIVEME);\n            System.out.println(\"is verified: \" + verified);\n\n        } catch (Exception e) {\n            throw new RuntimeException(\"Delete user example failed\", e);\n        }\n    }\n}\n</code></pre> <pre><code>\n</code></pre> <pre><code>import * as wasm from \"../pkg/cryptpay_sdk_wasm\";\nimport { initSdk } from './utils';\n\nasync function main() {\n    let username = \"archiveme\";\n    let pin = \"1234\";\n\n    const sdk = await initSdk(username);\n    let password: string = (process.env.PASSWORD as string);\n    let mnemonic: string = (process.env.MNEMONIC as string);\n\n    await sdk.createNewUser(username);\n    await sdk.initializeUser(username);\n    await sdk.setPassword(pin, password);\n    await sdk.createWalletFromMnemonic(pin, mnemonic);\n    await sdk.deleteUser(pin);\n    console.log(\"user deleted_successfully\");\n}\n\nexport { main }\n</code></pre>"},{"location":"SDK%20Examples/Examples/#19-get-wallet-transaction-list","title":"19. Get Wallet Transaction List","text":"RustJavaSwiftJS/TS <pre><code>mod utils;\nuse testing::USER_SATOSHI;\nuse utils::init_sdk;\n\n#[allow(clippy::unwrap_used, clippy::expect_used)]\n#[tokio::main]\nasync fn main() {\n    // Initialize SDK\n    let (mut sdk, _cleanup) = init_sdk().await;\n    let user: utils::TestUser = (*USER_SATOSHI).clone().into();\n\n    // Create new user\n    sdk.create_new_user(&amp;user.username).await.unwrap();\n    sdk.init_user(&amp;user.username).await.unwrap();\n\n    // Create new wallet\n    sdk.set_password(&amp;user.pin, &amp;user.password).await.unwrap();\n    sdk.create_wallet_from_new_mnemonic(&amp;user.pin).await.unwrap();\n\n    // Get wallet tx list\n    let wallet_tx_list = sdk.get_wallet_tx_list(&amp;user.pin, 0, 10).await.unwrap();\n    wallet_tx_list\n        .transactions\n        .iter()\n        .for_each(|tx| println!(\"Wallet transaction id: {:?}\", tx.transaction_id));\n}\n</code></pre> <pre><code>package com.etogruppe.examples;\n\nimport com.etogruppe.CryptpaySdk;\n\npublic class GetWalletTxList19 {\n\n    public static void main(String[] args) {\n\n        // initialize the sdk\n        CryptpaySdk sdk = utils.initSdk(utils.USERNAME_SATOSHI);\n\n        String password = utils.getEnvVariable(\"PASSWORD\");\n\n        try {\n            // create and init user\n            sdk.createNewUser(utils.USERNAME_SATOSHI);\n            sdk.initializeUser(utils.USERNAME_SATOSHI);\n            System.out.println(\"Created and initialized new user.\");\n\n            // create new wallet\n            sdk.setPassword(utils.PIN, password);\n            sdk.createNewWallet(utils.PIN);\n            System.out.println(\"Created and initialized new wallet.\");\n\n            // get wallet_tx_list\n            String wallet_tx_list = sdk.getWalletTransactionList(utils.PIN, 0, 10);\n            System.out.println(\"wallet tx list: \" + wallet_tx_list);\n\n        } catch (Exception e) {\n            throw new RuntimeException(\"Get wallet tx list example failed\", e);\n        }\n    }\n}\n</code></pre> <pre><code>\n</code></pre> <pre><code>import * as wasm from \"../pkg/cryptpay_sdk_wasm\";\nimport { initSdk } from './utils';\n\n\nasync function main() {\n    let username = \"satoshi\";\n    let pin = \"1234\"; // Define the PIN\n\n    const sdk = await initSdk(username); // Initialize the SDK\n    let mnemonic: string = (process.env.MNEMONIC as string);\n    let password: string = (process.env.PASSWORD as string);\n\n    await sdk.createNewUser(username); //Creating a new user \n    await sdk.initializeUser(username); // Initialize the user\n    await sdk.setPassword(pin, password);\n    await sdk.createWalletFromMnemonic(pin, mnemonic); // Initialize the wallet\n    console.log(\"Wallet initialized!\");\n\n    let transactions = await sdk.getWalletTransactionList(pin, 0, 10);  // Get the transaction list\n    console.log(\"Wallet transactions list: \" + JSON.stringify(transactions));\n}\n\nmain();\n</code></pre>"},{"location":"SDK%20Examples/Examples/#20-send-compliment","title":"20. Send Compliment","text":"RustJavaSwiftJS/TS <pre><code>use api_types::api::transactions::ApiTxStatus;\nuse rust_decimal_macros::dec;\nuse sdk::types::{currencies::CryptoAmount, newtypes::AccessToken};\nuse std::time::Duration;\nuse testing::USER_HANS34;\nmod utils;\nuse tokio::time;\nuse utils::init_sdk;\n\n#[allow(clippy::unwrap_used)]\n#[tokio::main]\nasync fn main() {\n    // Initialize SDK for sender, create new user and migrate wallet\n    let (mut sdk, _cleanup) = init_sdk().await;\n    let user: utils::TestUser = (*USER_HANS34).clone().into();\n\n    // the `init_sdk()` function generates an access token for `satoshi`.\n    // in this example we use `hans34` user. Therefore, we generate a new access token for the `hans34` user.\n    let access_token = testing::get_access_token(&amp;user.username, user.password.as_str())\n        .await\n        .access_token;\n    let access_token = AccessToken::try_from(access_token).unwrap();\n    sdk.refresh_access_token(Some(access_token)).await.unwrap();\n\n    // Create new user\n    sdk.create_new_user(&amp;user.username).await.unwrap();\n    sdk.init_user(&amp;user.username).await.unwrap();\n\n    // Create / init new wallet from mnemonic\n    sdk.set_password(&amp;user.pin, &amp;user.password).await.unwrap();\n    sdk.create_wallet_from_existing_mnemonic(&amp;user.pin, &amp;user.mnemonic)\n        .await\n        .unwrap();\n\n    // Generate address and get balance\n    let address = sdk.generate_new_address(&amp;user.pin).await.unwrap(); // this is needed, otherwise the balance will be 0 and tx will fail\n    let balance = sdk.get_balance(&amp;user.pin).await.unwrap();\n    println!(\"Balance: {:#?} on address {}\", balance, address);\n\n    // Create purchase request\n    let product_hash = \"2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824\";\n    let app_data = \"{\\\"imageUrl\\\":\\\"https://httpbin.org/\\\",\\\"imageId\\\":\\\"a846ad10-fc69-4b22-b442-5dd740ace361\\\"}\";\n    let purchase_type = \"CLIK\";\n\n    let amount = CryptoAmount::try_from(dec!(2.0)).unwrap();\n    let purchase_id = sdk\n        .create_purchase_request(\"alice\", amount, product_hash, app_data, purchase_type)\n        .await\n        .unwrap();\n    println!(\"Purchase_id {} \", purchase_id); // print the purchase id to facilitate debugging\n\n    // Wait 3 min while tx status becomes valid\n    let result = time::timeout(Duration::from_secs(3 * 60), async {\n        loop {\n            time::sleep(Duration::from_secs(5)).await;\n            let details = sdk.get_purchase_details(&amp;purchase_id).await.unwrap();\n            match details.status {\n                ApiTxStatus::Valid =&gt; {\n                    println!(\"Purchase request valid, moving on...\");\n                    break;\n                }\n                ApiTxStatus::Invalid(r) =&gt; {\n                    panic!(\"Purchase request invalid! Reason: {:?}. Exiting\", r);\n                }\n                ApiTxStatus::WaitingForVerification(r) =&gt; {\n                    panic!(\"Purchase request waiting for verification! Reason: {:?}.\", r);\n                }\n                _ =&gt; {}\n            }\n        }\n    })\n    .await;\n    if result.is_err() {\n        panic!(\"Timeout reached while waiting for purchase request to become valid\");\n    }\n\n    // Step 4: Confirm purchase request (perform actual wallet transaction)\n    sdk.confirm_purchase_request(&amp;user.pin, &amp;purchase_id).await.unwrap();\n\n    // Wait 3 min while tx status becomes completed\n    let result = time::timeout(Duration::from_secs(3 * 60), async {\n        loop {\n            time::sleep(Duration::from_secs(5)).await;\n            let status = sdk.get_purchase_details(&amp;purchase_id).await.unwrap().status;\n            println!(\" - Status: {:?}\", status);\n            if status == ApiTxStatus::Completed {\n                println!(\"Purchase request completed, done!\");\n                break;\n            } else if status == ApiTxStatus::Failed {\n                panic!(\"Purchase request failed\");\n            }\n        }\n    })\n    .await;\n    if result.is_err() {\n        panic!(\"Timeout reached while waiting for purchase request to complete\");\n    }\n\n    // Check new balance\n    let balance = sdk.get_balance(&amp;user.pin).await.unwrap();\n    println!(\"New Balance: {:#?}\", balance);\n}\n</code></pre> <pre><code>package com.etogruppe.examples;\n\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.CompletionException;\nimport java.util.concurrent.ExecutionException;\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport com.etogruppe.CryptpaySdk;\nimport com.etogruppe.model.TxDetailsResponse;\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\npublic class SendCompliment20 {\n\n    public static void main(String[] args) throws InterruptedException, ExecutionException, TimeoutException {\n\n        // initialize the sdk\n        CryptpaySdk sdk = utils.initSdk(utils.USERNAME_HANS48);\n\n        String password = utils.getEnvVariable(\"PASSWORD\");\n        String mnemonic_hans48 = utils.getEnvVariable(\"MNEMONIC_HANS48\");\n\n        try {\n            // create and init user\n            sdk.createNewUser(utils.USERNAME_HANS48);\n            sdk.initializeUser(utils.USERNAME_HANS48);\n            System.out.println(\"Created and initialized new user.\");\n\n            // create new wallet\n            sdk.setPassword(utils.PIN, password);\n            sdk.createWalletFromMnemonic(utils.PIN, mnemonic_hans48);\n\n            System.out.println(\"Created and initialized new wallet from mnemonic.\");\n\n            // generate receiver address\n            String address = sdk.generateNewAddress(utils.PIN);\n            System.out.println(\"address: \" + address);\n\n            // get balance\n            double balance = sdk.getWalletBalance(utils.PIN);\n            System.out.println(\"balance: \" + balance);\n\n            // create purchase request\n            String product_hash = \"2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824\";\n            String app_data = \"java example\";\n            String purchase_type = \"CLIK\";\n\n            String purchase_id = sdk.purchaseRequestCreate(\"satoshi\", 1, product_hash, app_data, purchase_type);\n            System.out.println(\"purchase request id: \" + purchase_id);\n\n            CompletableFuture&lt;Void&gt; validFuture = CompletableFuture.runAsync(() -&gt; {\n                String valid = \"Valid\";\n                String invalid = \"Invalid\";\n                String waiting = \"WaitingForVerification\";\n                try {\n                    while (true) {\n                        Thread.sleep(5 * 1000); // Simulate waiting\n                        String purchase_details = null;\n                        try {\n                            purchase_details = sdk.purchaseDetails(purchase_id);\n                        } catch (Exception e) {\n                            throw new RuntimeException(\"Error fetching purchase details\", e);\n                        }\n                        TxDetailsResponse details;\n                        try {\n                            details = new ObjectMapper().readValue(purchase_details, TxDetailsResponse.class);\n                        } catch (JsonProcessingException e) {\n                            throw new RuntimeException(\"Error processing JSON response\", e);\n                        }\n                        System.out.println(\" - Status: \" + details.status);\n                        if (details.status.equals(valid)) {\n                            System.out.println(\"Purchase request valid, moving on...\");\n                            return;\n                        } else if (details.status.equals(waiting)) {\n                            throw new RuntimeException(\n                                    \"Purchase request invalid. Reason: \" + details.invalid_reasons + \" exiting!\");\n                        } else if (details.status.equals(invalid)) {\n                            throw new RuntimeException(\n                                    \"Purchase request invalid. Reason: \" + details.invalid_reasons + \" exiting!\");\n                        }\n                    }\n                } catch (InterruptedException e) {\n                    Thread.currentThread().interrupt();\n                    throw new RuntimeException(e);\n                }\n            }).exceptionally(ex -&gt; {\n                handleException(ex);\n                return null;\n            });\n\n            try {\n                validFuture.get(3 * 60, TimeUnit.SECONDS);\n            } catch (ExecutionException | TimeoutException e) {\n                validFuture.cancel(true);\n                throw new RuntimeException(\"Timeout reached while waiting for purchase request to become valid\", e);\n            }\n\n            // Confirm purchase request\n            sdk.purchaseRequestConfirm(utils.PIN, purchase_id);\n\n            // Wait 3 min while tx status becomes completed\n            CompletableFuture&lt;Void&gt; completedFuture = CompletableFuture.runAsync(() -&gt; {\n                String completed = \"Completed\";\n                String failed = \"Failed\";\n                try {\n                    while (true) {\n                        Thread.sleep(5 * 1000); // Simulate waiting\n                        String purchase_details = null;\n                        try {\n                            purchase_details = sdk.purchaseDetails(purchase_id);\n                        } catch (Exception e) {\n                            throw new RuntimeException(\"Error fetching purchase details\", e);\n                        }\n                        TxDetailsResponse details;\n                        try {\n                            details = new ObjectMapper().readValue(purchase_details, TxDetailsResponse.class);\n                        } catch (JsonProcessingException e) {\n                            throw new RuntimeException(\"Error processing JSON response\", e);\n                        }\n                        System.out.println(\" - Status: \" + details.status);\n                        if (details.status.equals(completed)) {\n                            System.out.println(\"Purchase request completed, done!\");\n                            return;\n                        } else if (details.status.equals(failed)) {\n                            throw new RuntimeException(\"Purchase request failed\");\n                        }\n                    }\n                } catch (InterruptedException e) {\n                    Thread.currentThread().interrupt();\n                    throw new RuntimeException(e);\n                }\n            }).exceptionally(ex -&gt; {\n                handleException(ex);\n                return null;\n            });\n\n            try {\n                completedFuture.get(3 * 60, TimeUnit.SECONDS); // Wait for up to 3 minutes\n            } catch (ExecutionException | TimeoutException e) {\n                completedFuture.cancel(true);\n                throw new RuntimeException(\"Timeout reached while waiting for purchase request to complete\", e);\n            }\n\n            // Check new balance\n            double new_balance = sdk.getWalletBalance(utils.PIN);\n            System.out.println(\"new balance: \" + new_balance);\n\n        } catch (Exception e) {\n            throw new RuntimeException(\"Send compliment example failed\", e);\n        }\n    }\n\n    private static Void handleException(Throwable ex) {\n        if (ex instanceof CompletionException) {\n            ex = ex.getCause();\n        }\n        if (ex instanceof RuntimeException) {\n            throw (RuntimeException) ex;\n        } else {\n            throw new RuntimeException(ex);\n        }\n    }\n}\n</code></pre> <pre><code>\n</code></pre> <pre><code>import * as wasm from \"../pkg/cryptpay_sdk_wasm\";\nimport { initSdk } from './utils';\n\n// Send compliment example with sender `alice` and receiver `satoshi`\n\nconst sleep = (delay: number) =&gt; new Promise((resolve) =&gt; setTimeout(resolve, delay));\nconst timeoutMs = 3 * 60 * 1000;\nconst timeoutPromise = new Promise&lt;never&gt;((_, reject) =&gt;\n    setTimeout(() =&gt; reject(new Error(\"Timeout reached!\")), timeoutMs)\n);\n\nasync function main() {\n    let username = \"alice\";\n    let pin = \"1234\";\n\n    // Initialize SDK\n    const sdk = await initSdk(username);\n\n    // Get env variables\n    let mnemonic: string = (process.env.MNEMONIC_ALICE as string);\n    let password: string = (process.env.PASSWORD as string);\n\n    // Create new user and initialize it\n    await sdk.createNewUser(username);\n    await sdk.initializeUser(username);\n\n\n    // Create new wallet and initialize it\n    await sdk.setPassword(pin, password);\n    await sdk.createWalletFromMnemonic(pin, mnemonic);\n\n    // Generate new receiver address and fetch current balance\n    let address = await sdk.generateNewAddress(pin);\n    console.log(\"Address:\", address);\n\n    let balance = await sdk.getWalletBalance(pin);\n    console.log(\"Balance:\", balance);\n\n    // Create new purchase request\n    let product_hash = \"2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824\";\n    let app_data = \"wasm send compliment example\";\n    let purchase_type = \"CLIK\";\n\n    let purchase_id = await sdk.createPurchaseRequest(\"satoshi\", 2, product_hash, app_data, purchase_type);\n    console.log(\"Purchase Request created: \", purchase_id);\n\n    // Wait 3 min while transaction status becomes `Valid`\n    console.log(\"Waiting until transaction status is `Valid`..\");\n    await Promise.race([\n        (async () =&gt; {\n            while (true) {\n                await sleep(5000);\n\n                let details = await sdk.getPurchaseDetails(purchase_id);\n                console.log(\"Details: \", details);\n\n                if (details.status == wasm.TxStatus.Valid) {\n                    console.log(\"Purchase request valid, moving on...\");\n                    return;\n                } else if (details.status == wasm.TxStatus.WaitingForVerification || details.status == wasm.TxStatus.Invalid) {\n                    throw new Error(\"Purchase request invalid. Reason: \" + details.invalid_reasons);\n                }\n            }\n        })(),\n        timeoutPromise\n    ]);\n\n    // When the transaction is Valid, confirm it\n    await sdk.confirmPurchaseRequest(pin, purchase_id);\n\n    // Wait 3 min while transaction status is `Complete`\n    console.log(\"Waiting until transaction status is `Complete`..\");\n    await Promise.race([\n        (async () =&gt; {\n            while (true) {\n                await sleep(5000);\n\n                let details = await sdk.getPurchaseDetails(purchase_id);\n                console.log(\"Details: \", details);\n\n                if (details.status == wasm.TxStatus.Completed) {\n                    console.log(\"Purchase request completed, done!\");\n                    return;\n                } else if (details.status == wasm.TxStatus.Failed) {\n                    throw new Error(\"Purchase request failed\");\n                }\n            }\n        })(),\n        timeoutPromise\n    ]);\n\n    // Get new balance after sending the compliment\n    let new_balance = await sdk.getWalletBalance(pin);\n    console.log(\"New Balance:\", new_balance);\n\n    // Forcefully exit the process to ensure it completes.\n    // The process may hang if there are pending operations or unresolved promises\n    // This ensures that the script terminates properly without delays\n    process.exit();\n}\n\nmain();\n</code></pre>"},{"location":"SDK%20Examples/Examples/#21-initialize-wallet-from-mnemonic","title":"21. Initialize Wallet from Mnemonic","text":"RustJavaSwiftJS/TS <p>Not available.</p> <p>Not available.</p>"},{"location":"SDK%20Modules/Managing%20user/","title":"User management","text":"<p>The SDK is designed to allow multiple users working with their own wallets on the same end devices sharing the same storage space. This makes it easy for a single person to have multiple alias users for different purposes and use different wallets for each of them to have a clear separation of risks.</p> <p>The user initialization is done by two main operations in the SDK.</p> <p>Creating a new user : This creates a new user in the in-memory database. All the properties of the user, like his selected KYC process, his KYC status, his access token for the backend, pin, encrypted password, etc... are set with the default values. A salt is generated for the user, which will be used later for encrypting the password.</p> <p>Initializing a user : This function initializes the user for a new session. It also checks that a valid access token has been provided by updating the KYC status of the user from the backend in the SDK internal state.</p>"},{"location":"SDK%20Modules/Managing%20user/#creating-a-new-user","title":"Creating a new user","text":"<p>User creation in the SDK is compulsory. This user is only a local user which might be already existing in the identity management provider.  </p> Note <p>The user might already exist in the OAuth system, as well as every where else, including Cawaena backend. However, the SDK associates the local user to the system user only when an access token is provided.</p> <p>The SDK supports multi-user environments and switching between users is fairly simple. Creating a user in the SDK informs the SDK about the user and allows the SDK to manage the user's state locally, whilst syncing it with the backend periodically.</p> <p>This allows the SDK to be used across multiple devices, and ideally on the same device, on multiple storage path prefixes. This means, that changing the storage path prefix would result in the SDK unknowing the existence of the user and would require to create the user once again.</p> <p>Creating a new user can be done using the <code>create_new_user</code> function which takes the <code>username</code> input parameter. Before creating a user, it is important that at least the storage path is set in the SDK.</p> <p>The <code>username</code> should always match the <code>preferred_username</code> claim on the JWT <code>access_token</code>, otherwise the SDK would not be able to access the backend services for that user. Through this, the newly created SDK local user gets recognized in the system as a valid user.</p> Tip <p>The application can extract the <code>preferred_username</code> information automatically from the JWT claim and set the username directly, instead of asking the user to enter the input. A user might mistype or misunderstand and enter a username which might later not work. This would lead to a bad end-user experience and should be avoided.</p> RustJavaSwift <pre><code>async fn main() {\n    dotenvy::dotenv().ok();\n    let path = \"/tmp/Cawaena\";\n\n    // ensure a clean start\n    tokio::fs::create_dir_all(path).await.unwrap();\n\n    let username = std::env::var(\"SATOSHI_USERNAME\").unwrap();\n\n    sdk.set_path_prefix(path);\n    sdk.validate_config().unwrap();\n\n    sdk.create_new_user(&amp;username).await.unwrap();\n\n    // other SDK functions\n\n}\n</code></pre> <pre><code>package org.example.app;\n\nimport com.etogruppe.CryptpaySdk;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.io.IOException;\nimport java.util.Map;\n\npublic class app {\n    private CryptpaySdk sdk;\n    public static void main(){\n        sdk = new CryptpaySdk();\n        String path = \"/tmp/Cawaena\"; \n\n        // ensure a clean start\n        try {\n            Files.createDirectories(Paths.get(path));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        Map&lt;String, String&gt; env = System.getenv();\n        String username = env.get(\"SATOSHI_USERNAME\");\n\n        try {\n            sdk.setStoragePath(path);\n            sdk.logLevel(\"info\");\n            sdk.initLogger();\n            sdk.checkConfig();\n            sdk.createNewUser(username);\n            // other SDK functions\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre> <pre><code>import Foundation\n\nlet path = \"/tmp/Cawaena\"\n\n// ensure a clean start\ndo {\n    try FileManager.default.createDirectory(atPath: path, withIntermediateDirectories: true, attributes: nil)\n} catch {\n    print(error.localizedDescription)\n}\n\nlet username = ProcessInfo.processInfo.environment[\"SATOSHI_USERNAME\"] ?? \"\"\n\nlet sdk = Sdk()\nsdk.setPathPrefix(path_prefix: path)\nsdk.setLogLevel(log_level: \"info\")\ndo {\n    try sdk.initLogger()\n    try sdk.checkConfig()\n    try sdk.createNewUser(username: username)\n    // other SDK functions\n} catch {\n    print(error.localizedDescription)\n}\n</code></pre>"},{"location":"SDK%20Modules/Managing%20user/#initializing-a-user-and-access-token-refresh","title":"Initializing a user and access token refresh","text":"<p>The user is created and needs to be initialized before any state updates or wallet-related operations can be performed for this user. This allows the SDK to create multiple users and by using the initializing function, only the selected user is activated for the session. Without initializing a user, all operations related to the user would fail or conversely the previously initialized user's session will be used and might corrupt the state! To protect this from happening, before initializing the user, a corresponding access token is required. An invalid access token would result in failure of the initialization.</p> <p>The access token brings the following safe operations for the SDK:</p> <ol> <li>Only the correct user with the username would be initialized. Mismatch would cause an error.</li> <li>The application can only initialize a user, only after the authorization of the actual person, since they would need to share their credentials for creating an access token.</li> <li>Any user whose rights have been revoked, due to misuse reports, would not be able to use the system as the access token would be invalid and generating a new one would not also work.</li> </ol> <p>Warning</p> <p>The user management is local to the end devices and deleting the application data, cache, temporary data files, etc... or changing the storage path prefix in the configuration would result in a loss of state and that would require the application to re-create and re-initialize user.</p> RustJavaSwift <pre><code>async fn main() {\n    dotenvy::dotenv().ok();\n    let path = \"/tmp/Cawaena\";\n\n    // ensure a clean start\n    tokio::fs::create_dir_all(path).await.unwrap();\n\n    let username = std::env::var(\"SATOSHI_USERNAME\").unwrap();\n    let access_token = std::env::var(\"ACCESS_TOKEN\").unwrap();\n\n    sdk.set_path_prefix(path);\n    sdk.validate_config().unwrap();\n\n    sdk.create_new_user(&amp;username).await.unwrap();\n\n    sdk.refresh_access_token(&amp;access_token).await.unwrap();\n    sdk.init_user(&amp;username).await.unwrap();\n\n    // other SDK functions now use the initialized user\n\n}\n</code></pre> <pre><code>package org.example.app;\n\nimport com.etogruppe.CryptpaySdk;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.io.IOException;\nimport java.util.Map;\n\npublic class app {\n    private CryptpaySdk sdk;\n    public static void main(){\n        sdk = new CryptpaySdk();\n        String path = \"/tmp/Cawaena\"; \n\n        // ensure a clean start\n        try {\n            Files.createDirectories(Paths.get(path));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        Map&lt;String, String&gt; env = System.getenv();\n        String username = env.get(\"SATOSHI_USERNAME\");\n        String accessToken = env.get(\"ACCESS_TOKEN\");\n\n        try {\n            sdk.setStoragePath(path);\n            sdk.logLevel(\"info\");\n            sdk.initLogger();\n            sdk.checkConfig();\n            sdk.createNewUser(username);\n\n            sdk.refreshAccessToken(accessToken);\n            sdk.initializeUser(username);\n            // other SDK functions now use the initialized user\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre> <pre><code>import Foundation\n\nlet path = \"/tmp/Cawaena\"\n\n// ensure a clean start\ndo {\n    try FileManager.default.createDirectory(atPath: path, withIntermediateDirectories: true, attributes: nil)\n} catch {\n    print(error.localizedDescription)\n}\n\nlet username = ProcessInfo.processInfo.environment[\"SATOSHI_USERNAME\"] ?? \"\"\nlet access_token = ProcessInfo.processInfo.environment[\"ACCESS_TOKEN\"] ?? \"\"\n\nlet sdk = Sdk()\nsdk.setPathPrefix(path_prefix: path)\nsdk.setLogLevel(log_level: \"info\")\ndo {\n    try sdk.initLogger()\n    try sdk.checkConfig()\n    try sdk.createNewUser(username: username)\n\n    try sdk.refreshAccessToken(access_token: access_token)\n    try sdk.initUser(username: username)\n    // other SDK functions\n} catch {\n    print(error.localizedDescription)\n}\n</code></pre> Example <p>Handling multiple users</p> RustJavaSwift <pre><code>async fn main() {\n    dotenvy::dotenv().ok();\n    let path = \"/tmp/Cawaena\";\n\n    // ensure a clean start\n    tokio::fs::create_dir_all(path).await.unwrap();\n\n    let username = std::env::var(\"SATOSHI_USERNAME\").unwrap();\n    let username2 = std::env::var(\"ANOTHER_USERNAME\").unwrap(); // Second user\n\n    let access_token = std::env::var(\"ACCESS_TOKEN\").unwrap();\n    let access_token2 = std::env::var(\"ACCESS_TOKEN2\").unwrap(); // Second user token\n\n    sdk.set_path_prefix(path);\n    sdk.validate_config().unwrap();\n\n    // Create both the users\n    sdk.create_new_user(&amp;username).await.unwrap();\n    sdk.create_new_user(&amp;username2).await.unwrap();\n\n    // Initialize the first user\n\n    sdk.refresh_access_token(&amp;access_token).await.unwrap();\n    sdk.init_user(&amp;username).await.unwrap();\n\n    // other SDK functions now use the initialized user\n    // do some stuff for first user\n\n    // Now initialize the second user to activate the user.\n    // First user will be inactive automatically\n\n    sdk.refresh_access_token(&amp;access_token2).await.unwrap();\n    sdk.init_user(&amp;username2).await.unwrap();\n\n    // Now the SDK uses the second user\n\n}\n</code></pre> <pre><code>package org.example.app;\n\nimport com.etogruppe.CryptpaySdk;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.io.IOException;\nimport java.util.Map;\n\npublic class app {\n    private CryptpaySdk sdk;\n    public static void main(){\n        sdk = new CryptpaySdk();\n        String path = \"/tmp/Cawaena\"; \n\n        // ensure a clean start\n        try {\n            Files.createDirectories(Paths.get(path));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        Map&lt;String, String&gt; env = System.getenv();\n        String username = env.get(\"SATOSHI_USERNAME\");\n        String username2 = env.get(\"ANOTHER_USERNAME\"); // Second user\n\n\n        String accessToken = env.get(\"ACCESS_TOKEN\");\n        String accessToken2 = env.get(\"ACCESS_TOKEN2\"); // Second user token\n\n        try {\n            sdk.setStoragePath(path);\n            sdk.logLevel(\"info\");\n            sdk.initLogger();\n            sdk.checkConfig();\n            sdk.createNewUser(username);\n\n            sdk.refreshAccessToken(accessToken);\n            sdk.initializeUser(username);\n            // other SDK functions now use the initialized user\n            // do some stuff for first user\n\n            // Now initialize the second user to activate the user.\n            // First user will be inactive automatically\n\n            sdk.refreshAccessToken(accessToken2);\n            sdk.initializeUser(username2);\n\n            // Now the SDK uses the second user\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre> <pre><code>import Foundation\n\nlet path = \"/tmp/Cawaena\"\n\n// ensure a clean start\ndo {\n    try FileManager.default.createDirectory(atPath: path, withIntermediateDirectories: true, attributes: nil)\n} catch {\n    print(error.localizedDescription)\n}\n\nlet username = ProcessInfo.processInfo.environment[\"SATOSHI_USERNAME\"] ?? \"\"\nlet username2 = ProcessInfo.processInfo.environment[\"ANOTHER_USERNAME\"] ?? \"\"\n\nlet access_token = ProcessInfo.processInfo.environment[\"ACCESS_TOKEN\"] ?? \"\"\nlet access_token2 = ProcessInfo.processInfo.environment[\"ACCESS_TOKEN2\"] ?? \"\"\n\nlet sdk = Sdk()\nsdk.setPathPrefix(path_prefix: path)\nsdk.setLogLevel(log_level: \"info\")\ndo {\n    try sdk.initLogger()\n    try sdk.checkConfig()\n    try sdk.createNewUser(username: username)\n\n    try sdk.refreshAccessToken(access_token: access_token)\n    try sdk.initUser(username: username)\n    // other SDK functions\n    // do some stuff for first user\n\n    // Now initialize the second user to activate the user.\n    // First user will be inactive automatically\n\n    try sdk.refreshAccessToken(access_token: access_token2)\n    try sdk.initUser(username: username2)\n\n    // Now the SDK uses the second user\n} catch {\n    print(error.localizedDescription)\n}\n</code></pre>"},{"location":"SDK%20Modules/Managing%20user/#deleting-a-user","title":"Deleting a user","text":"<p>Deleting the user is simply deleting the user entity from the local database, while maintaining entries for other users. The delete user also calls the backend API to trigger an archiving action for the user. Deleting the user also deletes all the local data files for the user, which in this case are files related to the wallet. Since, this is a one-way operation a user is required to enter the pin, that they have set for the wallet. If there is no wallet setup, the pin can be skipped and the user is simply deleted locally and archived in the backend.</p> <p>Danger</p> <p>Deleting a user not only deletes the user in the system but also deletes all local files and information from the device. This means, that the wallet is also deleted. Hence, a pin is used to verify if the user wishes to delete all this information. Deletion of a wallet without having a backup file or without the mnemonic is extremely dangerous as it can potentially lead to permanent loss of funds.</p> RustJavaSwift <pre><code>async fn main() {\n    dotenvy::dotenv().ok();\n    let path = \"/tmp/Cawaena\";\n\n    // ensure a clean start\n    tokio::fs::create_dir_all(path).await.unwrap();\n\n    let username = std::env::var(\"SATOSHI_USERNAME\").unwrap();\n    let access_token = std::env::var(\"ACCESS_TOKEN\").unwrap();\n\n\n    sdk.set_path_prefix(path);\n    sdk.validate_config().unwrap();\n\n    sdk.create_new_user(&amp;username).await.unwrap();\n\n    sdk.refresh_access_token(&amp;access_token).await.unwrap();\n    sdk.init_user(&amp;username).await.unwrap();\n\n    // other SDK functions now use the initialized user\n    let pin = \"1234\"; // only if wallet was created by the user, a pin value is required\n    sdk.delete_user(pin).await.unwrap();\n\n}\n</code></pre> <pre><code>package org.example.app;\n\nimport com.etogruppe.CryptpaySdk;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.io.IOException;\nimport java.util.Map;\n\npublic class app {\n    private CryptpaySdk sdk;\n    public static void main(){\n        sdk = new CryptpaySdk();\n        String path = \"/tmp/Cawaena\"; \n\n        // ensure a clean start\n        try {\n            Files.createDirectories(Paths.get(path));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        Map&lt;String, String&gt; env = System.getenv();\n        String username = env.get(\"SATOSHI_USERNAME\");\n        String accessToken = env.get(\"ACCESS_TOKEN\");\n\n        try {\n            sdk.setStoragePath(path);\n            sdk.logLevel(\"info\");\n            sdk.initLogger();\n            sdk.checkConfig();\n            sdk.createNewUser(username);\n\n            sdk.refreshAccessToken(accessToken);\n            sdk.initializeUser(username);\n            // other SDK functions now use the initialized user\n            String pin = \"1234\"; // only if wallet was created by the user, a pin value is required\n            sdk.deleteUser(pin)\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre> <pre><code>import Foundation\n\nlet path = \"/tmp/Cawaena\"\n\n// ensure a clean start\ndo {\n    try FileManager.default.createDirectory(atPath: path, withIntermediateDirectories: true, attributes: nil)\n} catch {\n    print(error.localizedDescription)\n}\n\nlet username = ProcessInfo.processInfo.environment[\"SATOSHI_USERNAME\"] ?? \"\"\nlet access_token = ProcessInfo.processInfo.environment[\"ACCESS_TOKEN\"] ?? \"\"\n\nlet sdk = Sdk()\nsdk.setPathPrefix(path_prefix: path)\nsdk.setLogLevel(log_level: \"info\")\ndo {\n    try sdk.initLogger()\n    try sdk.checkConfig()\n    try sdk.createNewUser(username: username)\n\n    try sdk.refreshAccessToken(access_token: access_token)\n    try sdk.initUser(username: username)\n    // other SDK function\n    let pin = \"1234\"; // only if wallet was created by the user, a pin value is required\n    try sdk.deleteUser(pin: pin)\n} catch {\n    print(error.localizedDescription)\n}\n</code></pre> Bug <p>Currently, the delete user does require a pin and it is not optional. For this, the wallet should be initialized using the appropriate method for the delete user function to successfully execute.</p>"},{"location":"SDK%20Modules/Managing%20user/#user-lifecycle-overview","title":"User lifecycle overview","text":"<pre><code>      Username    Refresh access   Username              Pin              \n         |            token          |                      |             \n         |             |             |                      |             \n         |             |             |                      |             \n         |             |             |                      |             \n    +----v---------+   |     +-------v------+        +------v---------+   \n    |              |   |     |              |        |                |   \n    |  Create      |   |     | Initialize   |        |     Delete     |   \n    |  new         +---v-----&gt; User         +--------&gt;     User       |   \n    |  User        |         |              |        |                |   \n    +--------------+         +-----+--------+        +----------------+   \nOnce                                |\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nMultiple                            |\nTimes                   +-----------v-----------------+\n                        |  User           Wallet      |\n                        |  State          Operations  |\n                        |  Change                     |\n                        +-----------------------------+\n</code></pre>"},{"location":"SDK%20Modules/Managing%20wallet/","title":"Wallet management","text":"<p>The SDK provides users with the opportunity to host their own wallets on their personal end-devices in a safe and easy manner. Before discussing wallet management, some information on wallets and what they are is needed to understand how to manage non-custodial hot wallets.</p>"},{"location":"SDK%20Modules/Managing%20wallet/#creating-the-wallet","title":"Creating the wallet","text":"<p>The stronghold secret manager requires a file path for the wallet and a password to unlock this file. This password disables other applications from interpreting the files created by the stronghold engine and needs to come from the user.</p> <p>The IOTA SDK offers an account manager structure which comprises of various fields to work with the wallet and the internal wallet accounts. The SDK creates a standard account <code>standalone</code> for its usage. There might be other accounts that could exist and are not operated upon by the SDK. The following ways can be used to create a wallet in the SDK:</p>"},{"location":"SDK%20Modules/Managing%20wallet/#create-a-new-wallet","title":"Create a new wallet","text":"<p>This does not require any user input except <code>username</code>,  <code>password</code> and <code>pin</code>. But, this should be a multi-step process. The created wallet returns a mnemonic. The app should immediately delete the wallet. In the second step the migration of the wallet with the mnemonic should be carried out and the wallet is only loaded with the mnemonic entered by the user. This approach protects the user against creating a wallet without never confirming the mnemonic back to the SDK and also by deleting a wallet, the SDK can ensure that there is actually no wallet created whose mnemonic was never entered from outside the application. This forces applications to have their end-users the mnemonic either memorized or input from a copy.</p> Info <p>A fresh wallet can be created by a random seed, using the stronghold secret manager. It needs the password and username. The username is part of the file path and helps distinguish across different user wallets on the same end device. It returns the mnemonic, and this needs to be securely stored by the user, otherwise access to the funds on the wallet addresses would get limited. A node url for the DLT network can also be selected. Currently, the PoW is set to local, however it might change based on the used node url and its support for PoW.</p> RustJavaSwift <pre><code>async fn main() {\n    dotenvy::dotenv().ok();\n    let path = \"/tmp/Cawaena\";\n\n    // ensure a clean start\n    tokio::fs::create_dir_all(path).await.unwrap();\n\n    let password = std::env::var(\"SATOSHI_PASSWORD\").unwrap();\n    let pin = std::env::var(\"SATOSHI_PIN\").unwrap();\n\n    // Create and initialize the user\n    //...\n\n    let mnemonic = sdk.create_new_wallet(&amp;pin, &amp;password).await.unwrap();\n    sdk.verify_mnemonic(&amp;pin, &amp;password, &amp;mnemonic).await.unwrap();\n\n    // If no exception is thrown, the mnemonic was verified...\n    // now the wallet can be initialized and used...\n\n}\n</code></pre> <pre><code>package org.example.app;\n\nimport com.etogruppe.CryptpaySdk;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.io.IOException;\nimport java.util.Map;\n\npublic class app {\n    private CryptpaySdk sdk;\n    public static void main(){\n        // Create and initialize the user\n        //...\n\n        try {\n            String password = env.get(\"SATOSHI_PASSWORD\");\n            String pin = env.get(\"SATOSHI_PIN\");\n\n            String mnemonic = \"\";\n            mnemonic = sdk.createNewWallet(pin, password);\n            // return the mnemonic to the user to verify it\n\n            sdk.verMnemonic(pin, password, mnemonic); \n            // If no exception is thrown, the mnemonic was verified...\n            // now the wallet can be initialized and used...\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre> <pre><code>// Create and initialize the user\n//...\ndo {\n    let password = ProcessInfo.processInfo.environment[\"SATOSHI_PASSWORD\"] ?? \"\"\n    let pin = ProcessInfo.processInfo.environment[\"SATOSHI_PIN\"] ?? \"\"\n\n    var mnemonic = \"\"\n    mnemonic = try sdk.createNewWallet(pin: pin, password: password)\n    try sdk.verifyMnemonic(pin: pin, password: password, mnemonic: mnemonic)\n    // If no exception is thrown, the mnemonic was verified...\n    // now the wallet can be initialized and used..\n\n} catch {\n    print(error.localizedDescription)\n}\n</code></pre>"},{"location":"SDK%20Modules/Managing%20wallet/#migrate-an-existing-wallet","title":"Migrate an existing wallet","text":"<p>This just performs the second step of the create fresh wallet process and needs in addition to the <code>mnemonic</code> also the <code>username</code>, <code>password</code> and <code>pin</code>.</p> RustJavaSwift <pre><code>async fn main() {\n    dotenvy::dotenv().ok();\n    let path = \"/tmp/Cawaena\";\n\n    // ensure a clean start\n    tokio::fs::create_dir_all(path).await.unwrap();\n\n    let password = std::env::var(\"SATOSHI_PASSWORD\").unwrap();\n    let pin = std::env::var(\"SATOSHI_PIN\").unwrap();\n    let mnemonic = \"\"; // User should enter their mnemonic\n\n    // Create and initialize the user\n    //...\n\n    sdk.create_wallet_from_mnemonic(&amp;pin, &amp;password,&amp;mnemonic).await.unwrap();\n\n    // If no exception is thrown, the mnemonic was verified...\n    // now the wallet can be initialized and used...\n\n}\n</code></pre> <pre><code>package org.example.app;\n\nimport com.etogruppe.CryptpaySdk;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.io.IOException;\nimport java.util.Map;\n\npublic class app {\n    private CryptpaySdk sdk;\n    public static void main(){\n        // Create and initialize the user\n        //...\n\n        try {\n            String password = env.get(\"SATOSHI_PASSWORD\");\n            String pin = env.get(\"SATOSHI_PIN\");\n\n            String mnemonic = \"\"; // User should enter their mnemonic\n            sdk.createWalletFromMnemonic(pin, password, mnemonic);\n\n            // If no exception is thrown, the mnemonic was verified...\n            // now the wallet can be initialized and used...\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre> <pre><code>// Create and initialize the user\n//...\ndo {\n    let password = ProcessInfo.processInfo.environment[\"SATOSHI_PASSWORD\"] ?? \"\"\n    let pin = ProcessInfo.processInfo.environment[\"SATOSHI_PIN\"] ?? \"\"\n\n    let mnemonic = \"\" // User should enter their mnemonic\n    try sdk.createWalletFromMnemonic(pin: pin, password: password, mnemonic: mnemonic)\n    // If no exception is thrown, the mnemonic was verified...\n    // now the wallet can be initialized and used..\n\n} catch {\n    print(error.localizedDescription)\n}\n</code></pre>"},{"location":"SDK%20Modules/Managing%20wallet/#from-a-wallet-backup-file","title":"From a wallet backup file","text":"<p>If the user has created a backup from any other devices or wallet applications using the stronghold file format, this file can be used to restore the wallet by creating a new wallet from the backup file. All existing accounts as well as mnemonic information are restored.</p> RustJavaSwift <pre><code>async fn main() {\n    dotenvy::dotenv().ok();\n    let path = \"/tmp/Cawaena\";\n\n    // ensure a clean start\n    tokio::fs::create_dir_all(path).await.unwrap();\n\n    let password = std::env::var(\"SATOSHI_PASSWORD\").unwrap(); // This is the password used while creating backup!\n    let pin = std::env::var(\"SATOSHI_PIN\").unwrap();\n    let backup_path = \"\"; // The path to the backup file\n\n    // Create and initialize the user\n    //...\n\n    sdk.create_wallet_from_backup(&amp;pin, &amp;password,&amp;backup_path).await.unwrap();\n\n    // If no exception is thrown, the backup was successfully restored...\n    // now the wallet can be initialized and used...\n\n}\n</code></pre> <pre><code>package org.example.app;\n\nimport com.etogruppe.CryptpaySdk;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.io.IOException;\nimport java.util.Map;\n\npublic class app {\n    private CryptpaySdk sdk;\n    public static void main(){\n        // Create and initialize the user\n        //...\n\n        try {\n            String password = env.get(\"SATOSHI_PASSWORD\"); // This is the password used while creating backup!\n            String pin = env.get(\"SATOSHI_PIN\");\n\n            String backup_path = \"\"; // The path to the backup file\n            sdk.createWalletFromBackup(pin, password, backup_path);\n\n            // If no exception is thrown, the backup was successfully restored...\n            // now the wallet can be initialized and used...\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre> <pre><code>// Create and initialize the user\n//...\ndo {\n    let password = ProcessInfo.processInfo.environment[\"SATOSHI_PASSWORD\"] ?? \"\" // This is the password used while creating backup!\n    let pin = ProcessInfo.processInfo.environment[\"SATOSHI_PIN\"] ?? \"\"\n\n    let backup_path = \"\" // The path to the backup file\n    try sdk.createWalletFromBackup(pin: pin, password: password, backup_path: backup_path)\n    // If no exception is thrown, the backup was successfully restored...\n    // now the wallet can be initialized and used...\n\n} catch {\n    print(error.localizedDescription)\n}\n</code></pre> <p>This restores an existing wallet from a backup file. It requires the <code>backup path</code> of the file as well the <code>backup password</code> in addition to the <code>password</code> of the backup and the new <code>pin</code> to be used.</p>"},{"location":"SDK%20Modules/Managing%20wallet/#creating-a-wallet-backup","title":"Creating a wallet backup","text":"<p>The SDK also provides function to create a stronghold backup file. This file is generated and stored in the path defined as <code>{path_prefix}/backups/{coin_type}/{username}/{Unix date time in seconds}.stronghold</code>. This file can be given to the user to download the backup and securely store it outside the application. The same backup file can be used to restore the wallet on other devices as well as in other application supporting stronghold files.</p> <p>A <code>password</code> is also required to create the backup and the same <code>password</code> is required for restoring the backup. The backup can be created only if a wallet exists an it is successfully initialized for use. Uninitialized wallets need to be initialized before creating their backups.</p> RustJavaSwiftRustJavaSwift <pre><code>async fn main() {\n    dotenvy::dotenv().ok();\n    let path = \"/tmp/Cawaena\";\n\n    // ensure a clean start\n    tokio::fs::create_dir_all(path).await.unwrap();\n\n    let backup_password = std::env::var(\"SATOSHI_BACKUP_PASSWORD\").unwrap(); // This is the password used while creating backup!\n    // Create and initialize the user\n    // Create the wallet\n    // Initialize the wallet\n    let path = sdk.create_wallet_backup(&amp;backup_password).await.unwrap();\n\n    // the function also returns the path to the backup file\n\n}\n</code></pre> <pre><code>package org.example.app;\n\nimport com.etogruppe.CryptpaySdk;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.io.IOException;\nimport java.util.Map;\n\npublic class app {\n    private CryptpaySdk sdk;\n    public static void main(){\n        // Create and initialize the user\n        // Create the wallet\n        // Initialize the wallet\n\n        try {\n            String backup_password = env.get(\"BACKUP_PASSWORD\"); // This is the password used while creating backup!\n\n            String backup_path = sdk.createWalletBackup(backup_password);\n\n            // the function also returns the path to the backup file\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre> <pre><code>// Create and initialize the user\n// Create the wallet\n// Initialize the wallet\ndo {\n    let backup_password = ProcessInfo.processInfo.environment[\"SATOSHI_BACKUP_PASSWORD\"] ?? \"\" // This is the password used while creating backup!\n\n    let backup_path = try sdk.createWalletBackup(password: backup_password)\n    // the function also returns the path to the backup file\n\n} catch {\n    print(error.localizedDescription)\n}\n</code></pre> <pre><code>async fn main() {\n    dotenvy::dotenv().ok();\n    let path = \"/tmp/Cawaena\";\n\n    // ensure a clean start\n    tokio::fs::create_dir_all(path).await.unwrap();\n\n    let backup_password = std::env::var(\"SATOSHI_BACKUP_PASSWORD\").unwrap(); // This is the password used while creating backup!\n    // Create and initialize the user\n    // Create the wallet\n    // Initialize the wallet\n    let path = sdk.create_wallet_backup(&amp;backup_password).await.unwrap();\n\n    // the function also returns the path to the backup file\n\n}\n</code></pre> <pre><code>package org.example.app;\n\nimport com.etogruppe.CryptpaySdk;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.io.IOException;\nimport java.util.Map;\n\npublic class app {\n    private CryptpaySdk sdk;\n    public static void main(){\n        // Create and initialize the user\n        // Create the wallet\n        // Initialize the wallet\n\n        try {\n            String backup_password = env.get(\"BACKUP_PASSWORD\"); // This is the password used while creating backup!\n\n            String backup_path = sdk.createWalletBackup(backup_password);\n\n            // the function also returns the path to the backup file\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre> <pre><code>// Create and initialize the user\n// Create the wallet\n// Initialize the wallet\ndo {\n    let backup_password = ProcessInfo.processInfo.environment[\"SATOSHI_BACKUP_PASSWORD\"] ?? \"\" // This is the password used while creating backup!\n\n    let backup_path = try sdk.createWalletBackup(password: backup_password)\n    // the function also returns the path to the backup file\n\n} catch {\n    print(error.localizedDescription)\n}\n</code></pre>"},{"location":"SDK%20Modules/Managing%20wallet/#initializing-the-wallet","title":"Initializing the wallet","text":"<p>For performing any operations involving the wallet, like fetching wallet balance, or send a transfer or generating a new address, the wallet needs to be initialized. The initialization also requires a <code>pin</code> entry from the application user, guaranteeing that the wallet cannot be misused.</p> RustJavaSwift <pre><code>async fn main() {\n    dotenvy::dotenv().ok();\n    let path = \"/tmp/Cawaena\";\n\n    // ensure a clean start\n    tokio::fs::create_dir_all(path).await.unwrap();\n\n    // Initialize the wallet\n    let pin = \"1234\"; // User enters the pin\n    sdk.init_wallet(&amp;pin).await.unwrap();\n\n    // Now all wallet functions can be called\n\n}\n</code></pre> <pre><code>package org.example.app;\n\nimport com.etogruppe.CryptpaySdk;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.io.IOException;\nimport java.util.Map;\n\npublic class app {\n    private CryptpaySdk sdk;\n    public static void main(){\n        // Initialize the wallet\n\n        try {\n            String pin = \"1234\"; // User enters the pin\n\n            sdk.initializeWallet(pin);\n\n            // Now all wallet functions can be called\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre> <pre><code>// Initialize the wallet\ndo {\n\n    let pin = \"1234\"; // User enters the pin\n    try sdk.initWallet(pin: pin)\n\n    // Now all wallet functions can be called\n\n\n} catch {\n    print(error.localizedDescription)\n}\n</code></pre>"},{"location":"SDK%20Modules/Managing%20wallet/#deleting-the-wallet","title":"Deleting the wallet","text":"<p>This function just deletes the wallet files and is a one-way function, to be used under extreme caution, as it could result in permanent loss of funds. Note that, similar to any other wallet operation, deleting the wallet is also a wallet operation and requires the wallet to be correctly initialized. Without initialization, the deletion of wallet would fail.</p> RustJavaSwift <pre><code>async fn main() {\n    dotenvy::dotenv().ok();\n    let path = \"/tmp/Cawaena\";\n\n    // ensure a clean start\n    tokio::fs::create_dir_all(path).await.unwrap();\n\n    // Initialize the wallet\n    let pin = \"1234\"; // User enters the pin\n    sdk.init_wallet(&amp;pin).await.unwrap();\n\n    // Only initialized wallets can be deleted\n    sdk.delete_wallet();\n\n}\n</code></pre> <pre><code>package org.example.app;\n\nimport com.etogruppe.CryptpaySdk;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.io.IOException;\nimport java.util.Map;\n\npublic class app {\n    private CryptpaySdk sdk;\n    public static void main(){\n        // Initialize the wallet\n\n        try {\n            String pin = \"1234\"; // User enters the pin\n\n            sdk.initializeWallet(pin);\n\n            // Only initialized wallets can be deleted\n            sdk.deleteWallet();\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre> <pre><code>// Initialize the wallet\ndo {\n\n    let pin = \"1234\"; // User enters the pin\n    try sdk.initWallet(pin: pin)\n\n    // Only initialized wallets can be deleted\n    try sdk.deleteWallet()\n\n\n} catch {\n    print(error.localizedDescription)\n}\n</code></pre>"},{"location":"SDK%20Modules/Managing%20wallet/#password-and-pin-utilities","title":"Password and pin utilities","text":"<p>In addition to creating, migrating, backups and initialization, the wallet module also performs auxiliary operations for pin and password management. It supports function to reset the pin using password, verify the pin, or change the wallet password using the current password and pin. Wallet initialization is again a pre-requisite, since the pin and password operations are related to the wallet and can only be performed once a wallet is initialized successfully.</p> RustJavaSwift <pre><code>async fn main() {\n    dotenvy::dotenv().ok();\n    let path = \"/tmp/Cawaena\";\n\n    // ensure a clean start\n    tokio::fs::create_dir_all(path).await.unwrap();\n\n    // Initialize the wallet\n    let pin = \"1234\"; // User enters the pin\n    sdk.init_wallet(&amp;pin).await.unwrap();\n\n    // Try to verify the pin\n    sdk.verify_pin(&amp;pin);\n    let new_pin = \"1235\";\n    let password = \"StrongP@55w0rd\";\n    // or reset the pin to a new one\n    sdk.reset_pin(&amp;password,&amp;new_pin)\n    // or change the password\n    let new_password = \"StrongP@55W0rd\";\n    sdk.change_password(&amp;pin,&amp;password,&amp;new_password);\n}\n</code></pre> <pre><code>package org.example.app;\n\nimport com.etogruppe.CryptpaySdk;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.io.IOException;\nimport java.util.Map;\n\npublic class app {\n    private CryptpaySdk sdk;\n    public static void main(){\n        // Initialize the wallet\n\n        try {\n            String pin = \"1234\"; // User enters the pin\n\n            sdk.initializeWallet(pin);\n\n            // Try to verify the pin\n            sdk.pinVerify(pin);\n            String new_pin = \"1235\";\n            String password = \"StrongP@55w0rd\";\n            // or reset the pin to a new one\n            sdk.pinReset(password, new_pin);\n            // or change the password\n            String new_password = \"StrongP@55W0rd\";\n            sdk.passwordChange(pin, password, new_password);\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre> <pre><code>// Initialize the wallet\ndo {\n\n    let pin = \"1234\"; // User enters the pin\n    try sdk.initWallet(pin: pin)\n\n    // Try to verify the pin\n    try sdk.verifyPin(pin: pin)\n    let new_pin = \"1235\";\n    let password = \"StrongP@55w0rd\";\n    // or reset the pin to a new one\n    try sdk.resetPin(password: password, new_pin: new_pin)\n    // or change the password\n    let new_password = \"StrongP@55W0rd\";\n    try sdk.changePassword(pin: pin, current_password: password, new_password: new_password)\n\n} catch {\n    print(error.localizedDescription)\n}\n</code></pre>"},{"location":"SDK%20Modules/Managing%20wallet/#wallet-flows","title":"Wallet flows","text":"<pre><code>                Mnemonic  Username  Password  Pin  backup password         Pin                            Pin        \n                   | ^         |      |       |      |                     |                              |          \n                   | |         |      |       |      |                     |                              |          \n                   | |         |      |       |      |                     |                              |          \n                   | |         |      |       |      |                     |                              |          \n                   | |         |      |       |      |                     |                              |          \n                   | |         |      |       |      |                     |                              |          \n                   | |         |      |       |      |                     |                              |          \n    Inputs         v |         v      v       v      v                     v                              v          \n-------------------------------------------------------------------------------------------------------------------  \n                                                                |                           |                        \n                                           +-------------+      |                           |                        \n                                           |             |      |                           |                        \n                                           | Create      |      |      +-------------+      |                        \n                                           | New         +---+  |      |             |      |        +--------------+\n                                           | Wallet      |   |  |      |  Initialize |      |        |              |\n                                           |             |   |  |      |  Wallet     +------+--------&gt;   Delete     |\n                                           +-------------+   |  +------&gt;             |      |        |   wallet     |\n                                                             |  |      |             |      |        |   (external) |\n                                                             |  |      +------+------+      |        |              |\n                         +----------+      +-------------+   |  |             |             |        +--------------+\n                         |          |      |             |   |  |             |             |                        \n                         | Mnemonic |      | Migrate     |   |  |             |             |                        \n                 +-------&gt;          +------&gt; Existing    |   |  |             |             |                        \n                 |       |          |      | Wallet      |   |  |      +------v------+      |                        \n                 |       |          |      |             |   |  |      |             |      |                        \n                 |       +----------+      +-------------+   |  |      |  User       |      |                        \n                 |                                           |  |      |  Wallet     |      |                        \n                 |                                           |  |      |  Functions  |      |                        \n                 |           +------+      +-------------+   |  |      |             |      |                        \n                 |           |      |      |             |   |  |      +-------------+      |                        \n                 |           |Backup|      | Create      |   |  |                           |                        \n                 |           | File +------&gt; Wallet      |   |  |                           |                        \n                 |           |      |      | From        |   |  |                           |                        \n                 |           |      |      | Backup      |   |  |                           |                        \n                 |           +------+      +-------------+   |  |                           |                        \n                 |                                           |  |                           |                        \n                 |                                           |  |                           |                        \n                 |    +-------------+      +-------------+   |  |                           |                        \n                 |    |             |      |             |   |  |                           |                        \n                 |    | Verify      |      |  Delete     |   |  |                           |                        \n                 +----+ Mnemonic    &lt;------+  wallet     &lt;---+  |                           |                        \n                      |             |      | (internal)  |      |                           |                        \n                      |             |      |             |      |                           |                        \n                      +-------------+      +-------------+      |                           |                        \n                                                                |                           |                        \n                                                                |                           |                        \n                                             Once(setup)        |        Multiple times     |       Once (tear down) \n                                                                |                           |                        \n</code></pre>"},{"location":"SDK%20Modules/Transactions_Swaps_Purchases/","title":"Transactions, Swaps and Purchases","text":"<p>The SDK is primarily used to perform transactions. The type of transactions that the SDK currently facilitates are</p> <ol> <li>Wallet transactions</li> <li>Swap transactions</li> <li>Purchase transactions</li> </ol>"},{"location":"SDK%20Modules/Transactions_Swaps_Purchases/#wallet-transactions-flow","title":"Wallet transactions flow","text":"<pre><code>+---------------+                      +---------------+\n|               |                      |               |\n|               |                      | Wallet        |\n| Wallet        +----------------------&gt; Address       |\n| Address       |                      | Receiver      |\n| Sender        |                      |               |\n+---------------+                      +---------------+\n</code></pre> <p>The wallet transaction is a simple transfer of funds from one address to another facilitated by the DLT network node and the wallet software running within the SDK.</p>"},{"location":"SDK%20Modules/Transactions_Swaps_Purchases/#swap-transactions-flow","title":"Swap transactions flow","text":"<p>A swap is simply an exchange of value from one currency to another. In the current scenario, the swap is always between SMR &lt;--&gt; EURO currencies. This is executed at viviswap exchange.</p> <p>For payments in EURO, only the SEPA transfer method is currently supported. See the german explanation here and the english explanation here</p> <p>The EURO payment needs the user to setup and add their IBAN (International Bank Account Number) to the viviswap exchange. Through this, the viviswap uses SEPA transfers to this IBAN, whenever a swap is triggered from SMR to EURO. The other way around, currently, since direct debit is not setup from the bank of viviswap, the user has to transfer manually from exactly this IBAN (viviswap verifies it in every transfer) to the IBAN owned by viviswap with the amount and a reference number provided by viviswap.</p> <ol> <li><code>get_iban_for_viviswap</code>: This function allows the user query their own IBAN saved at viviswap.</li> <li><code>ensure_detail</code>: This function verifies if a detail created at viviswap is legitimate, syntactically and semantically. A detail is basically an address for a particular payment method. The various payment methods used by viviswap are SMR, IOTA, BTC, ETH, etc... for crypto-currencies and PAYPAL, SEPA, etc... for EURO payments. For example, the address for the payment method SMR would be shimmer wallet address and the address for the payment method SEPA would be the IBAN.</li> <li><code>update_iban_for_viviswap</code>: This function updates the IBAN of the user in the viviswap exchange. The update is actually an advanced <code>upsert</code> action. The update would insert the IBAN if none exists and also replace the existing IBAN with the new one.</li> <li><code>create_deposit_with_viviswap</code>: This function creates details of a fiat to crypto swap. Deposit is to be understood as deposit of funds to a crypto currency address. Currently, the swap is between EURO to SMR. Since, there is no direct debit authorization available, creating the deposit generally means getting information about the bank details of viviswap and the reference number, and advising the user to make a SEPA transfer in the required amount.</li> <li><code>create_detail_for_viviswap</code>: This function creates a user detail for a payment method. This could be adding the crypto address for a certain payment method to the viviswap exchange. This detail with its id can then be directly used for the swaps.</li> <li><code>get_payment_method_id_viviswap</code>: This is a generic function and has to be called once to cache the UUIDs of all the payment methods supported by viviswap.</li> <li><code>create_withdrawal_with_viviswap</code>: This function is the opposite of deposit. Withdrawal is to be understood as withdrawal of funds from a crypto currency address. If a pin is provided, the function automatically immediately transfers money from the crypto address of the user to that of viviswap and ideally viviswap would automatically transfer the funds to the IBAN created in their system. If no pin is provided, the user is shown the crypto address of the chosen payment method and the user can decide to transfer the funds to this address at any point.</li> <li><code>get_swap_list</code>: This function gives the list of swaps performed at viviswap.</li> <li><code>get_swap_details</code>: This function gives details about a swap, like information on fees, exchange rate, the swap status, etc...</li> <li><code>get_exchange_rate</code>: This function provides the exchange rate for the involved currencies in the swap. Currently, the exchange rate is always provided with EURO as base currency, i.e. it is either SMR/EURO or IOTA/EUR or BTC/EURO and so on... An inversion of the exchange rate gives the reverse rate and should be calculated by simply inverting the value. As confirmed by viviswap, there are no vertical spreads to be considered here!</li> </ol> <pre><code>                              Deposit Flow                        \n\n\n            +------------+            |          +------------+   \n            |            |            |          |            |   \n            | User       |            |          | Viviswap   |   \n            | Wallet     &lt;------------+----------+ Wallet     |   \n            | Address    |            |          | Address    |   \n            |            |            |          |            |   \n            +------------+            |          +------^-----+   \n                                      |                 |         \n                                      |                 |         \n                                      |                 |         \n                                      |                 |Trigger  \n                                      |                 |         \n                                      |                 |         \n                                      |                 |         \n            +------------+            |            +----+-------+ \n            |            |            |            |            | \nUser        | User       |     Bank   |            |  Viviswap  | \n------------&gt; IBAN       +------------+------------&gt;  IBAN      | \nAction      |            |     Ref.   |            |            | \n            |            |     Nr.    |            |            | \n            +------^-----+            |            +------------+ \n                   |                  |                           \n                   |                  |                           \n                   |                  |                           \n                   |                  |                           \n                   |                  |                           \n                   |                  |             +------------+\n                   +------------------+-------------+            |\n                                      |             |  Create    |\n           Update  -------------------+-------------&gt;  Deposit   |\n           User           Payment     |             |  Detail    |\n           IBAN           Detail      |             |            |\n                                      |             +------------+\n                                      |                           \n                                      |                           \n                              User    |    Viviswap               \n</code></pre> <pre><code>                 Withdraw Flow                       \n\n                                   +------------+    \n                                   |            |    \n  User                    |        |  Create    |    \n  ------------------------+--------&gt;  Withdraw  |    \n  Action                  |        |  Detail    |    \n              Viviswap    |        |            |    \n      +-------------------+--------+------------+    \n      |       Address     |                          \n      |                   |                          \n+-----v------+            |          +------------+  \n|            |            |          |            |  \n| User       |            |          | Viviswap   |  \n| Wallet     +------------+----------&gt; Wallet     |  \n| Address    |            |          | Address    |  \n|            |            |          |            |  \n+------------+            |          +------+-----+  \n                          |                 |        \n                          |                 |        \n                          |                 |        \n                          |                 |Trigger \n                          |                 |        \n                          |                 |        \n                          |                 |        \n+------------+            |            +----v-------+\n|            |            |            |            |\n| User       |            |            |  Viviswap  |\n| IBAN       &lt;------------+------------+  IBAN      |\n|            |            |            |            |\n|            |            |            |            |\n+------------+            |            +------------+\n                          |                          \n                          |                          \n                          |                          \n                  User    |    Viviswap              \n</code></pre>"},{"location":"SDK%20Modules/Transactions_Swaps_Purchases/#purchase-transactions-flow","title":"Purchase transactions flow","text":"<p>The purchase transaction is a process different than a swap or a wallet transaction. The purchase is a process of exchanging funds for an underlying artefact. An artefact can be something promised between two parties like a photo, video, or a compliment on a photo, sensor data, services, licenses, etc... The SDK is only interested in creation, querying and confirmation of these purchase requests. The rest of the business logic flow is handled by the corresponding service in Cawaena infrastructure. The transfer of artefact can happen only after a successful execution of the purchase request. This information can be verified at all times by querying the status of the purchase request and the details of the purchase request.</p> <p>A purchase request can be created at any time and is unique per purchase. A purchase id is returned by the infrastructure to track this particular request. Currently, polling is used to wait for the purchase request to be valid. It can be invalid for multiple reasons, as defined in the infrastructure. In case the request turns out to be valid, then the details (supplemented by the infrastructure) are fetched and a confirmation is done through the sdk.</p> <p>The confirmation of a purchase request means that funds are required to be released from the wallet and this operation needs the pin from the user, to avoid creation and confirmation of purchase request which might not have been authorized by the user. The confirmation triggers a wallet transaction to the recipient's wallet address as well as to the system's wallet address. The purchase details deliver this information for each individual purchase request. The result of the wallet transaction is then added to the purchase request and sent to the infrastructure as part of the confirmation body, so that the infrastructure can search for the transaction on the DLT network.</p> <pre><code>                                        |                      \n                                        |                      \n                                        |                      \n                 +-------------+        |                      \n                 |             |        |                      \n       User      | Create      |        |                      \n     +-----------&gt; Purchase    +--------+-+     +-------------+\n     | Request   | Request     |        | |     |             |\n     |           |             |        | |     |  (Polling)  |\n     |           +-------------+        | +-----&gt;  Get        |\n     |                                  |       |  Purchase   |\n     |                                  |       |  Status     |\n     |                                  |       +------+------+\n     |      Pin                         |              |       \n     +-------------------+              |              |Valid  \n                         |              |              |       \n                         |              |       +------v------+\n                  +------v------+       |       |             |\n                  |             |       |       |  Get        |\n    Wallet        | Confirm     &lt;-------+-------+  Purchase   |\n&lt;-----------------+ Purchase    |       |       |  Details    |\n    Transaction   | Request     |       |       |             |\n                  |             |       |       +-------------+\n                  +-------------+       |                      \n                                        |                      \n                                        |                      \n                                        |                      \n                                        |                      \n                               Once     |   Multiple times     \n                                        |                      \n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/","title":"API Reference","text":""},{"location":"SDK%20Reference/SDK%20API%20Reference/#levels-and-repeats","title":"Levels and Repeats","text":"Category Description Levels Basic The functions at these levels are absolutely necessary to use the SDK. Without calling these functions, the SDK is never in a correct state. Optional functions can be skipped, since they will take default values, if that is the requirement. Usage The functions at these levels can only be called once all basic level functions have successfully executed. Repeats Handle The functions need to be called every time a new SDK Handle (object) needs to be created via a constructor or after garbage collection of any existing old handles. User The functions need to be called every time a new SDK user needs to be created. Application The functions can be called any time while using the SDK, however they may fail, if the certain dependencies are not fulfilled."},{"location":"SDK%20Reference/SDK%20API%20Reference/#usage-infos-and-warnings","title":"Usage infos and warnings","text":"<p>Warning</p> <ul> <li>Viviswap and Postident KYC onboarding will not work if the user is already kyc verified.</li> <li>KYC onboarding with another provider will not work if the user is already started kyc onboarding with one of the other providers.</li> <li>Restoring a wallet backup may fail, if the wallet is already existing.</li> <li>Initializing User and initializing wallet may fail, if the user and wallet are already initialized. Since, there is no de-init function, the  SDK handle needs to be closed, or a new handle needs to be created to re init. </li> <li>Multiple handles to the wallet may also fail, since only atomic access are allowed.</li> <li>Deleting a user may fail if the backend cannot be reached.</li> </ul>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#javascript-typescript","title":"JavaScript / TypeScript","text":"<p>The API reference for the JS/TS bindings are available here. Please consult the tables below for the dependencies between each function.</p>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#sdk-initialization-and-configuration","title":"SDK Initialization and Configuration","text":""},{"location":"SDK%20Reference/SDK%20API%20Reference/#instantiating-the-sdk","title":"Instantiating the SDK","text":"Method Arguments Returns Errors Dependencies Level Repeat Constructor Returns an <code>Error</code> if an error occurs, otherwise the handle to the SDK Returns an <code>Error</code> if there is an issue in loading the dynamically or statically linked binary shared library Basic Handle RustJavaSwift <pre><code>use sdk::Sdk;\nlet mut sdk = Sdk::default();\n</code></pre> <pre><code>import com.etogruppe.CryptpaySdk;\nsdk = new CryptpaySdk();\n</code></pre> <pre><code>import cryptpaysdk\nlet sdk = Sdk()\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#set-path-prefix","title":"Set path prefix","text":"Method Arguments Returns Errors Dependencies Level Repeat Sets the path prefix <code>path_prefix</code> - The path to the storage where SDK has read/write file I/O access Constructor Basic Handle RustJavaSwift <pre><code>fn set_path_prefix(&amp;mut self, path_prefix: &amp;str)\n</code></pre> <pre><code>public void setStoragePath(String path_prefix) throws Exception\n</code></pre> <pre><code>public func setPathPrefix(path_prefix: String)\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#set-authentication-provider","title":"Set authentication provider","text":"Method Arguments Returns Errors Dependencies Level Repeat Sets the auth provider <code>auth_provider</code> - The string identifying the auth provider Constructor Basic Handle RustJavaSwift <pre><code>fn set_auth_provider(&amp;mut self, auth_provider: &amp;str)\n</code></pre> <pre><code>public void authProvider(String authProvider) throws Exception\n</code></pre> <pre><code>public func setAuthProvider(auth_provider: String)\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#set-backend-url","title":"Set backend URL","text":"Method Arguments Returns Errors Dependencies Level Repeat Sets the backend URL <code>backend_url</code> - The string containing the backend URL Constructor Basic Handle RustJavaSwift <pre><code>fn set_backend_url(&amp;mut self, backend_url: &amp;str)\n</code></pre> <pre><code>public void backendUrl(String backendUrl) throws Exception \n</code></pre> <pre><code>public func setBackendUrl(backend_url: String)\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#set-log-level","title":"Set log level","text":"Method Arguments Returns Errors Dependencies Level Repeat Sets the log level <code>log_level</code> - The log level as string. Allowed values are <code>info</code>, <code>error</code>, <code>warn</code> and <code>debug</code> Error, if the matching log level string cannot be parsed Constructor Basic Handle RustJavaSwift <pre><code>fn set_log_level(&amp;mut self, log_level: &amp;str)\n</code></pre> <pre><code>public void logLevel(String logLevel) throws Exception \n</code></pre> <pre><code>public func setLogLevel(log_level: String)\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#set-environment","title":"Set environment","text":"Method Arguments Returns Errors Dependencies Level Repeat Sets the environment <code>env</code> - The environment as string. Allowed values are <code>qa</code>, <code>development</code>, <code>staging</code> and <code>production</code> Error, if the matching environment string cannot be parsed Constructor Basic Handle RustJavaSwift <pre><code>fn set_env(&amp;mut self, env: Environment)\n</code></pre> <pre><code>public void logLevel(String logLevel) throws Exception \n</code></pre> <pre><code>public func setSdkEnv(sdk_env: String) throws\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#set-currency","title":"Set currency","text":"Method Arguments Returns Errors Dependencies Level Repeat Sets the currency <code>currency</code> - The currency as string. Allowed values are <code>smr</code>and <code>iota</code> Error, if the matching currency string cannot be parsed Constructor Basic Handle RustJavaSwift <pre><code>fn set_currency(&amp;mut self, currency: Currency)\n</code></pre> <pre><code>public void setCurrency(String currency) throws Exception \n</code></pre> <pre><code>public func setCurrency(currency: String) throws \n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#validate-config","title":"Validate config","text":"Method Arguments Returns Errors Dependencies Level Repeat Validates the SDK configuration Error, if the configuration is invalid Constructor Basic (optional) Handle RustJavaSwift <pre><code>fn validate_config(&amp;self) -&gt; Result&lt;(), crate::error::Error&gt;\n</code></pre> <pre><code>public void checkConfig() throws Exception\n</code></pre> <pre><code>public func validateConfig() throws\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#initialize-logger","title":"Initialize logger","text":"Method Arguments Returns Errors Dependencies Level Repeat Initializes the logger Error, if the logger cannot be initialized Constructor, Path Prefix, Log Level Basic Handle RustJavaSwift <pre><code>fn init_logger(&amp;self) -&gt; Result&lt;(), crate::error::Error&gt; \n</code></pre> <pre><code>public void initLogger() throws Exception\n</code></pre> <pre><code>public func initLogger() throws\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#user-functions","title":"User functions","text":""},{"location":"SDK%20Reference/SDK%20API%20Reference/#creating-a-new-user","title":"Creating a new user","text":"Method Arguments Returns Errors Dependencies Level Repeat Create a new user <code>username</code> - The username of the new user. Returns an <code>Error</code> if an error occurs, otherwise void Returns an <code>Error</code> if there is an issue validating the configuration, initializing the repository, or creating the user. Constructor, Path Prefix Basic User RustJavaSwift <pre><code>async fn create_new_user(&amp;mut self, username: &amp;str) -&gt; Result&lt;(), crate::error::Error&gt;;\n</code></pre> <pre><code>public void createNewUser(String username) throws Exception\n</code></pre> <pre><code>public func createNewUser(username: String) throws\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#initializing-a-user","title":"Initializing a user","text":"Method Arguments Returns Errors Dependencies Level Repeat Initialize a user <code>username</code> - The username of the user to initialize. Returns, if the user is initialized successfully, or an <code>Error</code> if an error occurs. Returns an <code>Error</code> if there is an issue validating the configuration, initializing the repository, or checking the KYC status. Constructor, Path Prefix, Refresh access token, Create new user Usage Application RustJavaSwift <pre><code>async fn init_user(&amp;mut self, username: &amp;str) -&gt; Result&lt;(), crate::error::Error&gt;;\n</code></pre> <pre><code>public void initializeUser(String username) throws Exception\n</code></pre> <pre><code>public func initUser(username: String) throws \n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#refreshing-access-token","title":"Refreshing access token","text":"Method Arguments Returns Errors Dependencies Level Repeat Refresh access token <code>access_token</code> - The new access token to be set. Returns, if the access token is refreshed successfully, or an <code>Error</code> if an error occurs. Returns an <code>Error</code> if there is an issue validating the configuration. Constructor, Path Prefix Basic Application RustJavaSwift <pre><code>async fn refresh_access_token(&amp;mut self, access_token: &amp;str) -&gt; Result&lt;(), crate::error::Error&gt;\n</code></pre> <pre><code>public void refreshAccessToken(String access_token) throws Exception\n</code></pre> <pre><code>public func refreshAccessToken(access_token: String) throws \n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#checking-kyc-status","title":"Checking KYC status","text":"Method Arguments Returns Errors Dependencies Level Repeat Check if KYC status is verified <code>username</code> - The username of the user to check KYC status for. Returns <code>true</code> if the KYC status is verified, or <code>false</code> if it is not verified. Returns an <code>Error</code> if there is an issue validating the configuration, initializing the repository, or checking the KYC status. User initialization Usage Application RustJavaSwift <pre><code>async fn is_kyc_status_verified(&amp;mut self, username: &amp;str) -&gt; Result&lt;bool, crate::error::Error&gt;\n</code></pre> <pre><code>public boolean isKycVerified(String username) throws Exception\n</code></pre> <pre><code>public func isKycVerified(username: String) throws\n-&gt; Bool\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#delete-user","title":"Delete user","text":"Method Arguments Returns Errors Dependencies Level Repeat Delete the currently active user and their wallet <code>pin</code> - The PIN of the user to be deleted Returns, if the user is deleted successfully, or an <code>Error</code> if an error occurs. Returns an <code>Error</code> if there is an issue verifying the PIN, initializing the repository, deleting the user, or deleting the wallet. User initialization Usage Application RustJavaSwift <pre><code>async fn delete_user(&amp;mut self, pin: &amp;str) -&gt; Result&lt;(), crate::error::Error&gt;\n</code></pre> <pre><code>public void deleteUser(String pin) throws Exception\n</code></pre> <pre><code>public func deleteUser(pin: String) throws\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#wallet-functions","title":"Wallet functions","text":""},{"location":"SDK%20Reference/SDK%20API%20Reference/#create-new-wallet","title":"Create new wallet","text":"Method Arguments Returns Errors Dependencies Level Repeat Creates a new wallet for the user with the specified PIN and password <code>pin</code> - The PIN for the wallet, <code>password</code> - The password for the wallet Returns the mnemonic phrase of the newly created wallet if successful, otherwise returns an <code>Error</code>. <code>RepositoryInitError</code> - If there is an error initializing the repository, <code>UserInitError</code> - If there is an error initializing the user, <code>WalletInitError</code> - If there is an error initializing the wallet User initialization Usage User RustJavaSwift <pre><code>async fn create_new_wallet(&amp;mut self, pin: &amp;str, password: &amp;str) -&gt; Result&lt;String, crate::error::Error&gt;\n</code></pre> <pre><code>public String createNewWallet(String pin, String password) throws Exception\n</code></pre> <pre><code>public func createNewWallet(pin: String, password: String) throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#create-new-wallet-from-mnemonic","title":"Create new wallet from mnemonic","text":"Method Arguments Returns Errors Dependencies Level Repeat Migrate a wallet from existing mnemonic <code>pin</code> - The PIN for the wallet, <code>password</code> - The password for the wallet, <code>mnemonic</code> - The mnemonic to migrate from Returns, if the wallet is successfully created, otherwise returns an <code>Error</code>. <code>RepositoryInitError</code> - If there is an error initializing the repository, <code>UserInitError</code> - If there is an error initializing the user, <code>WalletInitError</code> - If there is an error initializing the wallet User initialization Usage User RustJavaSwift <pre><code>async fn create_wallet_from_mnemonic(\n    &amp;mut self,\n    pin: &amp;str,\n    password: &amp;str,\n    mnemonic: &amp;str,\n) -&gt; Result&lt;(), crate::error::Error&gt;\n</code></pre> <pre><code>public void createWalletFromMnemonic(String pin, String password, String mnemonic) throws Exception \n</code></pre> <pre><code>public func createWalletFromMnemonic(pin: String, password: String, mnemonic: String) throws\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#create-new-wallet-from-backup","title":"Create new wallet from backup","text":"Method Arguments Returns Errors Dependencies Level Repeat Migrate a wallet from existing backup <code>pin</code> - The PIN for the wallet, <code>password</code> - The password for the backup, <code>backup_path</code> - The path to the backup file Returns, if the wallet is successfully created, otherwise returns an <code>Error</code>. <code>RepositoryInitError</code> - If there is an error initializing the repository, <code>UserInitError</code> - If there is an error initializing the user, <code>WalletInitError</code> - If there is an error initializing the wallet User initialization Usage Application RustJavaSwift <pre><code>async fn create_wallet_from_backup(\n    &amp;mut self,\n    pin: &amp;str,\n    password: &amp;str,\n    backup_path: &amp;str,\n) -&gt; Result&lt;(), crate::error::Error&gt;\n</code></pre> <pre><code>public void createWalletFromBackup(String pin, String password, String backup_path) throws Exception \n</code></pre> <pre><code>public func createWalletFromBackup(pin: String, password: String, backup_path: String) throws\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#create-a-wallet-backup","title":"Create a wallet backup","text":"Method Arguments Returns Errors Dependencies Level Repeat Create a wallet backup <code>password</code> - The password for the backup Returns the path to the created backup file as a <code>String</code> if successful, otherwise returns an <code>Error</code>. <code>WalletInitError</code> - If there is an error initializing the wallet User initialization Usage Application RustJavaSwift <pre><code>async fn create_wallet_backup(\n    &amp;mut self,\n    password: &amp;str,\n) -&gt; Result&lt;(), crate::error::Error&gt;\n</code></pre> <pre><code>public String createWalletBackup(String backup_password) throws Exception\n</code></pre> <pre><code>public func createWalletBackup(password: String) throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#initialize-a-wallet","title":"Initialize a wallet","text":"Method Arguments Returns Errors Dependencies Level Repeat Initialize an existing wallet <code>pin</code> - The PIN for the wallet. Returns, if the wallet is successfully initialized, otherwise returns an <code>Error</code>. <code>RepositoryInitError</code> - If there is an error initializing the repository, <code>UserInitError</code> - If there is an error initializing the user, <code>MissingPassword</code> - If the encrypted password is missing, <code>WrongPinOrPassword</code> - If the PIN or password is incorrect User initialization Usage Application RustJavaSwift <pre><code>async fn init_wallet(&amp;mut self, pin: &amp;str) -&gt; Result&lt;(), crate::error::Error&gt;\n</code></pre> <pre><code>public void initializeWallet(String pin) throws Exception\n</code></pre> <pre><code>public func initWallet(pin: String) throws\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#verify-mnemonic","title":"Verify mnemonic","text":"Method Arguments Returns Errors Dependencies Level Repeat Verifies the mnemonic by deleting the current wallet and creating a new wallet from the provided mnemonic <code>pin</code> - The PIN for the wallet, <code>password</code> - The password for the wallet, <code>mnemonic</code> - The mnemonic to verify Returns, if the mnemonic is successfully verified, otherwise returns an <code>Error</code> <code>WalletInitError</code> - If there is an error initializing the wallet, <code>RepositoryInitError</code> - If there is an error initializing the repository, <code>UserInitError</code> - If there is an error initializing the user,  <code>Error</code> - If there is an error deleting the wallet or creating a new wallet from the mnemonic. User initialization Usage User RustJavaSwift <pre><code>async fn verify_mnemonic(&amp;mut self, pin: &amp;str, password: &amp;str, mnemonic: &amp;str) -&gt; Result&lt;(), crate::error::Error&gt;\n</code></pre> <pre><code>public void verifyMnemonic(String pin, String password, String mnemonic) throws Exception\n</code></pre> <pre><code>public func verifyMnemonic(pin: String, password: String, mnemonic: String) throws\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#delete-wallet","title":"Delete wallet","text":"<p>Warning</p> <p>Deletes the currently active wallet, potentially resulting in loss of funds if the mnemonic or wallet is not backed up.</p> Method Arguments Returns Errors Dependencies Level Repeat Delete the currently active wallet Returns, if the wallet is successfully deleted, otherwise returns an <code>Error</code>. <code>WalletInitError</code> - If there is an error initializing the wallet,  <code>Error</code> - If there is an error closing or deleting the wallet Wallet initialization Usage Application RustJavaSwift <pre><code>async fn delete_wallet(&amp;mut self) -&gt; Result&lt;(), crate::error::Error&gt; \n</code></pre> <pre><code>public void deleteWallet() throws Exception\n</code></pre> <pre><code>public func deleteWallet() throws\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#verify-pin","title":"Verify pin","text":"Method Arguments Returns Errors Dependencies Level Repeat Verifies the pin for the wallet <code>pin</code> - The pin to verify Returns, if the pin is verified successfully, otherwise returns an <code>Error</code>. <code>RepositoryInitError</code> - If there is an error initializing the repository, <code>UserInitError</code> - If there is an error initializing the user, <code>WalletInitError</code> - If there is an error initializing the wallet, <code>MissingPassword</code> - If the password is missing, <code>WrongPinOrPassword</code> - If the pin or password is incorrect Wallet initialization Usage Application RustJavaSwift <pre><code>async fn verify_pin(&amp;self, pin: &amp;str) -&gt; Result&lt;(), crate::error::Error&gt;\n</code></pre> <pre><code>public void pinVerify(String pin) throws Exception\n</code></pre> <pre><code>public func verifyPin(pin: String) throws\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#reset-pin","title":"Reset pin","text":"Method Arguments Returns Errors Dependencies Level Repeat Resets the pin for the wallet using the provided password and new pin <code>password</code> - The current password for the wallet, <code>new_pin</code> - The new pin to set for the wallet Returns, if the pin is reset successfully, otherwise returns an <code>Error</code> <code>RepositoryInitError</code> - If there is an error initializing the repository, <code>UserInitError</code> - If there is an error initializing the user, <code>MissingPassword</code> - If the password is missing, <code>WrongPinOrPassword</code> - If the pin or password is incorrect Wallet initialization Usage Application RustJavaSwift <pre><code>async fn reset_pin(&amp;mut self, password: &amp;str, new_pin: &amp;str) -&gt; Result&lt;(), crate::error::Error&gt;\n</code></pre> <pre><code>public void pinReset(String password, String pin) throws Exception \n</code></pre> <pre><code>public func resetPin(password: String, new_pin: String) throws \n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#change-password","title":"Change password","text":"Method Arguments Returns Errors Dependencies Level Repeat Changes the password for the wallet using the provided pin, current password, and new password <code>pin</code> - The pin to verify, <code>current_password</code> - The current password for the wallet, <code>new_password</code> - The new password to set for the wallet Returns, if the password is changed successfully, otherwise returns an <code>Error</code> <code>RepositoryInitError</code> - If there is an error initializing the repository, <code>UserInitError</code> - If there is an error initializing the user, <code>WalletInitError</code> - If there is an error initializing the wallet Wallet initialization Usage Application RustJavaSwift <pre><code>async fn change_password(\n    &amp;mut self,\n    pin: &amp;str,\n    current_password: &amp;str,\n    new_password: &amp;str,\n) -&gt; Result&lt;(), crate::error::Error&gt; \n</code></pre> <pre><code>public void passwordChange(String pin, String current_password, String new_password) throws Exception\n</code></pre> <pre><code>public func changePassword(pin: String, current_password: String, new_password: String) throws \n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#generate-a-new-address","title":"Generate a new address","text":"Method Arguments Returns Errors Dependencies Level Repeat Generates a new receiver address for the wallet Returns the generated address as a <code>String</code> if successful, otherwise returns an <code>Error</code> <code>UserInitError</code> - If there is an error initializing the user, <code>WalletInitError</code> - If there is an error initializing the wallet Wallet initialization Usage Application RustJavaSwift <pre><code>async fn generate_new_iota_receiver_address(&amp;self) -&gt; Result&lt;String, crate::error::Error&gt;\n</code></pre> <pre><code>public String generateNewIotaReceiverAddress() throws Exception\n</code></pre> <pre><code>public func generateNewIotaReceiverAddress() throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#get-balance","title":"Get balance","text":"Method Arguments Returns Errors Dependencies Level Repeat Fetches the balance of the user from the wallet Returns the balance as a <code>f64</code> if successful, otherwise returns an <code>Error</code> <code>WalletInitError</code> - If there is an error initializing the wallet Wallet initialization Usage Application RustJavaSwift <pre><code>async fn get_balance(&amp;self) -&gt; Result&lt;f64, crate::error::Error&gt;\n</code></pre> <pre><code>public double getBalance() throws Exception\n</code></pre> <pre><code>public func getBalance() throws -&gt; Double\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#get-wallet-transactions","title":"Get wallet transactions","text":"Method Arguments Returns Errors Dependencies Level Repeat Wallet transaction list <code>page</code> - The page number for paginatation, <code>page_size</code> - The page size for each page Returns the list of transactions made on the wallet as an array of <code>WalletTxInfo</code> object or a serialized JSON of the same, if successful, otherwise returns an <code>Error</code> <code>WalletInitError</code> - If there is an error initializing the wallet Wallet initialization Usage Application RustJavaSwift <pre><code>async fn get_wallet_tx_list(&amp;self, page: usize, page_size: usize) -&gt; Result&lt;WalletTxInfoList, crate::error::Error&gt;\n</code></pre> <pre><code>public String getWalletTransactionList(long page, long pageSize) throws Exception\n</code></pre> <pre><code>public func getWalletTransactionList(page: UInt64, pageSize: UInt64) throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#wallettxinfo","title":"WalletTxInfo","text":"RustJSON <pre><code>pub struct WalletTxInfo {\n/// Tx creation date, if available\npub date: String,\n/// Contains block id\npub block_id: Option&lt;String&gt;,\n/// transaction id for particular transaction\npub transaction_id: String,\n/// Describes type of transaction\npub incoming: bool,\n/// Amount of transfer\npub amount: f64,\n/// either SMR or IOTA [convert network_id to string based on the value]\npub network: String,\n/// Status of the transfer\npub status: String,\n/// Url of network SMR/IOTA\npub explorer_url: Option&lt;String&gt;,\n// change based on the network either shimmer or iota\n// base explorer url for SMR = https://explorer.shimmer.network/shimmer/block/[block_id]\n// base explorer url for IOTA = https://explorer.iota.org/mainnet/block/[block_id]\n}\n</code></pre> <pre><code>{\n    \"$schema\": \"&lt;http://json-schema.org/draft-07/schema#&gt;\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"date\": {\n            \"type\": \"string\",\n            \"description\": \"Tx creation date, if available\"\n        },\n        \"block_id\": {\n            \"type\": [\"string\", \"null\"],\n            \"description\": \"Contains block id\"\n        },\n        \"transaction_id\": {\n            \"type\": \"string\",\n            \"description\": \"transaction id for particular transaction\"\n        },\n        \"incoming\": {\n            \"type\": \"boolean\",\n            \"description\": \"Describes type of transaction\"\n        },\n        \"amount\": {\n            \"type\": \"number\",\n            \"description\": \"Amount of transfer\"\n        },\n        \"network\": {\n            \"type\": \"string\",\n            \"description\": \"either SMR or IOTA [convert network_id to string based on the value]\"\n        },\n        \"status\": {\n            \"type\": \"string\",\n            \"description\": \"Status of the transfer\"\n        },\n        \"explorer_url\": {\n            \"type\": [\"string\", \"null\"],\n            \"description\": \"Url of network SMR/IOTA explorer\"\n        }\n    },\n    \"required\": [\"date\", \"transaction_id\", \"incoming\", \"amount\", \"network\", \"status\"]\n}\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#get-wallet-transaction","title":"Get wallet transaction","text":"Method Arguments Returns Errors Dependencies Level Repeat Single wallet transaction <code>tx_id</code> - The transaction id on the network Returns the transactions made on the wallet with the given id as <code>WalletTxInfo</code> object or a serialized JSON of the same, if successful, otherwise returns an <code>Error</code> <code>WalletInitError</code> - If there is an error initializing the wallet Wallet initialization Usage Application RustJavaSwift <pre><code>async fn get_wallet_tx(&amp;self, tx_id: &amp;str) -&gt; Result&lt;WalletTxInfo, crate::error::Error&gt;\n</code></pre> <pre><code>public String getWalletTransaction(String transactionId) throws Exception\n</code></pre> <pre><code>public func getWalletTransaction(transactionId: String) throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#viviswap-functions","title":"Viviswap functions","text":""},{"location":"SDK%20Reference/SDK%20API%20Reference/#start-kyc-verification-for-viviswap","title":"Start KYC Verification for viviswap","text":"Method Arguments Returns Errors Dependencies Level Repeat Create new viviswap user and initialize kyc verification <code>mail</code> - The email address of the user, <code>terms_accepted</code> - A boolean indicating whether the terms have been accepted Returns<code>NewViviswapUser</code> if successful, or an <code>Error</code>, if an error occurs Repository initialization error, User already exists, Viviswap API error, User status update error User initialization Usage Application RustJavaSwift <pre><code>async fn start_kyc_verification_for_viviswap(\n    &amp;self,\n    mail: &amp;str,\n    terms_accepted: bool,\n) -&gt; Result&lt;NewViviswapUser, crate::error::Error&gt;\n</code></pre> <pre><code>public String startViviswapKyc(String mail, boolean terms_accepted) throws Exception\n</code></pre> <pre><code>public func startKycVerificationForViviswap(mail: String, termsAccepted: Bool) throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#newviviswapuser","title":"NewViviswapUser","text":"RustJSON <pre><code>pub struct NewViviswapUser {\n/// Username of new viviswap user\npub username: String,\n}\n</code></pre> <pre><code>{\n    \"$schema\": \"&lt;http://json-schema.org/draft-07/schema#&gt;\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"username\": {\n            \"type\": \"string\",\n            \"description\": \"Username of new viviswap user\"\n        }\n    },\n    \"required\": [\"username\"]\n}\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#get-kyc-details-for-viviswap","title":"Get KYC details for viviswap","text":"Method Arguments Returns Errors Dependencies Level Repeat Get current kyc status of viviswap Returns <code>ViviswapKycStatus</code> if successful, or an <code>Error</code> if an error occurs Repository initialization error, Viviswap API error User initialization Usage Application RustJavaSwift <pre><code>async fn get_kyc_details_for_viviswap(&amp;self) -&gt; Result&lt;ViviswapKycStatus, crate::error::Error&gt;\n</code></pre> <pre><code>public String getViviswapKyc() throws Exception\n</code></pre> <pre><code>public func getKycDetailsForViviswap() throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#viviswapkycstatus","title":"ViviswapKycStatus","text":"RustJSON <pre><code>pub struct ViviswapKycStatus {\n    /// full name of the user\n    pub full_name: String,\n    /// the current submission step in the KYC onboarding process for the user\n    pub submission_step: ViviswapVerificationStep,\n    /// the current verified step in the KYC onboarding process for the user\n    pub verified_step: ViviswapVerificationStep,\n    /// the user verification status\n    pub verification_status: ViviswapVerificationStatus,\n    /// The monthly swap limit in euros\n    pub monthly_limit_eur: f32,\n}\npub enum ViviswapVerificationStep {\n    /// no verification step (no next verification step available)\n    Undefined,\n    /// general verification step\n    General,\n    /// personal verification step\n    Personal,\n    /// residence verification step\n    Residence,\n    /// identity verification step\n    Identity,\n    /// amla general verification step\n    Amla,\n    /// document verification step\n    Documents,\n}\npub enum ViviswapVerificationStatus {\n    /// The user is fully verified\n    Verified,\n    /// The user is not verified\n    Unverified,\n    /// The user is partially verified\n    PartiallyVerified,\n}\n</code></pre> <pre><code>{\n    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"full_name\": {\n            \"type\": \"string\",\n            \"description\": \"Full name of the user\"\n        },\n        \"submission_step\": {\n            \"type\": \"string\",\n            \"enum\": [\"Undefined\", \"General\", \"Personal\", \"Residence\", \"Identity\", \"Amla\", \"Documents\"],\n            \"description\": \"The current submission step in the KYC onboarding process for the user\"\n        },\n        \"verified_step\": {\n            \"type\": \"string\",\n            \"enum\": [\"Undefined\", \"General\", \"Personal\", \"Residence\", \"Identity\", \"Amla\", \"Documents\"],\n            \"description\": \"The current verified step in the KYC onboarding process for the user\"\n        },\n        \"verification_status\": {\n            \"type\": \"string\",\n            \"enum\": [\"Verified\", \"Unverified\", \"PartiallyVerified\"],\n            \"description\": \"The user verification status\"\n        },\n        \"monthly_limit_eur\": {\n            \"type\": \"number\",\n            \"description\": \"The monthly swap limit in euros\"\n        }\n    },\n    \"required\": [\"full_name\", \"submission_step\", \"verified_step\", \"verification_status\", \"monthly_limit_eur\"]\n}\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#update-partial-kyc-for-viviswap","title":"Update partial KYC for viviswap","text":"Method Arguments Returns Errors Dependencies Level Repeat Update the kyc details for viviswap to be submitted <code>is_individual</code> - Whether the user is an individual, <code>is_pep</code> - Whether the user is a politically exposed person, <code>is_us_citizen</code> - Whether the user is a US citizen, <code>is_regulatory_disclosure</code> - Whether the user has accepted the regulatory disclosure, <code>country_of_residence</code> - The country of residence of the user, <code>nationality</code> - The nationality of the user, <code>full_name</code> - The full name of the user, <code>date_of_birth</code> - The date of birth of the user Returns <code>ViviswapPartiallyKycDetails</code> containing the partially updated KYC details or a vector of errors for each input field A vector of errors if any validation errors occur during the update process User initialization Usage Application RustJavaSwift <pre><code>async fn update_kyc_partially_status_for_viviswap(\n    &amp;self,\n    is_individual: Option&lt;bool&gt;,\n    is_pep: Option&lt;bool&gt;,\n    is_us_citizen: Option&lt;bool&gt;,\n    is_regulatory_disclosure: Option&lt;bool&gt;,\n    country_of_residence: Option&lt;String&gt;,\n    nationality: Option&lt;String&gt;,\n    full_name: Option&lt;String&gt;,\n    date_of_birth: Option&lt;String&gt;,\n) -&gt; Result&lt;ViviswapPartiallyKycDetails, Vec&lt;crate::error::Error&gt;&gt;\n</code></pre> <pre><code>public String updateViviswapKycPartial(boolean is_individual, boolean is_pep, boolean is_us_citizen,\n        boolean is_regulatory_disclosure, String country_of_residence, String nationality, String full_name,\n        String date_of_birth) throws Exception\n</code></pre> <pre><code>public func updateKycPartiallyStatusForViviswap(\n    isIndividual: Bool,\n    isPep: Bool,\n    isUsCitizen: Bool,\n    isRegulatoryDisclosure: Bool,\n    countryOfResidence: String,\n    nationality: String,\n    fullName: String,\n    dateOfBirth: String\n) throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#viviswappartiallykycdetails","title":"ViviswapPartiallyKycDetails","text":"RustJSON <pre><code>pub struct ViviswapPartiallyKycDetails {\n    /// Is the user an individual\n    pub is_individual: Option&lt;bool&gt;,\n    /// Is the user a politically exposed person\n    pub is_pep: Option&lt;bool&gt;,\n    /// Is the user a US citizen\n    pub is_us_citizen: Option&lt;bool&gt;,\n    /// Is the regulatory disclosure confirmed by user\n    pub is_regulatory_disclosure: Option&lt;bool&gt;,\n    /// The country of tax residence of the user\n    pub country_of_residence: Option&lt;String&gt;,\n    /// The user's nationality\n    pub nationality: Option&lt;String&gt;,\n    /// The full name of the user as per his legal documents\n    pub full_name: Option&lt;String&gt;,\n    /// The date of birth of the user as per his legal documents\n    pub date_of_birth: Option&lt;String&gt;,\n}\n</code></pre> <pre><code>{\n    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"is_individual\": {\n            \"type\": [\"boolean\", \"null\"],\n            \"description\": \"Is the user an individual\"\n        },\n        \"is_pep\": {\n            \"type\": [\"boolean\", \"null\"],\n            \"description\": \"Is the user a politically exposed person\"\n        },\n        \"is_us_citizen\": {\n            \"type\": [\"boolean\", \"null\"],\n            \"description\": \"Is the user a US citizen\"\n        },\n        \"is_regulatory_disclosure\": {\n            \"type\": [\"boolean\", \"null\"],\n            \"description\": \"Is the regulatory disclosure confirmed by user\"\n        },\n        \"country_of_residence\": {\n            \"type\": [\"string\", \"null\"],\n            \"description\": \"The country of tax residence of the user\"\n        },\n        \"nationality\": {\n            \"type\": [\"string\", \"null\"],\n            \"description\": \"The user's nationality\"\n        },\n        \"full_name\": {\n            \"type\": [\"string\", \"null\"],\n            \"description\": \"The full name of the user as per his legal documents\"\n        },\n        \"date_of_birth\": {\n            \"type\": [\"string\", \"null\"],\n            \"description\": \"The date of birth of the user as per his legal documents\"\n        }\n    }\n}\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#submit-partial-kyc-for-viviswap","title":"Submit partial KYC for viviswap","text":"Method Arguments Returns Errors Dependencies Level Repeat Submit the kyc details for viviswap Returns,  if the submission is successful Returns a vector of <code>Error</code> if any or many of the following conditions occur: Repository initialization error, Viviswap missing user error, Viviswap invalid state error, Viviswap missing field error, Viviswap API error User initialization Usage Application RustJavaSwift <pre><code>async fn submit_kyc_partially_status_for_viviswap(&amp;self) -&gt; Result&lt;(), Vec&lt;crate::error::Error&gt;&gt;\n</code></pre> <pre><code>public void submitViviswapKycPartial() throws Exception\n</code></pre> <pre><code>public func submitKycPartiallyStatusForViviswap() throws\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#get-iban-for-viviswap","title":"Get IBAN for viviswap","text":"Method Arguments Returns Errors Dependencies Level Repeat Get current iban of viviswap user Returns <code>ViviswapAddressDetail</code>, if successful otherwise <code>Error</code> Returns <code>ViviswapInvalidStateError</code> - If the viviswap state is invalid, <code>RepositoryInitError</code> - If the repository initialization fails, <code>ViviswapApiError</code> - If there is an error in the viviswap API, <code>UserStatusUpdateError</code> - If there is an error updating the user status Wallet initialization, Get KYC Details for viviswap Usage Application RustJavaSwift <pre><code>async fn get_iban_for_viviswap(&amp;self) -&gt; Result&lt;ViviswapAddressDetail, crate::error::Error&gt;\n</code></pre> <pre><code>public String getIbanViviswap() throws Exception\n</code></pre> <pre><code>public func getIbanViviswap() throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#viviswapaddressdetail","title":"ViviswapAddressDetail","text":"RustJSON <pre><code>pub struct ViviswapAddressDetail {\n    /// the unique id of the address detail\n    pub id: String,\n    /// the address used in the detail\n    pub address: String,\n    /// the status from viviswap, whether the address is verified\n    pub is_verified: bool,\n}\n</code></pre> <pre><code>{\n    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"id\": {\n            \"type\": \"string\",\n            \"description\": \"The unique id of the address detail\"\n        },\n        \"address\": {\n            \"type\": \"string\",\n            \"description\": \"The address used in the detail\"\n        },\n        \"is_verified\": {\n            \"type\": \"boolean\",\n            \"description\": \"The status from viviswap, whether the address is verified\"\n        }\n    },\n    \"required\": [\"id\", \"address\", \"is_verified\"]\n}\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#update-iban-for-viviswap","title":"Update IBAN for viviswap","text":"Method Arguments Returns Errors Dependencies Level Repeat Update IBAN of viviswap user <code>pin</code> - The user's PIN, <code>address</code> - The new IBAN address Returns <code>ViviswapAddressDetail</code>, if successful otherwise <code>Error</code> Returns <code>RepositoryInitError</code> - If the repository initialization fails, <code>ViviswapMissingUserError</code> - If the viviswap user is missing, <code>UserStatusUpdateError</code> - If there is an error updating the user status Wallet initialization, Get KYC Details for viviswap Usage Application RustJavaSwift <pre><code>async fn update_iban_for_viviswap(\n    &amp;self,\n    pin: String,\n    address: String,\n) -&gt; Result&lt;ViviswapAddressDetail, crate::error::Error&gt;\n</code></pre> <pre><code>public String updateIbanViviswap(String pin, String address) throws Exception\n</code></pre> <pre><code>public func updateIbanViviswap(pin: String, address: String) throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#create-deposit-with-viviswap","title":"Create deposit with viviswap","text":"Method Arguments Returns Errors Dependencies Level Repeat Create deposit for viviswap user Returns <code>ViviswapDeposit</code>, if successful otherwise <code>Error</code> Returns <code>RepositoryInitError</code> - If the repository initialization fails, <code>ViviswapMissingUserError</code> - If the viviswap user is missing, <code>ViviswapInvalidStateError</code> - If the viviswap state is invalid, <code>ViviswapApiError</code> - If there is an error with the Viviswap API Wallet initialization, Get KYC Details for viviswap, Update IBAN Usage Application RustJavaSwift <pre><code>async fn create_deposit_with_viviswap(&amp;self) -&gt; Result&lt;ViviswapDeposit, crate::error::Error&gt;\n</code></pre> <pre><code>public String depositWithViviswap() throws Exception\n</code></pre> <pre><code>public func depositWithViviswap() throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#viviswapdeposit","title":"ViviswapDeposit","text":"RustJSON <pre><code>pub struct ViviswapDeposit {\n    /// The unique UUID of the contract\n    pub contract_id: String,\n    /// The deposit address (crypto) where the swap will put the funds from fiat\n    pub deposit_address: String,\n    /// The details of the deposit (for the user)\n    pub details: ViviswapDepositDetails,\n}\npub struct ViviswapDepositDetails {\n    /// The reference to be entered by the user in his SEPA bank transfer\n    pub reference: String,\n    /// The name of the beneficiary receiving the SEPA transfer\n    pub beneficiary: String,\n    /// The name of the bank of the beneficiary\n    pub name_of_bank: String,\n    /// The address of the bank of the beneficiary\n    pub address_of_bank: String,\n    /// The IBAN of the beneficiary\n    pub iban: String,\n    /// The BIC/SWIFT code for the SEPA transfer\n    pub bic: String,\n}\n</code></pre> <pre><code>{\n    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"contract_id\": {\n            \"type\": \"string\",\n            \"description\": \"The unique UUID of the contract\"\n        },\n        \"deposit_address\": {\n            \"type\": \"string\",\n            \"description\": \"The deposit address (crypto) where the swap will put the funds from fiat\"\n        },\n        \"details\": {\n            \"type\": \"object\",\n            \"description\": \"The details of the deposit (for the user)\",\n            \"properties\": {\n                \"reference\": {\n                    \"type\": \"string\",\n                    \"description\": \"The reference to be entered by the user in his SEPA bank transfer\"\n                },\n                \"beneficiary\": {\n                    \"type\": \"string\",\n                    \"description\": \"The name of the beneficiary receiving the SEPA transfer\"\n                },\n                \"name_of_bank\": {\n                    \"type\": \"string\",\n                    \"description\": \"The name of the bank of the beneficiary\"\n                },\n                \"address_of_bank\": {\n                    \"type\": \"string\",\n                    \"description\": \"The address of the bank of the beneficiary\"\n                },\n                \"iban\": {\n                    \"type\": \"string\",\n                    \"description\": \"The IBAN of the beneficiary\"\n                },\n                \"bic\": {\n                    \"type\": \"string\",\n                    \"description\": \"The BIC/SWIFT code for the SEPA transfer\"\n                }\n            },\n            \"required\": [\"reference\", \"beneficiary\", \"name_of_bank\", \"address_of_bank\", \"iban\", \"bic\"]\n        }\n    },\n    \"required\": [\"contract_id\", \"deposit_address\", \"details\"]\n}\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#create-viviswap-address-detail","title":"Create viviswap address detail","text":"Method Arguments Returns Errors Dependencies Level Repeat Create address detail for viviswap user Returns <code>ViviswapAddressDetail</code>, if successful otherwise <code>Error</code> Returns <code>RepositoryInitError</code> - If the repository initialization fails, <code>ViviswapMissingUserError</code> - If the viviswap user is missing, <code>ViviswapInvalidStateError</code> - If the viviswap state is invalid, <code>ViviswapApiError</code> - If there is an error with the Viviswap API Wallet initialization, Get KYC Details for viviswap Usage Application RustJavaSwift <pre><code>async fn create_detail_for_viviswap(&amp;self) -&gt; Result&lt;ViviswapAddressDetail, crate::error::Error&gt;\n</code></pre> <pre><code>public String createViviswapDetail() throws Exception\n</code></pre> <pre><code>public func createViviswapDetail() throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#create-withdrawal-with-viviswap","title":"Create withdrawal with viviswap","text":"Method Arguments Returns Errors Dependencies Level Repeat Create address detail for viviswap user <code>amount</code> - The amount of the withdrawal, <code>pin</code> - The optional PIN for verification Returns <code>ViviswapWithdrawal</code>, if successful otherwise <code>Error</code> Returns <code>RepositoryInitError</code> - If the repository initialization fails, <code>ViviswapMissingUserError</code> - If the viviswap user is missing, <code>ViviswapInvalidStateError</code> - If the viviswap state is invalid, <code>ViviswapApiError</code> - If there is an error with the Viviswap API Wallet initialization, Get KYC Details for viviswap, Update IBAN Usage Application RustJavaSwift <pre><code>async fn create_withdrawal_with_viviswap(\n    &amp;self,\n    amount: f32,\n    pin: Option&lt;String&gt;,\n) -&gt; Result&lt;ViviswapWithdrawal, crate::error::Error&gt;\n</code></pre> <pre><code>public String withdrawWithViviswap(float amount, String pin) throws Exception\n</code></pre> <pre><code>public func withdrawWithViviswap(amount: Float, pin: String) throws -&gt; String \n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#viviswapwithdrawal","title":"ViviswapWithdrawal","text":"RustJSON <pre><code>pub struct ViviswapWithdrawal {\n    /// The unique UUID to track the withdrawal contract\n    pub contract_id: String,\n    /// The deposit address, in this case the IBAN of the user, where fiat will be deposited.\n    pub deposit_address: String,\n    /// The details of the withdrawal\n    pub details: ViviswapWithdrawalDetails,\n}\npub struct ViviswapWithdrawalDetails {\n    /// The reference used by viviswap for the SEPA transfer\n    pub reference: String,\n    /// The id of the unique wallet internal to viviswap\n    pub wallet_id: String,\n    /// The crypto address of viviswap where the crypto swap is to be sent\n    pub crypto_address: String,\n}\n</code></pre> <pre><code>{\n    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"contract_id\": {\n            \"type\": \"string\",\n            \"description\": \"The unique UUID of the contract\"\n        },\n        \"withdrawal_address\": {\n            \"type\": \"string\",\n            \"description\": \"The withdrawal address (crypto) where the swap will put the funds from fiat\"\n        },\n        \"details\": {\n            \"type\": \"object\",\n            \"description\": \"The details of the withdrawal (for the user)\",\n            \"properties\": {\n                \"reference\": {\n                    \"type\": \"string\",\n                    \"description\": \"The reference used by viviswap for the SEPA transfer\"\n                },\n                \"wallet_id\": {\n                    \"type\": \"string\",\n                    \"description\": \"The id of the unique wallet internal to viviswap\"\n                },\n                \"crypto_address\": {\n                    \"type\": \"string\",\n                    \"description\": \"The crypto address of viviswap where the crypto swap is to be sent\"\n                }\n            },\n            \"required\": [\"reference\", \"wallet_id\", \"crypto_address\"]\n        }\n    },\n    \"required\": [\"contract_id\", \"withdrawal_address\", \"details\"]\n}\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#get-swap-details","title":"Get swap details","text":"Method Arguments Returns Errors Dependencies Level Repeat Get swap details <code>order_id</code> - The ID of the swap order. Returns <code>Order</code> containing the swap order details or an error. Returns <code>RepositoryInitError</code> - If the repository initialization fails, <code>ViviswapMissingUserError</code> - If the viviswap user is missing, <code>ViviswapApiError</code> - If there is an error with the Viviswap API Wallet initialization, Get KYC Details for viviswap Usage Application RustJavaSwift <pre><code>async fn get_swap_details(&amp;self, order_id: String) -&gt; Result&lt;Order, crate::error::Error&gt;\n</code></pre> <pre><code>public String getSwapDetails(String order_id) throws Exception\n</code></pre> <pre><code>public func getSwapDetails(order_id: String) throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#order","title":"Order","text":"RustJSON <pre><code>pub struct Order {\n    pub id: String,\n    pub is_payed_out: bool,\n    pub is_approved: bool,\n    pub is_canceled: bool,\n    pub fees_amount_eur: f32,\n    pub crypto_fees: f32,\n    pub contract_id: String,\n    pub incoming_payment_method_id: String,\n    pub incoming_payment_method_currency: String,\n    pub incoming_amount: f32,\n    pub incoming_course: f32,\n    pub outgoing_payment_method_id: String,\n    pub outgoing_payment_method_currency: String,\n    pub outgoing_amount: f32,\n    pub outgoing_course: f32,\n    pub refund_amount: Option&lt;f32&gt;,\n    pub refund_course: Option&lt;f32&gt;,\n    pub refund_payment_method_id: Option&lt;String&gt;,\n    pub status: i32,\n    pub creation_date: String,\n    pub incoming_payment_detail: Option&lt;PaymentDetail&gt;,\n    pub outgoing_payment_detail: Option&lt;PaymentDetail&gt;,\n    pub refund_payment_detail: Option&lt;PaymentDetail&gt;,\n}\n\npub struct PaymentDetail {\n    pub id: String,\n    pub address: String,\n    pub is_verified: Option&lt;bool&gt;,\n}\n</code></pre> <pre><code>{\n    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"id\": {\n            \"type\": \"string\",\n            \"description\": \"The unique id of the order\"\n        },\n        \"is_payed_out\": {\n            \"type\": \"boolean\",\n            \"description\": \"Whether the order is payed out\"\n        },\n        \"is_approved\": {\n            \"type\": \"boolean\",\n            \"description\": \"Whether the order is approved\"\n        },\n        \"is_canceled\": {\n            \"type\": \"boolean\",\n            \"description\": \"Whether the order is canceled\"\n        },\n        \"fees_amount_eur\": {\n            \"type\": \"number\",\n            \"description\": \"The amount of fees in EUR\"\n        },\n        \"crypto_fees\": {\n            \"type\": \"number\",\n            \"description\": \"The amount of crypto fees\"\n        },\n        \"contract_id\": {\n            \"type\": \"string\",\n            \"description\": \"The id of the contract\"\n        },\n        \"incoming_payment_method_id\": {\n            \"type\": \"string\",\n            \"description\": \"The id of the incoming payment method\"\n        },\n        \"incoming_payment_method_currency\": {\n            \"type\": \"string\",\n            \"description\": \"The currency of the incoming payment method\"\n        },\n        \"incoming_amount\": {\n            \"type\": \"number\",\n            \"description\": \"The amount of the incoming payment\"\n        },\n        \"incoming_course\": {\n            \"type\": \"number\",\n            \"description\": \"The course of the incoming payment\"\n        },\n        \"outgoing_payment_method_id\": {\n            \"type\": \"string\",\n            \"description\": \"The id of the outgoing payment method\"\n        },\n        \"outgoing_payment_method_currency\": {\n            \"type\": \"string\",\n            \"description\": \"The currency of the outgoing payment method\"\n        },\n        \"outgoing_amount\": {\n            \"type\": \"number\",\n            \"description\": \"The amount of the outgoing payment\"\n        },\n        \"outgoing_course\": {\n            \"type\": \"number\",\n            \"description\": \"The course of the outgoing payment\"\n        },\n        \"refund_amount\": {\n            \"type\": [\"number\", \"null\"],\n            \"description\": \"The amount of the refund\"\n        },\n        \"refund_course\": {\n            \"type\": [\"number\", \"null\"],\n            \"description\": \"The course of the refund\"\n        },\n        \"refund_payment_method_id\": {\n            \"type\": [\"string\", \"null\"],\n            \"description\": \"The id of the refund payment method\"\n        },\n        \"status\": {\n            \"type\": \"integer\",\n            \"description\": \"The status of the order\"\n        },\n        \"creation_date\": {\n            \"type\": \"string\",\n            \"description\": \"The creation date of the order\"\n        },\n        \"incoming_payment_detail\": {\n            \"type\": [\"object\", \"null\"],\n            \"description\": \"The details of the incoming payment\",\n            \"properties\": {\n                \"id\": {\n                    \"type\": \"string\",\n                    \"description\": \"The unique id of the payment detail\"\n                },\n                \"address\": {\n                    \"type\": \"string\",\n                    \"description\": \"The address of the payment detail\"\n                }\n            },\n            \"required\": [\"id\", \"address\"]\n        },\n        \"outgoing_payment_detail\": {\n            \"type\": [\"object\", \"null\"],\n            \"description\": \"The details of the outgoing payment\",\n            \"properties\": {\n                \"id\": {\n                    \"type\": \"string\",\n                    \"description\": \"The unique id of the payment detail\"\n                },\n                \"address\": {\n                    \"type\": \"string\",\n                    \"description\": \"The address of the payment detail\"\n                }\n            },\n            \"required\": [\"id\", \"address\"]\n        },\n        \"refund_payment_detail\": {\n            \"type\": [\"object\", \"null\"],\n            \"description\": \"The details of the refund payment\",\n            \"properties\": {\n                \"id\": {\n                    \"type\": \"string\",\n                    \"description\": \"The unique id of the payment detail\"\n                },\n                \"address\": {\n                    \"type\": \"string\",\n                    \"description\": \"The address of the payment detail\"\n                }\n            },\n            \"required\": [\"id\", \"address\"]\n        }\n    },\n    \"required\": [\"id\", \"is_payed_out\", \"is_approved\", \"is_canceled\", \"fees_amount_eur\", \"crypto_fees\", \"contract_id\", \"incoming_payment_method_id\", \"incoming_payment_method_currency\", \"incoming_amount\", \"incoming_course\", \"outgoing_payment_method_id\", \"outgoing_payment_method_currency\", \"outgoing_amount\", \"outgoing_course\", \"status\", \"creation_date\"]\n}\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#get-swap-lists","title":"Get swap lists","text":"Method Arguments Returns Errors Dependencies Level Repeat Get swap list <code>start</code> - The start page parameter, <code>limit</code> - The pagination limit parameter Returns an array of <code>Order</code> containing the swap order details for each swap or an error. Returns <code>RepositoryInitError</code> - If the repository initialization fails, <code>ViviswapMissingUserError</code> - If the viviswap user is missing, <code>ViviswapApiError</code> - If there is an error with the Viviswap API Wallet initialization, Get KYC Details for viviswap Usage Application RustJavaSwift <pre><code>async fn get_swap_list(&amp;self, start: u32, limit: u32) -&gt; Result&lt;OrderList, crate::error::Error&gt;\n</code></pre> <pre><code>public String getSwapList(long page, long limit) throws Exception\n</code></pre> <pre><code>public func getSwapList(page: UInt64, limit: UInt64) throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#get-exchange-rate","title":"Get exchange rate","text":"Method Arguments Returns Errors Dependencies Level Repeat The exchange rate for the selected currency Returns the exchange rate Returns <code>ViviswapApiError</code> - If there is an error with the Viviswap API Usage Application RustJavaSwift <pre><code>async fn get_exchange_rate(&amp;self) -&gt; Result&lt;f32, crate::error::Error&gt;\n</code></pre> <pre><code>public float getExchangeRate() throws Exception\n</code></pre> <pre><code>public func getExchangeRate() throws -&gt; Float\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#transaction-functions","title":"Transaction functions","text":""},{"location":"SDK%20Reference/SDK%20API%20Reference/#create-purchase-request","title":"Create purchase request","text":"Method Arguments Returns Errors Dependencies Level Repeat Create purchase request <code>receiver</code> - The receiver's username, <code>amount</code> - The amount of the purchase, <code>product_hash</code> - The hash of the product, <code>app_data</code> - The application data, <code>purchase_type</code> - The type of the purchase The purchase ID. This is an internal index used to reference the transaction in Cawaena Returns an error if the user or wallet is not initialized, or if there is an error creating the transaction Wallet initialization Usage Application RustJavaSwift <pre><code>async fn create_purchase_request(\n    &amp;self,\n    receiver: &amp;str,\n    amount: f64,\n    product_hash: &amp;str,\n    app_data: &amp;str,\n    purchase_type: &amp;str,\n) -&gt; Result&lt;String, crate::error::Error&gt;\n</code></pre> <pre><code>public String purchaseRequestCreate(String receiver, double amount, String product_hash, String app_data,\n        String purchase_type) throws Exception \n</code></pre> <pre><code>public func createPurchaseRequest(\n    receiver: String, amount: Double, product_hash: String, app_data: String, purchase_type: String\n) throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#get-purchase-status","title":"Get purchase status","text":"Method Arguments Returns Errors Dependencies Level Repeat Get purchase status <code>purchase_id</code> - The ID of the purchase. The purchase status as <code>TxStatus</code> object Returns an error if the user or wallet is not initialized, or if there is an error getting the transaction status Wallet initialization Usage Application RustJavaSwift <pre><code>async fn get_purchase_status(&amp;self, purchase_id: &amp;str) -&gt; Result&lt;TxStatus, crate::error::Error&gt;\n</code></pre> <pre><code>public String purchaseStatus(String purchase_id) throws Exception\n</code></pre> <pre><code>public func getPurchaseStatus(purchase_id: String) throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#txstatus","title":"TxStatus","text":"RustJSON <pre><code>pub enum TxStatus {\n    #[default]\n    Pending,\n    Valid,\n    Invalid,\n    ProcessingMain,\n    ProcessingAux,\n    Completed,\n    Failed,\n}\n</code></pre> <pre><code>{\n    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n    \"type\": \"string\",\n    \"description\": \"The status of the transaction\",\n    \"enum\": [\"Pending\", \"Valid\", \"Invalid\", \"ProcessingMain\", \"ProcessingAux\", \"Completed\", \"Failed\"]\n}\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#get-purchase-details","title":"Get purchase details","text":"Method Arguments Returns Errors Dependencies Level Repeat Get purchase details <code>purchase_id</code> - The ID of the purchase. The purchase status as <code>PurchaseDetails</code> object Returns an error if the user or wallet is not initialized, or if there is an error getting the transaction status Wallet initialization Usage Application RustJavaSwift <pre><code>async fn get_purchase_details(&amp;self, purchase_id: &amp;str) -&gt; Result&lt;PurchaseDetails, crate::error::Error&gt;\n</code></pre> <pre><code>public String purchaseDetails(String purchase_id) throws Exception\n</code></pre> <pre><code>public func getPurchaseDetails(purchase_id: String) throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#purchasedetails","title":"PurchaseDetails","text":"RustJSON <pre><code>pub struct PurchaseDetails {\n    /// The main address where the fees goes to.\n    pub main_address: String,\n    /// The auxiliary address where the amount minus fees goes.\n    pub aux_address: String,\n    /// The amount to be paid.\n    pub amount: f64,\n    /// The fees to be paid.\n    pub fees: f64,\n}\n</code></pre> <pre><code>{\n    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"main_address\": {\n            \"type\": \"string\",\n            \"description\": \"The main address where the fees goes to\"\n        },\n        \"aux_address\": {\n            \"type\": \"string\",\n            \"description\": \"The auxiliary address where the amount minus fees goes\"\n        },\n        \"amount\": {\n            \"type\": \"number\",\n            \"description\": \"The amount to be paid\"\n        },\n        \"fees\": {\n            \"type\": \"number\",\n            \"description\": \"The fees to be paid\"\n        }\n    },\n    \"required\": [\"main_address\", \"aux_address\", \"amount\", \"fees\"]\n}\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#confirm-purchase-request","title":"Confirm purchase request","text":"Method Arguments Returns Errors Dependencies Level Repeat Confirm purchase request <code>pin</code> - The PIN of the user, <code>purchase_id</code> - The ID of the purchase. Returns, if the purchase request is confirmed successfully. Returns an error if the user or wallet is not initialized, if there is an error verifying the PIN, if there is an error getting the transaction details, or if there is an error committing the transaction. Wallet initialization Usage Application RustJavaSwift <pre><code>async fn confirm_purchase_request(&amp;self, pin: &amp;str, purchase_id: &amp;str) -&gt; Result&lt;(), crate::error::Error&gt;\n</code></pre> <pre><code>public void purchaseRequestConfirm(String pin, String purchase_id) throws Exception\n</code></pre> <pre><code>public func confirmPurchaseRequest(pin: String, purchase_id: String) throws\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#send-amount","title":"Send amount","text":"Method Arguments Returns Errors Dependencies Level Repeat Confirm purchase request <code>pin</code> - The PIN of the user, <code>address</code> - The receiver's address, <code>amount</code> - The amount to send Returns, if the amount is sent successfully. Returns an error if the user or wallet is not initialized, if there is an error verifying the PIN, or if there is an error sending the amount Wallet initialization Usage Application RustJavaSwift <pre><code>async fn send_amount(&amp;self, pin: &amp;str, address: &amp;str, amount: f64) -&gt; Result&lt;(), crate::error::Error&gt;\n</code></pre> <pre><code>public void transferAmount(String pin, String address, double amount) throws Exception\n</code></pre> <pre><code>public func sendAmount(pin: String, address: String, amount: Double) throws\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#get-purchase-list","title":"Get Purchase list","text":"Method Arguments Returns Errors Dependencies Level Repeat Get purchase list <code>page</code> - The page number, <code>limit</code> - The maximum number of transactions per page Returns a list of purchases as <code>TxInfo</code> object, if successful Returns an error if there is a problem getting the list of purchases. User initialization Usage Application RustJavaSwift <pre><code>async fn get_tx_list(&amp;self, page: u32, limit: u32) -&gt; Result&lt;TxList, crate::error::Error&gt;\n</code></pre> <pre><code>public String txList(long page, long limit) throws Exception \n</code></pre> <pre><code>public func getTxList(page: UInt64, limit: UInt64) throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#txinfo","title":"TxInfo","text":"RustJSON <pre><code>pub struct TxInfo {\n    /// Tx creation date, if available\n    pub date: Option&lt;String&gt;,\n    /// receiver of the transaction\n    pub receiver: String,\n    /// Cawaena reference id for the transaction\n    pub reference_id: String,\n    /// Application specific metadata attached to the tx\n    pub application_metadata: Option&lt;ApplicationMetadata&gt;,\n    /// Amount of transfer\n    pub amount: f64,\n    /// Currency of transfer\n    pub currency: String,\n    /// Status of the transfer\n    pub status: TxStatus,\n    /// The transaction hash on the network\n    pub transaction_hash: Option&lt;String&gt;,\n    /// Exchange rate\n    pub course: f64,\n}\n\npub struct ApplicationMetadata {\n    pub product_hash: String,\n    pub reason: String,\n    pub purchase_model: String,\n    pub app_data: String,\n}\n</code></pre> <pre><code>{\n    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"date\": {\n            \"type\": [\"string\", \"null\"],\n            \"description\": \"Tx creation date, if available\"\n        },\n        \"receiver\": {\n            \"type\": \"string\",\n            \"description\": \"receiver of the transaction\"\n        },\n        \"reference_id\": {\n            \"type\": \"string\",\n            \"description\": \"Cawaena reference id for the transaction\"\n        },\n        \"application_metadata\": {\n            \"type\": [\"object\", \"null\"],\n            \"description\": \"Application specific metadata attached to the tx\",\n            \"properties\": {\n                \"product_hash\": {\n                    \"type\": \"string\",\n                    \"description\": \"The product hash\"\n                },\n                \"reason\": {\n                    \"type\": \"string\",\n                    \"description\": \"The reason for the transaction\"\n                },\n                \"purchase_model\": {\n                    \"type\": \"string\",\n                    \"description\": \"The purchase model\"\n                },\n                \"app_data\": {\n                    \"type\": \"string\",\n                    \"description\": \"The application data\"\n                }\n            },\n            \"required\": [\"product_hash\", \"reason\", \"purchase_model\", \"app_data\"]\n        },\n        \"amount\": {\n            \"type\": \"number\",\n            \"description\": \"Amount of transfer\"\n        },\n        \"currency\": {\n            \"type\": \"string\",\n            \"description\": \"Currency of transfer\"\n        },\n        \"status\": {\n            \"type\": \"string\",\n            \"description\": \"Status of the transfer\",\n            \"enum\": [\"Pending\", \"Valid\", \"Invalid\", \"ProcessingMain\", \"ProcessingAux\", \"Completed\", \"Failed\"]\n        },\n        \"transaction_hash\": {\n            \"type\": [\"string\", \"null\"],\n            \"description\": \"The transaction hash on the network\"\n        },\n        \"course\": {\n            \"type\": \"number\",\n            \"description\": \"Exchange rate\"\n        }\n    },\n    \"required\": [\"receiver\", \"reference_id\", \"amount\", \"currency\", \"status\", \"course\"]\n}\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#postident-functions","title":"Postident functions","text":""},{"location":"SDK%20Reference/SDK%20API%20Reference/#start-kyc-verification-for-postident","title":"Start kyc verification for postident","text":"Method Arguments Returns Errors Dependencies Level Repeat Start kyc verification for postident Returns an object <code>NewCaseIdResponse</code> if successful, or an <code>Error</code> if an error occurs. <code>RepositoryInitError</code> if the repository fails to initialize, <code>UserInitError</code> if the user fails to initialize, <code>UserAlreadyKycVerifiedError</code> if the user is already KYC verified. User initialization Usage Application RustJavaSwift <pre><code>async fn start_kyc_verification_for_postident(&amp;mut self) -&gt; Result&lt;NewCaseIdResponse, crate::error::Error&gt;\n</code></pre> <pre><code>public String startKycVerificationForPostident() throws Exception\n</code></pre> <pre><code>public func startKycVerificationForPostident() throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#newcaseidresponse","title":"NewCaseIdResponse","text":"RustJSON <pre><code>pub struct NewCaseIdResponse {\n    /// New Postident case id\n    pub case_id: String,\n    /// Case url\n    pub case_url: String,\n}\n</code></pre> <pre><code>{\n    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"case_id\": {\n            \"type\": \"string\",\n            \"description\": \"New Postident case id\"\n        },\n        \"case_url\": {\n            \"type\": \"string\",\n            \"description\": \"Case url\"\n        }\n    },\n    \"required\": [\"case_id\", \"case_url\"]\n}\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#get-case-details-for-postident","title":"Get case details for postident","text":"Method Arguments Returns Errors Dependencies Level Repeat Get case details for postident Returns an object <code>CaseDetailsResponse</code> if successful, or an <code>Error</code> if an error occurs. UserInitError` if the user fails to initialize User initialization Usage Application RustJavaSwift <pre><code>async fn get_kyc_details_for_postident(&amp;self) -&gt; Result&lt;CaseDetailsResponse, crate::error::Error&gt;\n</code></pre> <pre><code>public String getKycDetailsForPostident() throws Exception\n</code></pre> <pre><code>public func getKycDetailsForPostident() throws -&gt; String\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#casedetailsresponse","title":"CaseDetailsResponse","text":"RustJSON <pre><code>pub struct CaseDetailsResponse {\n    pub case_id: String,\n    pub archived: bool,\n    pub status: String,\n}\n</code></pre> <pre><code>    {\n        \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n        \"type\": \"object\",\n        \"properties\": {\n            \"case_id\": {\n                \"type\": \"string\",\n                \"description\": \"The Postident case id\"\n            },\n            \"archived\": {\n                \"type\": \"boolean\",\n                \"description\": \"Whether the case is archived\"\n            },\n            \"status\": {\n                \"type\": \"string\",\n                \"description\": \"The status of the case\"\n            }\n        },\n        \"required\": [\"case_id\", \"archived\", \"status\"]\n    }\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#update-case-status-for-postident","title":"Update case status for postident","text":"Method Arguments Returns Errors Dependencies Level Repeat Update case status for postident <code>case_id</code>: The ID of the case to update. Returns,<code>if successful, or an</code>Error<code>if an error occurs. | UserInitError</code> if the user fails to initialize User initialization Usage Application RustJavaSwift <pre><code>async fn update_kyc_status_for_postident(&amp;self, case_id: &amp;str) -&gt; Result&lt;(), crate::error::Error&gt;\n</code></pre> <pre><code>public void updateKycStatusForPostident(String case_id) throws Exception\n</code></pre> <pre><code>public func updateKycStatusForPostident(case_id: String) throws\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#billing-account-functions","title":"Billing account functions","text":""},{"location":"SDK%20Reference/SDK%20API%20Reference/#create-a-new-billing-customer-account","title":"Create a new billing customer account","text":"Method Arguments Returns Errors Dependencies Level Repeat Create a new account <code>country_code</code> - The country code for the customer. Returns,<code>if successful, or an</code>Error<code>if an error occurs. | UserInitError</code> if the user fails to initialize User initialization Usage User RustJavaSwift <pre><code>async fn create_customer(&amp;self, country_code: &amp;str) -&gt; Result&lt;(), crate::error::Error&gt; \n</code></pre> <pre><code>public void customerCreate(String country_code) throws Exception\n</code></pre> <pre><code>public func createCustomer(country_code: String) throws\n</code></pre>"},{"location":"SDK%20Reference/SDK%20API%20Reference/#get-account-status","title":"Get account status","text":"Method Arguments Returns Errors Dependencies Level Repeat Fetches the customer account and updates it internally Returns,<code>if successful, or an</code>Error<code>if an error occurs. | UserInitError</code> if the user fails to initialize, or if there is an issue retrieving the customer account details. User initialization Usage Application RustJavaSwift <pre><code>async fn get_customer(&amp;mut self) -&gt; Result&lt;(), crate::error::Error&gt; \n</code></pre> <pre><code>public void customerGet() throws Exception\n</code></pre> <pre><code>public func getCustomer() throws \n</code></pre>"},{"location":"SDK%20Release%20Notes/Release%20Notes/","title":"Release Notes","text":""},{"location":"SDK%20Release%20Notes/Release%20Notes/#0121-2024-06-27","title":"[0.12.1] - 2024-06-27","text":""},{"location":"SDK%20Release%20Notes/Release%20Notes/#bug-fixes","title":"\ud83d\udc1b Bug Fixes","text":"<ul> <li>Api currency backwards compatibility</li> </ul>"},{"location":"SDK%20Release%20Notes/Release%20Notes/#0120-2024-06-19","title":"[0.12.0] - 2024-06-19","text":""},{"location":"SDK%20Release%20Notes/Release%20Notes/#features","title":"\ud83d\ude80 Features","text":"<ul> <li>Publish swift bindings package</li> <li>Add function to initialize a wallet from a mnemonic without stronghold</li> </ul>"},{"location":"SDK%20Release%20Notes/Release%20Notes/#bug-fixes_1","title":"\ud83d\udc1b Bug Fixes","text":"<ul> <li>Handle case id not found</li> <li>Update txs details query page param</li> </ul>"},{"location":"SDK%20Release%20Notes/Release%20Notes/#refactor","title":"\ud83d\ude9c Refactor","text":"<ul> <li>Seprate create_new_wallet from init_wallet</li> <li>(sdk) Split viviswap with feature flags</li> <li>Adding xml for generating pom and setting xml files</li> </ul>"},{"location":"SDK%20Release%20Notes/Release%20Notes/#documentation","title":"\ud83d\udcda Documentation","text":"<ul> <li>Update transactions validator docs</li> <li>Update kyc service docs</li> <li>Update user data service docs</li> <li>Update postident service docs</li> <li>Update webhook service docs</li> <li>Update main readme</li> </ul>"},{"location":"SDK%20Release%20Notes/Release%20Notes/#testing","title":"\ud83e\uddea Testing","text":"<ul> <li>Add tests for the webhook-aggregator</li> </ul>"},{"location":"SDK%20Release%20Notes/Release%20Notes/#miscellaneous-tasks","title":"\u2699\ufe0f Miscellaneous Tasks","text":"<ul> <li>Add commit sha for android sdk version</li> <li>(docs) Generate changelog from conventional commits</li> <li>Add testing crate</li> <li>Added deploy for wasm web target</li> <li>Bump <code>neon</code> to 1.0.0 for nodejs</li> <li>Bump version to 1.3.2 for dev container added kubectl and k9s</li> <li>Update pipeline to cache only on cargo-check push</li> <li>Updating toml files storing dependency in alphabetically sorted order</li> <li>Use rules of upstream pipeline</li> <li>(release) Bump version to 0.12</li> <li>(test) Fix conflicting tx using different account for test</li> </ul>"},{"location":"SDK%20Release%20Notes/Release%20Notes/#0110-2024-08-06","title":"[0.11.0] - 2024-08-06","text":""},{"location":"SDK%20Release%20Notes/Release%20Notes/#features_1","title":"\ud83d\ude80 Features","text":"<ul> <li>Allow multiple DLT nodes in SDK config</li> <li>Publish android SDK to Jfrog MVN</li> <li>Use array and Option in JNI bindings</li> </ul>"},{"location":"SDK%20Release%20Notes/Release%20Notes/#bug-fixes_2","title":"\ud83d\udc1b Bug Fixes","text":"<ul> <li>Admin service - add proper JSON format handling for send_event command</li> <li>Satoshi not kyc verified issue</li> <li>Don't return error when block does not have transaction payload</li> <li>Added resiliency against dapr when starting services</li> </ul>"},{"location":"SDK%20Release%20Notes/Release%20Notes/#refactor_1","title":"\ud83d\ude9c Refactor","text":"<ul> <li>Move errors from common crate into services</li> <li>Remove duplicate client implementations from common</li> <li>Replace TxCreated event with grpc call</li> </ul>"},{"location":"SDK%20Release%20Notes/Release%20Notes/#miscellaneous-tasks_1","title":"\u2699\ufe0f Miscellaneous Tasks","text":"<ul> <li>Update opentelemetry</li> </ul>"},{"location":"SDK%20Release%20Notes/Release%20Notes/#v0104","title":"[v0.10.4]","text":"<ul> <li>Added <code>get_wallet_transaction_list</code> - Returns the list of transactions of wallet by taking page and page size as a parameter.</li> <li>Added <code>get_wallet_transaction</code> - Returns the detailed report of particular transaction by taking transaction id as a parameter.</li> </ul>"},{"location":"SDK%20Release%20Notes/Release%20Notes/#v0100","title":"[v0.10.0]","text":"<ul> <li>The objects returned by <code>getTxList</code> now also include the exchange rate used for each transaction in the new field \"course\"</li> <li>Pagination of <code>getTxList</code> now works correctly.</li> <li>The functions <code>setCurrency</code> (introduced in v0.9.0), <code>getSwapList</code> and <code>getSwapDetails</code> (introduced in v0.8.2) had issues with the binding due to naming and could not be called from android, that has now been fixed and the functions are callable as intended.</li> <li>Added a check so that a transaction cannot be committed until it is marked as \u201cValid\u201d by the backend. This partially fixes the issue with being able to give more compliments than the daily limit.</li> </ul>"},{"location":"SDK%20Release%20Notes/Release%20Notes/#v090","title":"[v0.9.0]","text":"<ul> <li>Added new function <code>setCurrency</code>. From this version, this method will handle(setNodeUrl, setCoinType, setBech32Hrp) operations. For this reason those methods have been removed.</li> <li>Added new function `deleteUser. This method will allow a user to request to delete all of his data.</li> </ul>"},{"location":"SDK%20Release%20Notes/Release%20Notes/#v080","title":"[v0.8.0]","text":"<ul> <li>Added <code>getSwapList</code>. Retrieves the list of all the swaps(viviswap orders) performed by a user</li> <li>Added <code>getSwapDetails</code>. Retrieves details for a specific swap(order in viviswap)</li> </ul>"},{"location":"SDK%20Release%20Notes/Release%20Notes/#v073","title":"[v0.7.3]","text":"<ul> <li>Updated <code>get_iban</code> function. It now gives is_verified flag to show if the IBAN is verified by viviswap or not.</li> <li>The <code>createPurchaseRequest</code> function now requires the string literal \"CLIK\" as the string value in parameter <code>purchase_type</code> for compliments instead of \"COMPLIMENT\".</li> <li>Improved balance function internally to find hidden balances.</li> </ul>"},{"location":"SDK%20Release%20Notes/Release%20Notes/#v071","title":"[v0.7.1]","text":"<ul> <li>Viviswap onboarding stabilized</li> <li>Production environment auth provider string was fixed (cawaenaprod \u2192 cawaena)</li> <li><code>UpdateIBAN</code> method now deletes old IBAN and inserts the new one, so that the old IBAN can be re-used on other accounts</li> </ul>"},{"location":"SDK%20Release%20Notes/Release%20Notes/#v070","title":"[v0.7.0]","text":"<ul> <li>Added new function <code>updateCustomer</code> which updates or creates a new customer account for billing. It requires the two-character  country code of the user, which can be the same as the one used while doing a new user registration. Calling this function is mandatory before initializing wallet. The list of valid/legally allowed country codes will be given to the team before go-live.</li> <li>Modified the function createPurchaseRequest. It now requires three more parameters: <code>product_hash</code>, <code>app_data</code> (may be empty but can be used to store additional data of the image like thumbnail URL etc\u2026), <code>purchase_type</code> (Required currently and should be set to the constant value \u201cCOMPLIMENT\u201d)</li> <li><code>getBalance</code> is now modified internally. It performs claiming of dust outputs, so that micro-transactions and locked outputs do not get lost. if not claimed. This feature is only internal to the crypto-currency and has no impact on the UX/UI.</li> <li>QA and staging environment now use SMR mainnet. Getting tokens now happens via either purchase from viviswap or transfer of existing SMR from own wallet-</li> <li>Webhook notifications can now be encrypted.</li> </ul>"},{"location":"SDK%20Release%20Notes/Release%20Notes/#v064","title":"[v0.6.4]","text":"<ul> <li>Added new function <code>getTxList</code> which gives list of purchases and supports pagination. It gives the transaction list of all the transaction sent and received. If the value of the \u201creceiver\u201d is same as the username, the transaction was received, if different, then the transaction was sent.</li> </ul>"},{"location":"SDK%20Release%20Notes/Release%20Notes/#v063","title":"[v0.6.3]","text":"<ul> <li>Added new optional function <code>setSdkEnv</code> which sets up the environment correctly according to predefined values, instead of setting up config individually. Individual config settings are still possible.</li> <li>Fixed issues related to compliments not working</li> <li>Fixed reported issues in capacitor plugin wrapper methods</li> <li>Staging environment now uses SMR mainnet. Getting tokens now happens via either purchase from viviswap or transfer of existing SMR from own wallet.</li> <li>The IOTA cryptocurrency is no longer MIOTA. Renamed to IOTA overall</li> </ul>"},{"location":"SDK%20Release%20Notes/Release%20Notes/#v062","title":"[v0.6.2]","text":"<ul> <li>Modified <code>createDepositWithViviswap</code> function to accept no arguments any more.</li> <li>Modified <code>createWithdrawWithViviswap</code> requirements</li> </ul>"},{"location":"SDK%20Release%20Notes/Release%20Notes/#v061","title":"[v0.6.1]","text":"<ul> <li>Modified <code>initLogger</code> function. Now no parameters are required. It however requires at least <code>setPathPrefix</code> and <code>setLogLevel</code>. Now returns error if logger cannot be initialized.</li> <li>Added <code>createViviswapDetail</code> function needed to perform withdrawals. It does not take any parameters.</li> <li>Modified <code>createWithdrawalWithViviswap</code> to now accept pin. If a pin is given, it tries to automatically perform withdrawal and also provides details for withdrawal. If no pin is given, it will just create a detail (address and an id) for manual withdrawal.</li> <li>Fixed issues with deposit and withdrawal at viviswap</li> </ul>"},{"location":"SDK%20Release%20Notes/Release%20Notes/#v060","title":"[v0.6.0]","text":"<ul> <li>Added two new configuration settings <code>setCoinType</code> and <code>setBech32Hrp</code> which are now mandatory.</li> <li>Added helper function <code>validateConfig</code> for checking if configuration is correct. Currently it performs only syntactical validation and not semantical.</li> <li>Modified viviswap deposit and withdraw functions to now use the <code>coin type</code> set in the config to correctly create payment details.</li> <li>Added <code>getExchangeRate</code> function to fetch the latest exchange rate. The exchange rate considers the <code>coin type</code> set in the config with EUR for the course.</li> <li>Sdk will support MIOTA along with SMR after stardust upgrade on Mainnet (04.10.2023)</li> </ul>"},{"location":"SDK%20Release%20Notes/Release%20Notes/#v052","title":"[v0.5.2]","text":"<ul> <li>Fixed issue in swift code and iOS bindings to make error responses exact to android bindings</li> <li>Migrated to iota-sdk from now deprecated wallet.rs</li> </ul>"},{"location":"SDK%20Release%20Notes/Release%20Notes/#v050","title":"[v0.5.0]","text":"<ul> <li>Switched to SMR wallet. No changes in the SDK interface/functions</li> <li>Using JammDB instead of RocksDB to resolve issues with iOS SDK</li> </ul>"},{"location":"SDK%20Release%20Notes/Release%20Notes/#v040","title":"[v0.4.0]","text":"<ul> <li>The functions <code>setAuthProvider</code>, <code>setPathPrefix</code>, <code>setBackendUrl</code> are not optional anymore.</li> <li>Switched to IOTA wallet. No change in the SDK interface/functions.</li> <li>Added new function setNodeUrl to set the IOTA Node URL (can be used with Mainnet as well)</li> <li>iOS SDK Class now 1-to-1 with Java SDK Class definition.</li> </ul>"},{"location":"SDK%20Release%20Notes/Release%20Notes/#v030","title":"[v0.3.0]","text":"<ul> <li>Added viviswap functions for updating IBAN, creating deposit and withdrawal details</li> <li>Fixed a bug where user IOTA address was not getting updated in backend. This lead to failure in purchaseRequest flow. This is now fixed and it requires that all KYC verified users at least call <code>generateNewIotaReceiverAddress</code> before receiving and sending compliments.</li> <li>iOS now gives similar error descriptions to android</li> <li>Wallet backup and delete functions now end gracefully by dropping all open handles.</li> <li>Swift Plugin is now functionally same to Java.</li> </ul>"},{"location":"Under%20the%20Hood/SDK%20Internals/","title":"SDK Internals","text":"<p>The Cawaena SDK is built in <code>rust</code>. It is primarily an implementation of the various interfaces for managing users, wallets, on-boarding of users through KYC (Know Your Customer) processes, payment methods and listing usage information.</p> <p>The SDK was designed to support the <code>Cawaena</code> application. It is a social media application, which allows monetization of user-generated content. However, in the same principle, any digital data, given that it is authentic and its origin can be verified, can be monetized using the Cawaena ecosystem, which includes the Cawaena infrastructure and the sdk.</p> <p>The big picture behind Cawaena is a data marketplace. Data processing, silo management and search engine features have been excluded by design from Cawaena to make it a minimal ecosystem for monetization.</p>"},{"location":"Under%20the%20Hood/SDK%20Internals/#overview-of-the-sdk-functional-components","title":"Overview of the SDK functional components","text":"<p>The figure below shows the functional component diagram of the SDK. The core of the SDK is a web3 hot-wallet. This wallet is used to store assets on the local machine running the application built with the SDK. The supporting components like the backend API, user state management and access control logic work for improving ease of use for the end user as well as ensuring correct process flow and state transitions between the Cawaena infrastructure and application.</p> <p>The binding layer is just a simple 1-to-1 wrapper around the SDK interface functionality. This just exports the existing business logic implemented in the SDK in rust to other programming stacks to avoid re-implementation as well as guarantee memory safety natively in code.</p> <p>The access control section at the bottom shows the input parameters needed from the user/application to authenticate itself against the SDK. For the one-time on-boarding in addition to the <code>pin</code> and <code>access_token</code> the <code>username</code> and <code>password</code> is also needed. For regular usage, the <code>pin</code>, whenever required and <code>access_token</code> is required to ensure smooth handling of operations, including internal function calls to the Cawaena infrastructure and the wallet.</p> <pre><code>+-------------------------------------------------------------------------------+\n|                                                                               |\n|   +-----------------------------------------------------------------------+   |\n|   |                                                                       |   |\n|   |                                                                       |   |\n|   |   +---------------------------------------------+    +--------------+ |   |\n|   |   |                                             |    |              | |   |\n|   |   |   +-------------------------------------+   |    |   Backend    | |   |\n|   |   |   |                                     |   |    |   API        | |   |\n|   |   |   |     +------------------------+      |   |    |              | |   |\n|   |   |   |     |                        |      |   |    +--------------+ |   |\n|   |   |   |     |                        |      |   |                     |   |\n|   |   |   |     |                        |      |   |                     |   |\n|   |   |   |     |       IOTA SDK         |      |   |    +--------------+ |   |\n|   |   |   |     |                        |      |   |    |              | |   |\n|   |   |   |     |       Stronghold       |      |   |    | User         | |   |\n|   |   |   |     |         wallet         |      |   |    | State        | |   |\n|   |   |   |     |         manager        |      |   |    | Management   | |   |\n|   |   |   |     |                        |      |   |    +--------------+ |   |\n|   |   |   |     +------------------------+      |   |                     |   |\n|   |   |   |                                     |   |                     |   |\n|   |   |   |           Wallet Manager            |   |    +--------------+ |   |\n|   |   |   +-------------------------------------+   |    |              | |   |\n|   |   |                                             |    |   Access     | |   |\n|   |   |                Wallet User                  |    |   Control    | |   |\n|   |   |                                             |    |   Logic      | |   |\n|   |   +---------------------------------------------+    +--------------+ |   |\n|   |                         SDK                                           |   |\n|   +-----------------------------------------------------------------------+   |\n|                           Bindings                                            |\n|                                                                               |\n|                                                                               |\n+--+--------------------------------------+------+----------------------------+-+\n   |      Onboarding authentication       |      |   Usage authentication     |  \n   |                                      |      |                            |  \n   +--^---------^-------^---------^-------+      +-----^-----------^----------+  \n      |         |       |         |                    |           |             \n      |         |       |         |                    |           |             \n      |         |       |         |                    |           |             \n   Username  Password  Pin    Access token            Pin      Access token      \n</code></pre>"},{"location":"Under%20the%20Hood/SDK%20Internals/#understanding-android-bindings","title":"Understanding android bindings","text":"<p>The <code>libc++_shared.so</code> files are packaged together with the generated <code>*.so</code> files from cargo. These files are required by the corresponding system binary loader to correctly load the*.so files from the jniLibs folder using the convention</p> <pre><code>System.loadLibrary(\"library_name\");\n</code></pre> <p>The library should be named with the prefix <code>lib</code> and the suffix <code>.so</code>. This is how the libraries are created by cargo when specifying the <code>crate-type</code> as <code>cdylib</code>. If the <code>libc++_shared.so</code> files for the corresponding architecture are not included, loading the library works a bit differently, however this method is not portable across different platforms.</p> <pre><code>System.load(\"absolute/path/to/lib/with/library_name.so\");\n</code></pre>"},{"location":"Under%20the%20Hood/SDK%20Internals/#creating-a-java-wrapper","title":"Creating a java wrapper","text":"<p>To support integration in java via a wrapper class, it is important to create the native methods in java and wrap them through a public method inside the class.</p> <p>The convention followed by JNI is crucial here. The convention followed for declaring function names which are JNI compatible is: Java_{TLD}{Org_Name} where TLD = Top Level Domain Org_Name = Organization name Class_Name = Name of the class, whose method is private static and native. function_Name = Name of the function}_{function_Name</p> <p>Example: In Java, for the function <code>setCurrencyJni</code>, the following code is needed</p> <pre><code>// filename: CryptpaySdk.java\npackage com.etogruppe; // com is the TLD and etogruppe is the org_name\n\npublic class CryptpaySdk { // Class_name\n    static {\n        System.loadLibrary(\"walletsdk\");\n    }\n    private static native void setCurrencyJni(String currency); // function_Name\n    // other native functions here\n\n    public void setCurrency(String currency) throws Exception {\n        setCurrencyJni(currency);\n    }\n\n}\n</code></pre> <p>This would translate to a rust function as per the rule, with <code>no_mangle</code>, to tell the rust compiler to not mangle the function name in the resulting binary.</p> <p>One point to note is not to use <code>snake_case</code> names of functions, because the JNI would deduce it as class path. <code>lowerCamelCase</code> or <code>CamelCase</code> is allowed.</p> <pre><code>// lib.rs\n#[no_mangle]\npub extern \"system\" fn Java_com_etogruppe_CryptpaySdk_setCurrencyJni(mut env: JNIEnv&lt;'local&gt;,\n    _class: JClass&lt;'local&gt;) {\n      // implementation\n    }\n</code></pre> <p>The two variables are passed by the JNI call to rust, namely the JNIEnv and the java class. The JClass is an empty place holders to satisfy the Java interface. The JNI environment is a constant pointer the JNI environment and can be used to call methods for checking and raising exceptions as shown below.</p> <pre><code>// lib.rs\nfn on_error_null(error: SdkError, env: &amp;mut JNIEnv) {\n    // fearlessly doing unwraps here, because we are already in exception\n    if env.exception_check().unwrap() {\n        // exception was raised,  clear it and raise again\n        // to return back to JVM\n        env.exception_clear().unwrap();\n    }\n    env.throw(format!(\"{error:#?}\")).unwrap();\n}\n</code></pre> <p>It can also be used to get strings and other objects from the java native to rust safely and pass back rust strings as java string objects back. These methods are needed almost on every function call and return, and hence have been written as macros to reduce code repetitions.</p> <pre><code>// lib.rs\nmacro_rules! get_jni_string {\n    ($env:ident, $on_error:ident, $input_string:expr) =&gt; {{\n        let jni_string = match $env.get_string(&amp;$input_string) {\n            Ok(jni_string) =&gt; String::from(jni_string),\n            Err(err) =&gt; {\n                let error = SdkError::UnhandledError(format!(\"Invalid string input: {err:#}\"));\n                $on_error(error, &amp;mut $env);\n                String::from(\"\")\n            }\n        };\n        jni_string\n    }};\n}\n\nmacro_rules! set_jni_string {\n    ($env:expr, $string:expr) =&gt; {\n        $env.new_string($string).unwrap()\n    };\n}\n</code></pre>"},{"location":"Under%20the%20Hood/SDK%20Internals/#futures-across-the-abi-boundary-in-java","title":"Futures across the ABI boundary in Java","text":"<p>As noticed in the previous example of the rust function, the prefix <code>extern \"system\"</code> is used  to tell compiler some information on how the function is going to be called. The <code>extern</code> helps the compiler to know that the function will be called from outside of rust. The <code>system</code> describes the application binary interface (ABI) to use to define the function in binary code. With <code>system</code> the systems ABI is to be used. This ABI is defined by each system according to the target-triplet configured during the cargo build command.</p> <p>As we will see later, we could also use <code>C</code> ABI to expose our functions using the <code>C</code> calling conventions in the binary interface. Based on the ABI selected, different applications running on the same host machine and using the same operating system can interact with each other through the binary layer for exchanging information or calling functions.</p> <p>Unfortunately, on the binary layer there is no easy concept of futures, since there is no scheduler, which can periodically check if a result of a certain function call is available. Calling an external application function from another application is generally synchronous and the result is returned immediately. This means that for asynchronous function calls like HTTP requests, a blocking [sync] call has to be used by the external application and the calling application has to treat the function call as synchronous.</p> <p>For the Cawaena SDK, there is a runtime thread started and used for calling the SDK functions, in this case, are all asynchronous. Using <code>OnceCell</code> this runtime thread is created on the first call to any SDK function and reused by all others.</p> <pre><code>// lib.rs\nfn runtime() -&gt; &amp;'static Arc&lt;Runtime&gt; {\n    static INSTANCE: OnceCell&lt;Arc&lt;Runtime&gt;&gt; = OnceCell::new();\n    INSTANCE.get_or_init(|| {\n        Arc::new(\n            tokio::runtime::Builder::new_multi_thread()\n                .thread_name(\"com.standalone.sdk.thread\")\n                .worker_threads(1)\n                .enable_all()\n                .build()\n                .unwrap(),\n        )\n    })\n}\n</code></pre> <p>This results in a function definition without need of async await in the exposed interface, since currently there are no known ABI's that support this. The future is actively blocked on, thus making it synchronous.</p> <pre><code>// lib.rs\n// async/await is not allowed in the function definition here. Is there any ABI that could do it?\n#[no_mangle]\npub extern \"system\" fn Java_com_etogruppe_CryptpaySdk_setPathPrefix&lt;'local&gt;( \n    mut env: JNIEnv&lt;'local&gt;,\n    _class: JClass&lt;'local&gt;,\n    path_prefix: JString&lt;'local&gt;,\n) {\n    let path_prefix = get_jni_string!(env, on_error_null, path_prefix);\n\n    runtime().block_on(async move {\n      // async/await can be done here as it is inside a thread which is \"blocked on\" i.e. synchronous\n        let mut sdk = get_or_init_sdk().write().await;\n        sdk.set_path_prefix(&amp;path_prefix)\n    });\n}\n</code></pre> <p>A nice way to solve this on the other side would be to wrap the native ABI calls in an interface which uses the futures framework of the used programming language (if available). So, the java class would now look something like this:</p> <pre><code>// filename: CryptpaySdk.java\npackage com.etogruppe; \nimport java.util.concurrent.Future; // get the future support from the language\n\npublic class CryptpaySdk { \n    static {\n        System.loadLibrary(\"walletsdk\");\n    }\n    private static native void setCurrencyJni(String currency); \n\n    // exposed class method now gives a future wrapped void and not just void!\n    public Future&lt;void&gt; setCurrency(String currency) throws Exception {\n        setCurrencyJni(currency);\n    }\n}\n</code></pre> <p>Wrapping the exposed interface with a future, tells the application which builds on top of this external library function, that it is indeed asynchronous and can implement mechanisms to handle it correspondingly.</p>"},{"location":"Under%20the%20Hood/SDK%20Internals/#understanding-swift-bindings","title":"Understanding Swift bindings","text":""},{"location":"Under%20the%20Hood/SDK%20Internals/#generating-ios-xcframeworks","title":"Generating iOS xcframeworks","text":"<p>The iOS ecosystem allows developers to create xcframeworks, which are a distribution format that contains multiple architectures and platforms in a single bundle. The xcframeworks offer advantages such as improved performance, reduced app size, and easier distribution and integration.</p> <p>Our xcframework structure is as following:</p> <ul> <li>CryptpaySdkBin.xcframework/</li> <li>ios-arm64/<ul> <li>Headers/</li> <li>generated/<ul> <li>Cawaena-sdk-swift-new/</li> <li>Cawaena-sdk-swift-new.h</li> <li>SwiftBridgeCore.h</li> </ul> </li> <li>bridging-header.h</li> <li>module.modulemap</li> <li>libwalletsdk_cabi_new.a</li> </ul> </li> <li>macos-arm64_x86_64/<ul> <li>Headers/</li> <li>generated/<ul> <li>Cawaena-sdk-swift-new/</li> <li>Cawaena-sdk-swift-new.h</li> <li>SwiftBridgeCore.h</li> </ul> </li> <li>bridging-header.h</li> <li>module.modulemap</li> <li>libwalletsdk_cabi_new.a</li> </ul> </li> </ul> <p>The creation can be done using the <code>xcodebuild</code> command, which takes the static library as input and an include section, which is actually a folder containing at most one module.modulemap file and any other C header files which describe the interface to the static library, assuming that it is C ABI.</p> <p>The module map should include all the header files for working with the static library and re-export them as shown below.</p> <pre><code>module CryptpaySdkBin {\n    header \"bridging-header.h\"\n    export *\n}\n</code></pre> <p>The module name is important here. It needs to have the name of the package binary which in our case is <code>CryptpaySdkBin</code>.</p> <p>The <code>bridging-header.h</code> file includes the auto-generated files from the <code>swift-bridge</code> crate which we explain in more details on the <code>header files</code> section below.</p> <p>The <code>lipo</code> utility is used to re-arrange the Rust generated static library with binary information. It allows developers to combine multiple architectures into a single binary file.</p> <p>Installing an xcframework in the iOS app development environment is simply done by dragging and dropping the xcframework file in xcode or importing it using the settings menu.</p>"},{"location":"Under%20the%20Hood/SDK%20Internals/#swift-package","title":"Swift package","text":"<p>Previously we were bundling our Swift bindings into a <code>.zip</code> file and exporting it. This was not very practical for the users and also for us since we need to bundle, download it and give it to our users manually. Instead, we want to offer it as a package. In this version we generate a Swift package instead which can be imported as a dependency. The structure of our Swift package is as following:</p> <ul> <li>CryptpaySdk/</li> <li>CryptpaySdkBin.xcframework/</li> <li>Sources/<ul> <li>CryptpaySdk/</li> <li>SwiftBridgeCore.swift</li> <li>Cawaena-sdk-swift-new.swift</li> <li>vectorizable.swift</li> </ul> </li> <li>Package.swift</li> </ul> <p>The <code>CryptpaySdkBin.xcframework</code> creation and its internal structure is explained in the above <code>Generating iOS xcframeworks</code> section. The <code>SwiftBridgeCore.swift</code> and <code>Cawaena-sdk-swift-new.swift</code> files are auto-generated by the <code>swift-bridge</code> crate.  </p> <p>The <code>vectorizable.swift</code> contains custom implementations for Rust types which cannot be bridged directly to Swift. For example the <code>Vec&lt;KycOpenDocument</code> type needs to implement the <code>Vectorizable</code> to compile in Swift. This is due to some limitations on the crate which need some workaround to compile properly.  </p> <p>Finally, the <code>Package.swift</code> is the actual file that generates the Swift package called <code>CryptpaySdk</code>. In xcode we can add the CryptpaySdk packge and initialize the constructor and call its functions (our Rust bindings):  </p> <pre><code>  import CryptpaySdk\n  let sdk = CryptpaySdk()\n  try await sdk.setEnvironment(\"development\")\n</code></pre>"},{"location":"Under%20the%20Hood/SDK%20Internals/#swift-bridge","title":"Swift-Bridge","text":"<p>We are using the <code>swift-bridge</code> crate to generate the Swift bindings.</p>"},{"location":"Under%20the%20Hood/SDK%20Internals/#built-in-types","title":"Built-in Types","text":"<p>The <code>swift-bridge</code> crate uses the <code>#[swift_bridge::bridge]</code> procedural macro to declare a bridge module. This macro parses the bridge module at compile time and then generates the Rust side of the FFI layer. The bridge module is declared inside the <code>lib.rs</code> module.</p> <pre><code>#[swift_bridge::bridge]\npub mod ffi {\n    pub enum UserState {\n        Undefined,\n        New,\n        Verified,\n        Locked,\n        Unlocked,\n    }\n\n    extern \"Rust\" {\n        #[swift_bridge(swift_name = \"getUserState\")]\n        async fn get_user_state(&amp;self) -&gt; Result&lt;UserState, String&gt;;\n      }\n}\n</code></pre> <p>For the above function it will generate the following C ABI in the backgroud, which will make the bridge with Swift possible:</p> <pre><code>pub extern \"C\" fn __swift_bridge__CryptpaySdk_get_user_state(callback_wrapper: *mut std::ffi::c_void, callback: extern \"C\" fn(*mut std::ffi::c_void, ResultUserStateAndString), this: *mut super::CryptpaySdk)\n</code></pre> <p>In the <code>java</code> bindings we serialize any complex return values into JSON and return a <code>String</code>. We also take enum variants as <code>Strings</code> and perform conversion internally.  </p> <p>The <code>swift-bridge</code> crate supports sharing standard library types between Rust and Swift. We can return <code>Result</code> or <code>Option</code> types in the response which can contain a complex type such as a <code>struct</code> or <code>enum</code>. These types can ba used in the response and also as function arguments. In our case, we always return a <code>Result</code> type and on the <code>Err</code> case we are returning a formatted <code>String</code> of the internal SDK error.</p> <p>The swift-bridge allows this if we declare shared types between Rust and Swift in the bridge module as shown in the example above with the <code>UserState</code> enum.</p> <p>Additionally, we should write the conversion between these types. In our case we have developed a helper macro for generating the <code>From</code> implementations for enums and structs. In other cases we do the conversion manually, depending on the use case and limitations.</p> <pre><code>convert_enum!(\n    sdk::types::users::UserState,\n    ffi::UserState,\n    Undefined,\n    New,\n    Verified,\n    Locked,\n    Unlocked,\n);\n</code></pre> <p>There are still some limitations with this library to passing some complex types and require some adaptations to work out. For example, the <code>Option&lt;String&gt;</code> type is not supported in return structs. In this case, the workaround would be to use <code>.unwrap_or(\"\".to_string())</code> on the Option value. It attempts to unwrap the <code>Option</code> that comes from the SDK and get the <code>String</code> value. Otherwise, if the unwrap fails, meaning we get a <code>None</code> value, it returns an empty <code>String</code> which would be equivalent to the <code>None</code> value. For more information regarding the supported build-in types refer to the official documentation of <code>swift-bridge</code> crate.  </p>"},{"location":"Under%20the%20Hood/SDK%20Internals/#async-support","title":"async support","text":"<p>As we can see from the example above, the <code>swift-bridge</code> library supports <code>async/await</code> functions between Swift and Rust. Calling an async Rust function from Swift is supported. Calling an async Swift function from Rust is not yet supported. In our case, we are exporting async functions from Rust to Swift, which is supported. Therefore we do not need to embedd a runtime (such as <code>tokio</code>) ourselves!</p> <p>At build time, on the background, it runs <code>swift-bridge-build</code> on files that contain bridge modules in order to generate the Swift and C code necessary to make the bridge work.</p>"},{"location":"Under%20the%20Hood/SDK%20Internals/#header-files","title":"header files","text":"<p>The <code>swift-bridge</code> crate along with <code>build.rs</code> is used to create the header files from the source code directly. Although one could write these header files by hand, but for a SDK with many functions, it makes sense to automate it for avoiding errors and missing out any functions.</p> <p>The <code>build.rs</code> links Swift to the Rust native library. Aside the header files, it generates also the Swift files.  </p> <p>It parses the Rust source files for <code>#[swift_bridge::bridge]</code> procedural macro headers and generates the corresponding Swift files. It then writes the auto-generated files to a single Swift file and all of the generated C headers to a single header file. These files are generated under the <code>/include</code> folder so that it can become a part of the xcframework without moving or copying it.  </p> <p>This is what the auto-generated header files structure look like:  </p> <ul> <li>generated/</li> <li>Cawaena-sdk-swift-new/<ul> <li>Cawaena-sdk-swift-new.h</li> <li>Cawaena-sdk-swift-new.swift</li> </ul> </li> <li>SwiftBridgeCore.h</li> <li>SwiftBridgeCore.swift</li> </ul>"},{"location":"Under%20the%20Hood/SDK%20Internals/#hot-and-cold-wallets","title":"Hot and Cold wallets","text":"<p>Users today maintain their crypto-currencies in wallets. A wallet is purely software coupled with a secret store, from which the addresses are deterministically derived from a single seed using hierarchical deterministic procedure. For more information, see BIP-0032. The actual tokens/coins of the cryptocurrency reside on these address. Thus, in reality, the wallet is a method of accessing and controlling the crypto-currency, which in turn always lies on the network and never in a hardware or in the typical sense inside a wallet.</p> <p>Since, the wallet has two components, the software and the storage, this allows to classify the wallet based on how these components are implemented and in which environment, specifically under whose control, these components are running/installed. The wallet matrix is shown as below:</p> Environment Software Storage User/Individual Cold/Hot-Wallet Non-custodial Exchange/Business Hot-Wallet Custodial <p>Users use cold non-custodial wallets to keep access and control over their secret seeds, which effectively give them control over their keys. Some users also use hot custodial wallets to efficiently trade cryptocurrencies at exchanges and participate in various decentralized finance (DeFi) protocols like lending pools, swaps, staking, etc.</p> <p>A well-informed and researched user will temporarily maintain hot custodial wallets to engage with the chain and market and permanently maintain a major chunk of funds to addresses controlled by the non-custodial cold wallet. The user will then shuffle between the two wallets based on funds risk.</p>"},{"location":"Under%20the%20Hood/SDK%20Internals/#hot-wallets-the-swift-side-of-crypto","title":"Hot Wallets: The Swift Side of Crypto","text":"<p>Picture a hot wallet as the bustling city centre of your digital finances. Hot wallets are online, connected to the internet, and readily available for transactions. They provide users with quick access to their cryptocurrencies, making them ideal for active trading and daily transactions. Think of them as your go-to pocket wallet for everyday spending in the digital realm.</p> <p>However, convenience comes at a cost. The very connectivity that makes hot wallets user-friendly also renders them more vulnerable to cyber threats. Hacking attempts and online attacks pose a constant risk, making it crucial for users to exercise caution and implement additional security measures when relying on hot wallets.</p>"},{"location":"Under%20the%20Hood/SDK%20Internals/#cold-wallets-embracing-the-fortress-of-security","title":"Cold Wallets: Embracing the Fortress of Security","text":"<p>Now, shift your focus to the serene fortress nestled away from the hustle and bustle \u2013 the cold wallet. Unlike their hot counterparts, cold wallets remain offline and disconnected from the internet. This deliberate isolation provides a higher level of security, shielding your digital assets from the prying eyes of online threats.</p> <p>Cold wallets are the guardians of large sums of cryptocurrency, often employed for long-term storage. While they may not offer the immediacy of hot wallets, their offline nature makes them an attractive option for those prioritizing the safety and longevity of their crypto investments.</p>"},{"location":"Under%20the%20Hood/SDK%20Internals/#the-iota-wallet","title":"The IOTA wallet","text":"<p>The wallet used within the SDK is the official wallet developed by the IOTA Foundation and maintained in its own SDK found here. The wallet internally uses the stronghold secret management engine also developed by the IOTA Foundation found here. The secret management engine not only stores sensitive data in files but also uses obfuscation and mechanisms against memory dumps to protect the secrets while they are being operated upon in the memory. Stronghold also provides functions for BIP-0032 derivation using the BIP-0044 derivation path mechanism described here. The word list used by the wallet is the word list described in BIP-0039 here.</p> <p>The various coin types supported by BIP-0044 can be found in the list here. Both <code>IOTA</code> and <code>SMR</code> are supported and have the coin types <code>4218</code> and <code>4219</code> respectively.</p> <p>Currently, in its base implementation the IOTA SDK also needs an in-memory key-value store to manage some metadata related to the stronghold engine and other wallet settings. The IOTA SDK uses a rocksdb implementation in rust for this purpose. There are a few noteworthy problems with rocksdb:</p> <ul> <li>rocksdb is not light-weight for mobile end devices and the resulting binaries of the sdk take long to build and are bigger in storage requirements.</li> <li>rocksdb does not support all mobile platforms</li> <li>rocksdb is not maintained on the latest sdks of the android and iOS mobile platforms</li> </ul> <p>After investigation, it was found that the in-memory key-value store was used only for storing some metadata keys and not necessarily need high-performance query execution. Luckily, the IOTA SDK implemented the rocksdb connection as a <code>Storage</code> trait. Since, the SDK already used jammdb for its internal key-value store, a fork was created and the trait was implemented using <code>jammdb</code>. A pull request was created to the upstream, but the dev team at IOTA Foundation recommended to maintain the fork for now, as there would be some new breaking changes coming and the pull request can be created at a later point. The fork is updated regularly and maintained here.</p>"},{"location":"Under%20the%20Hood/SDK%20Internals/#pin-and-password-in-the-sdk","title":"Pin and password in the SDK","text":"<p>Generally, the password requirements for any application need to meet today's standards. This might become difficult for the user to remember their wallet stronghold password and also an irritating experience to enter it every time even for the smallest of transactions. On the other side, for a secure wallet application, the SDK should not rely on the interfacing application to do password management for a secret manager used internally. This has a lot of side effects, such as, the application might bypass the SDK logic for protecting access to the secret by simply using the password against the file, with no knowledge of the SDK. This is a security risk and cannot be accepted.</p> <p>The end devices today support pin entry mostly protected by biometric authentication for ease but secure user experience, when it comes to accessing a restricted OS functionality. Taking all this in account, the SDK was designed to provide the end users possibilities to set up their wallet using a password and a pin.</p> <p>The password stays with the SDK in an encrypted form and only the pin can be used to decrypt it. Thus, for every operation with the secret manager, where a password is needed, the user must only enter the pin, or allow the application to fetch it through bio-metrically protected secure storages on end devices. This solves the problem of user experience.</p> <p>The issue of password management is also solved, since now the SDK internally manages the password, while still relying completely on the user to unblock it using the pin. The SDK cannot act in its own interest even if there was a malicious code trying to unblock the wallet! The probability distribution of the pin, being relatively weak, (4 to 6 digit), is improved through the addition of a pseudo random salt, which in combination with a hash function results in an encryption password of significant strength and quasi-random probability distribution. This is used then to encrypt the password for the secret manager.</p> <p>Thus an attacker would need information on the salt, the encrypted password, pin and the stronghold file to be able to gain access to the wallet functions. This is tough and would need somehow physical access to the end device, and to the end user. Security of end-user and their devices is out of the scope for Cawaena ecosystem.</p>"},{"location":"Under%20the%20Hood/SDK%20Internals/#vertical-spreads","title":"Vertical spreads","text":"<p>A vertical spread in the context of exchange rates between two currencies for a crypto exchange refers to the price difference (spread) between the bid and ask prices of a particular cryptocurrency pair.</p> <p>In a vertical spread, the bid price represents the highest price that a buyer is willing to pay for a specific cryptocurrency, while the ask price represents the lowest price at which a seller is willing to sell the same cryptocurrency. The vertical spread is the numerical difference between these two prices.</p> <p>For example, let's say the bid price for Bitcoin (BTC) against US Dollar (USD) is $50,000 and the ask price is $50,100. The vertical spread in this case would be $100 ($50,100 - $50,000).</p> <p>Vertical spreads are significant for traders and investors because they indicate liquidity and market depth. A narrow spread suggests a highly liquid market with many buyers and sellers, whereas a wide spread may indicate lower liquidity and potentially higher transaction costs. Traders often look for tight vertical spreads when executing trades to minimize costs and ensure efficient transactions.</p> <p>If an exchange offers no vertical spread, it means that the bid and ask prices for a particular cryptocurrency pair are identical or extremely close to each other. Essentially, there is no difference between the highest price a buyer is willing to pay (bid price) and the lowest price a seller is willing to accept (ask price).</p> <p>Having no vertical spread implies high liquidity and efficiency in the market. It indicates that there are many buyers and sellers actively trading the cryptocurrency pair, resulting in competitive pricing and minimal transaction costs for traders.</p> <p>Exchanges that offer no vertical spread are highly desirable for traders because they allow for instant execution of trades at fair market prices without incurring significant costs associated with spreads. This can contribute to a smoother trading experience and better opportunities for traders to enter and exit positions efficiently.</p> <p>Viviswap takes the burden of the vertical spread on itself by ensuring highest liquidity always! (Tough to achieve)</p>"}]}